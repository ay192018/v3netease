'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var helper = require('@tarojs/helper');
var template = require('@tarojs/shared/dist/template');
var runnerUtils = require('@tarojs/runner-utils');

function getLoaderMeta() {
    return {
        importFrameworkStatement: `
import { h, createApp } from 'vue'
`,
        mockAppStatement: `
const App = createApp({})
`,
        frameworkArgs: 'h, config',
        creator: 'createVue3App',
        creatorLocation: '@tarojs/plugin-framework-vue3/dist/runtime',
        importFrameworkName: 'h',
        isNeedRawLoader: true,
        extraImportForWeb: `
import { initVue3Components } from '@tarojs/components/dist-h5/vue3'
`,
        execBeforeCreateWebApp: `
initVue3Components(component)
`
    };
}

const CUSTOM_WRAPPER = 'custom-wrapper';
function modifyMiniWebpackChain(_ctx, chain, data, config) {
    setVueLoader$1(chain, data, config);
    setLoader$1(chain);
    setDefinePlugin$1(chain);
}
function setVueLoader$1(chain, data, config) {
    var _a;
    const vueLoaderPath = getVueLoaderPath();
    // plugin
    const { VueLoaderPlugin } = require(vueLoaderPath);
    chain
        .plugin('vueLoaderPlugin')
        .use(VueLoaderPlugin);
    // loader
    const vueLoaderOption = {
        optimizeSSR: false,
        transformAssetUrls: {
            video: ['src', 'poster'],
            'live-player': 'src',
            audio: 'src',
            source: 'src',
            image: 'src',
            'cover-image': 'src'
        },
        compilerOptions: {}
    };
    if (config === null || config === void 0 ? void 0 : config.compilerOptions) {
        vueLoaderOption.compilerOptions = Object.assign({}, config.compilerOptions);
    }
    (_a = vueLoaderOption.compilerOptions).nodeTransforms || (_a.nodeTransforms = []);
    vueLoaderOption.compilerOptions.nodeTransforms.unshift((node) => {
        if (node.type === 1 /* ELEMENT */) {
            node = node;
            const nodeName = node.tag;
            if (template.capitalize(template.toCamelCase(nodeName)) in template.internalComponents) {
                // change only ElementTypes.COMPONENT to ElementTypes.ELEMENT
                // and leave ElementTypes.SLOT untouched
                if (node.tagType === 1 /* COMPONENT */) {
                    node.tagType = 0; /* ELEMENT */
                }
                data.componentConfig.includes.add(nodeName);
            }
            if (nodeName === CUSTOM_WRAPPER) {
                node.tagType = 0; /* ELEMENT */
                data.componentConfig.thirdPartyComponents.set(CUSTOM_WRAPPER, new Set());
            }
            const usingComponent = data.componentConfig.thirdPartyComponents.get(nodeName);
            if (usingComponent != null) {
                node.props.forEach(prop => {
                    var _a;
                    if (prop.type === 6 /* ATTRIBUTE */) {
                        usingComponent.add(prop.name);
                    }
                    else if (prop.type === 7 /* DIRECTIVE */) {
                        prop = prop;
                        if (((_a = prop.arg) === null || _a === void 0 ? void 0 : _a.type) === 4 /* SimpleExpression */) {
                            let value = prop.arg.content;
                            if (prop.name === 'on') {
                                value = `on${value}`;
                            }
                            usingComponent.add(value);
                        }
                    }
                });
            }
        }
    });
    chain.module
        .rule('vue')
        .test(helper.REG_VUE)
        .use('vueLoader')
        .loader(vueLoaderPath)
        .options(vueLoaderOption);
}
function setLoader$1(chain) {
    chain.plugin('miniPlugin')
        .tap(args => {
        args[0].loaderMeta = getLoaderMeta();
        return args;
    });
}
function setDefinePlugin$1(chain) {
    chain
        .plugin('definePlugin')
        .tap(args => {
        args[0].ENABLE_ADJACENT_HTML = true;
        args[0].ENABLE_CLONE_NODE = true;
        args[0].ENABLE_TEMPLATE_CONTENT = true;
        args[0].ENABLE_MUTATION_OBSERVER = true;
        return args;
    });
}

function modifyH5WebpackChain(ctx, chain) {
    setStyleLoader(ctx, chain);
    setVueLoader(chain);
    setLoader(chain);
    setTaroApiLoader(chain);
}
function setStyleLoader(ctx, chain) {
    const config = ctx.initialConfig.h5 || {};
    const { styleLoaderOption = {} } = config;
    chain.module
        .rule('customStyle')
        .merge({
        use: [{
                loader: 'style-loader',
                options: styleLoaderOption
            }]
    });
}
function setVueLoader(chain) {
    const vueLoaderPath = getVueLoaderPath();
    // plugin
    const { VueLoaderPlugin } = require(vueLoaderPath);
    chain
        .plugin('vueLoaderPlugin')
        .use(VueLoaderPlugin);
    // loader
    const vueLoaderOption = {
        transformAssetUrls: {
            video: ['src', 'poster'],
            'live-player': 'src',
            audio: 'src',
            source: 'src',
            image: 'src',
            'cover-image': 'src',
            'taro-video': ['src', 'poster'],
            'taro-live-player': 'src',
            'taro-audio': 'src',
            'taro-source': 'src',
            'taro-image': 'src',
            'taro-cover-image': 'src'
        },
        compilerOptions: {
            // https://github.com/vuejs/vue-next/blob/master/packages/compiler-core/src/options.ts
            nodeTransforms: [(node) => {
                    if (node.type === 1 /* ELEMENT */) {
                        node = node;
                        const nodeName = node.tag;
                        if (runnerUtils.DEFAULT_Components.has(nodeName)) {
                            node.tag = `taro-${nodeName}`;
                            node.tagType = 1; /* 0: ELEMENT, 1: COMPONENT */
                        }
                    }
                }]
        }
    };
    chain.module
        .rule('vue')
        .test(helper.REG_VUE)
        .use('vueLoader')
        .loader(vueLoaderPath)
        .options(vueLoaderOption);
}
function setLoader(chain) {
    chain.plugin('mainPlugin')
        .tap(args => {
        args[0].loaderMeta = getLoaderMeta();
        return args;
    });
}
function setTaroApiLoader(chain) {
    chain.merge({
        module: {
            rule: {
                'process-import-taro': {
                    test: /taro-h5[\\/]dist[\\/]index/,
                    loader: require.resolve('./api-loader')
                }
            }
        }
    });
}

var index = (ctx, config = {}) => {
    const { framework } = ctx.initialConfig;
    if (framework !== 'vue3')
        return;
    ctx.modifyWebpackChain(({ chain, webpack, data }) => {
        // 通用
        // setAlias(chain)
        setDefinePlugin(chain, webpack);
        if (process.env.TARO_ENV === 'h5') {
            // H5
            modifyH5WebpackChain(ctx, chain);
        }
        else {
            // 小程序
            modifyMiniWebpackChain(ctx, chain, data, config.mini);
        }
    });
};
// function setAlias (chain) {
//   // 避免 npm link 时，taro composition apis 使用的 vue 和项目使用的 vue 实例不一致。
//   chain.resolve.alias
//     .set('vue', require.resolve('vue'))
// }
function setDefinePlugin(chain, webpack) {
    chain
        .plugin('defined')
        .use(webpack.DefinePlugin, [{
            __VUE_OPTIONS_API__: JSON.stringify(true),
            __VUE_PROD_DEVTOOLS__: JSON.stringify(false)
        }]);
}
function getVueLoaderPath() {
    try {
        return require.resolve('vue-loader', {
            paths: [process.cwd()]
        });
    }
    catch (error) {
        // eslint-disable-next-line no-console
        console.log(helper.chalk.yellow('找不到 vue-loader，请先安装。'));
        process.exit(1);
    }
}

exports['default'] = index;
exports.getVueLoaderPath = getVueLoaderPath;
//# sourceMappingURL=index.js.map
