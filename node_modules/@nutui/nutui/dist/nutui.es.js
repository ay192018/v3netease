var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
/*!
* @nutui/nutui v3.1.16 Sun Jan 30 2022 10:58:05 GMT+0800 (中国标准时间)
* (c) 2021 @jdf2e.
* Released under the MIT License.
*/
import { defineComponent, toRefs, computed, resolveComponent, openBlock, createElementBlock, normalizeStyle, normalizeClass, createVNode, renderSlot, createCommentVNode, h, createElementVNode, createBlock, Fragment, toDisplayString, createTextVNode, watch, onDeactivated, onBeforeUnmount, onMounted, onActivated, Transition, withCtx, withDirectives, withModifiers, vShow, inject, provide, reactive, onBeforeMount, Teleport, ref, nextTick, getCurrentInstance, renderList, render, onUnmounted, unref, mergeProps, watchEffect, shallowReactive, markRaw, isVNode, toRaw, readonly, vModelText, createSlots } from "vue";
import { useRouter } from "vue-router";
function createComponent(name) {
  const componentName2 = "nut-" + name;
  return {
    componentName: componentName2,
    create: function(_component) {
      _component.baseName = name;
      _component.name = componentName2;
      _component.install = (vue) => {
        vue.component(_component.name, _component);
      };
      return defineComponent(_component);
    },
    createDemo: function(_component) {
      _component.baseName = name;
      _component.name = "demo-" + name;
      return defineComponent(_component);
    }
  };
}
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const { componentName: componentName$14, create: create$1p } = createComponent("avatar");
const _sfc_main$1p = create$1p({
  props: {
    size: {
      type: String,
      default: "normal"
    },
    shape: {
      type: String,
      default: "round"
    },
    bgColor: {
      type: String,
      default: "#eee"
    },
    icon: {
      type: String,
      default: ""
    }
  },
  emits: ["active-avatar"],
  setup(props, { emit, slots }) {
    const { size, shape, bgColor, icon } = toRefs(props);
    const sizeValue = ["large", "normal", "small"];
    const classes = computed(() => {
      const prefixCls = componentName$14;
      return {
        [prefixCls]: true,
        ["avatar-" + size.value]: true,
        ["avatar-" + shape.value]: true
      };
    });
    const styles = computed(() => {
      return {
        width: sizeValue.indexOf(size.value) > -1 ? "" : `${size.value}px`,
        height: sizeValue.indexOf(size.value) > -1 ? "" : `${size.value}px`,
        backgroundColor: `${bgColor.value}`
      };
    });
    const iconStyles = computed(() => {
      return !!icon.value ? icon.value : "";
    });
    const isShowText = computed(() => {
      return slots.default;
    });
    const activeAvatar = (event) => {
      emit("active-avatar", event);
    };
    return {
      classes,
      styles,
      iconStyles,
      isShowText,
      activeAvatar
    };
  }
});
const _hoisted_1$$ = {
  key: 0,
  class: "text"
};
function _sfc_render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    style: normalizeStyle(_ctx.styles),
    class: normalizeClass(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.activeAvatar(_ctx.e))
  }, [
    createVNode(_component_nut_icon, {
      class: "icon",
      name: _ctx.iconStyles
    }, null, 8, ["name"]),
    _ctx.isShowText ? (openBlock(), createElementBlock("view", _hoisted_1$$, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true)
  ], 6);
}
var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$1h]]);
const pxCheck = (value) => {
  return isNaN(Number(value)) ? String(value) : `${value}px`;
};
const { componentName: componentName$13, create: create$1o } = createComponent("icon");
const _sfc_main$1o = create$1o({
  props: {
    name: { type: String, default: "" },
    size: { type: [String, Number], default: "" },
    classPrefix: { type: String, default: "nut-icon" },
    fontClassName: { type: String, default: "nutui-iconfont" },
    color: { type: String, default: "" },
    tag: { type: String, default: "i" }
  },
  emits: ["click"],
  setup(props, { emit, slots }) {
    const handleClick = (event) => {
      emit("click", event);
    };
    const isImage = () => {
      return props.name ? props.name.indexOf("/") !== -1 : false;
    };
    return () => {
      var _a;
      const _isImage = isImage();
      return h(_isImage ? "img" : props.tag, {
        class: _isImage ? `${componentName$13}__img` : `${props.fontClassName} ${componentName$13} ${props.classPrefix}-${props.name}`,
        style: {
          color: props.color,
          fontSize: pxCheck(props.size),
          width: pxCheck(props.size),
          height: pxCheck(props.size)
        },
        onClick: handleClick,
        src: _isImage ? props.name : ""
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const { componentName: componentName$12, create: create$1n } = createComponent("button");
const _sfc_main$1n = create$1n({
  components: {
    [_sfc_main$1o.name]: _sfc_main$1o
  },
  props: {
    color: String,
    shape: {
      type: String,
      default: "round"
    },
    plain: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "default"
    },
    size: {
      type: String,
      default: "normal"
    },
    block: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ""
    }
  },
  emits: ["click"],
  setup(props, { emit, slots }) {
    const { type, size, shape, disabled, loading, color, plain, block } = toRefs(props);
    const handleClick = (event) => {
      if (!loading.value && !disabled.value) {
        emit("click", event);
      }
    };
    const classes = computed(() => {
      const prefixCls = componentName$12;
      return {
        [prefixCls]: true,
        [`${prefixCls}--${type.value}`]: type.value,
        [`${prefixCls}--${size.value}`]: size.value,
        [`${prefixCls}--${shape.value}`]: shape.value,
        [`${prefixCls}--plain`]: plain.value,
        [`${prefixCls}--block`]: block.value,
        [`${prefixCls}--disabled`]: disabled.value,
        [`${prefixCls}--loading`]: loading.value
      };
    });
    const getStyle = computed(() => {
      var _a;
      const style = {};
      if (color == null ? void 0 : color.value) {
        if (plain.value) {
          style.color = color.value;
          style.background = "#fff";
          if (!((_a = color.value) == null ? void 0 : _a.includes("gradient"))) {
            style.borderColor = color.value;
          }
        } else {
          style.color = "#fff";
          style.background = color.value;
        }
      }
      return style;
    });
    return {
      handleClick,
      classes,
      getStyle
    };
  }
});
const _hoisted_1$_ = { class: "nut-button__warp" };
function _sfc_render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.getStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createElementVNode("view", _hoisted_1$_, [
      _ctx.loading ? (openBlock(), createBlock(_component_nut_icon, {
        key: 0,
        class: "nut-icon-loading"
      })) : createCommentVNode("", true),
      _ctx.icon && !_ctx.loading ? (openBlock(), createBlock(_component_nut_icon, {
        key: 1,
        class: normalizeClass(_ctx.icon),
        name: _ctx.icon
      }, null, 8, ["class", "name"])) : createCommentVNode("", true),
      _ctx.$slots.default ? (openBlock(), createElementBlock("view", {
        key: 2,
        class: normalizeClass({ text: _ctx.icon || _ctx.loading })
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2)) : createCommentVNode("", true)
    ])
  ], 6);
}
var Button = /* @__PURE__ */ _export_sfc(_sfc_main$1n, [["render", _sfc_render$1g]]);
const { componentName: componentName$11, create: create$1m } = createComponent("cell");
const _sfc_main$1m = create$1m({
  props: {
    title: { type: String, default: "" },
    subTitle: { type: String, default: "" },
    desc: { type: String, default: "" },
    descTextAlign: { type: String, default: "right" },
    isLink: { type: Boolean, default: false },
    to: [String, Object],
    replace: { type: Boolean, default: false },
    roundRadius: { type: [String, Number], default: "" },
    url: { type: String, default: "" },
    icon: { type: String, default: "" }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$11;
      return {
        [prefixCls]: true,
        [`${prefixCls}--clickable`]: props.isLink || props.to
      };
    });
    const router = useRouter();
    const baseStyle = computed(() => {
      return {
        borderRadius: pxCheck(props.roundRadius)
      };
    });
    const handleClick = (event) => {
      emit("click", event);
      if (props.to && router) {
        router[props.replace ? "replace" : "push"](props.to);
      } else if (props.url) {
        props.replace ? location.replace(props.url) : location.href = props.url;
      }
    };
    return {
      handleClick,
      classes,
      baseStyle
    };
  }
});
const _hoisted_1$Z = { class: "title" };
const _hoisted_2$O = { class: "nut-cell__title-desc" };
function _sfc_render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.baseStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      _ctx.title || _ctx.subTitle || _ctx.icon ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: normalizeClass(["nut-cell__title", { icon: _ctx.icon || _ctx.$slots.icon }])
      }, [
        _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 0 }) : _ctx.icon ? (openBlock(), createBlock(_component_nut_icon, {
          key: 1,
          class: "icon",
          name: _ctx.icon
        }, null, 8, ["name"])) : createCommentVNode("", true),
        _ctx.subTitle ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createElementVNode("view", _hoisted_1$Z, toDisplayString(_ctx.title), 1),
          createElementVNode("view", _hoisted_2$O, toDisplayString(_ctx.subTitle), 1)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 3 }, [
          createTextVNode(toDisplayString(_ctx.title), 1)
        ], 64))
      ], 2)) : createCommentVNode("", true),
      _ctx.desc ? (openBlock(), createElementBlock("view", {
        key: 1,
        class: "nut-cell__value",
        style: normalizeStyle({ "text-align": _ctx.descTextAlign })
      }, toDisplayString(_ctx.desc), 5)) : createCommentVNode("", true),
      _ctx.$slots.link ? renderSlot(_ctx.$slots, "link", { key: 2 }) : _ctx.isLink || _ctx.to ? (openBlock(), createBlock(_component_nut_icon, {
        key: 3,
        class: "nut-cell__link",
        name: "right"
      })) : createCommentVNode("", true)
    ])
  ], 6);
}
var Cell = /* @__PURE__ */ _export_sfc(_sfc_main$1m, [["render", _sfc_render$1f]]);
const { componentName: componentName$10, create: create$1l } = createComponent("cell-group");
const _sfc_main$1l = create$1l({
  props: {
    title: { type: String, default: "" },
    desc: { type: String, default: "" }
  },
  setup() {
    const classes = computed(() => {
      const prefixCls = componentName$10;
      return {
        [prefixCls]: true
      };
    });
    return {
      classes
    };
  }
});
const _hoisted_1$Y = {
  key: 1,
  class: "nut-cell-group__title"
};
const _hoisted_2$N = {
  key: 3,
  class: "nut-cell-group__desc"
};
const _hoisted_3$B = { class: "nut-cell-group__warp" };
function _sfc_render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }) : _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_1$Y, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
    _ctx.$slots.desc ? renderSlot(_ctx.$slots, "desc", { key: 2 }) : _ctx.desc ? (openBlock(), createElementBlock("view", _hoisted_2$N, toDisplayString(_ctx.desc), 1)) : createCommentVNode("", true),
    createElementVNode("view", _hoisted_3$B, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var CellGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1l, [["render", _sfc_render$1e]]);
const { componentName: componentName$$, create: create$1k } = createComponent("price");
const _sfc_main$1k = create$1k({
  props: {
    price: {
      type: [Number, String],
      default: 0
    },
    needSymbol: {
      type: Boolean,
      default: true
    },
    symbol: {
      type: String,
      default: "&yen;"
    },
    decimalDigits: {
      type: [Number, String],
      default: 2
    },
    thousands: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: "before"
    },
    size: {
      type: String,
      default: "large"
    }
  },
  setup(props) {
    const classes = computed(() => {
      return {
        [componentName$$]: true
      };
    });
    const showSymbol = computed(() => {
      const symbol = props.needSymbol ? props.symbol : "";
      return symbol;
    });
    const checkPoint = (price) => {
      return String(price).indexOf(".") > 0;
    };
    const formatThousands = (num) => {
      if (Number(num) == 0) {
        num = 0;
      }
      if (checkPoint(num)) {
        num = Number(num).toFixed(props.decimalDigits);
        num = typeof num.split(".") === "string" ? num.split(".") : num.split(".")[0];
      } else {
        num = num.toString();
      }
      if (props.thousands) {
        return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
      } else {
        return num;
      }
    };
    const formatDecimal = (decimalNum) => {
      if (Number(decimalNum) == 0) {
        decimalNum = 0;
      }
      if (checkPoint(decimalNum)) {
        decimalNum = Number(decimalNum).toFixed(props.decimalDigits);
        decimalNum = typeof decimalNum.split(".") === "string" ? 0 : decimalNum.split(".")[1] ? decimalNum.split(".")[1] : 0;
      } else {
        decimalNum = 0;
      }
      const result = "0." + decimalNum;
      const resultFixed = Number(result).toFixed(props.decimalDigits);
      return String(resultFixed).substring(2, resultFixed.length);
    };
    return {
      classes,
      showSymbol,
      checkPoint,
      formatThousands,
      formatDecimal
    };
  }
});
const _hoisted_1$X = ["innerHTML"];
const _hoisted_2$M = ["innerHTML"];
function _sfc_render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.needSymbol && _ctx.position == "before" ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: normalizeClass(["nut-price--symbol", `nut-price--symbol-${_ctx.size}`]),
      innerHTML: _ctx.showSymbol
    }, null, 10, _hoisted_1$X)) : createCommentVNode("", true),
    createElementVNode("view", {
      class: normalizeClass(`nut-price--${_ctx.size}`)
    }, toDisplayString(_ctx.formatThousands(_ctx.price)), 3),
    _ctx.decimalDigits != 0 ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass(`nut-price--decimal-${_ctx.size}`)
    }, ".", 2)) : createCommentVNode("", true),
    createElementVNode("view", {
      class: normalizeClass(`nut-price--decimal-${_ctx.size}`)
    }, toDisplayString(_ctx.formatDecimal(_ctx.price)), 3),
    _ctx.needSymbol && _ctx.position == "after" ? (openBlock(), createElementBlock("view", {
      key: 2,
      class: normalizeClass(["nut-price--symbol", `nut-price--symbol-${_ctx.size}`]),
      innerHTML: _ctx.showSymbol
    }, null, 10, _hoisted_2$M)) : createCommentVNode("", true)
  ], 2);
}
var Price = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$1d]]);
const { componentName: componentName$_, create: create$1j } = createComponent("overlay");
const overlayProps = {
  visible: {
    type: Boolean,
    default: false
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  duration: {
    type: [Number, String],
    default: 0.3
  },
  overlayClass: {
    type: String,
    default: ""
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  overlayStyle: {
    type: Object
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  }
};
const _sfc_main$1j = create$1j({
  props: overlayProps,
  emits: ["click", "update:visible"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$_;
      return {
        [prefixCls]: true,
        [props.overlayClass]: true
      };
    });
    watch(() => props.visible, (value) => {
      value ? lock() : unlock();
    });
    const lock = () => {
      if (props.lockScroll && props.visible) {
        document.body.classList.add("nut-overflow-hidden");
      }
    };
    const unlock = () => {
      document.body.classList.remove("nut-overflow-hidden");
    };
    onDeactivated(unlock);
    onBeforeUnmount(unlock);
    onMounted(lock);
    onActivated(lock);
    const style = computed(() => {
      return __spreadValues({
        animationDuration: `${props.duration}s`,
        zIndex: props.zIndex
      }, props.overlayStyle);
    });
    const touchmove = (e) => {
      if (props.lockScroll)
        e.preventDefault();
    };
    const onClick = (e) => {
      emit("click", e);
      if (props.closeOnClickOverlay) {
        emit("update:visible", false);
      }
    };
    return { classes, style, touchmove, onClick };
  }
});
function _sfc_render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, { name: "overlay-fade" }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("view", {
        class: normalizeClass(_ctx.classes),
        onTouchmove: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.touchmove && _ctx.touchmove(...args), ["stop"])),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
        style: normalizeStyle(_ctx.style)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 38), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  });
}
var OverLay = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$1c]]);
const { componentName: componentName$Z, create: create$1i } = createComponent("divider");
const _sfc_main$1i = create$1i({
  props: {
    contentPosition: {
      type: String,
      default: "center"
    },
    dashed: {
      type: Boolean,
      default: false
    },
    hairline: {
      type: Boolean,
      default: true
    }
  },
  components: {},
  setup(props, context) {
    const classes = computed(() => {
      const prefixCls = componentName$Z;
      return {
        [prefixCls]: true,
        [`${prefixCls}-center`]: context.slots.default,
        [`${prefixCls}-left`]: props.contentPosition === "left",
        [`${prefixCls}-right`]: props.contentPosition === "right",
        [`${prefixCls}-dashed`]: props.dashed,
        [`${prefixCls}-hairline`]: props.hairline
      };
    });
    return { classes };
  }
});
function _sfc_render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var Divider = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$1b]]);
const { create: create$1h } = createComponent("layout");
const _sfc_main$1h = create$1h({});
const { componentName: componentName$Y, create: create$1g } = createComponent("col");
const _sfc_main$1g = create$1g({
  props: {
    span: {
      type: [String, Number],
      default: "24"
    },
    offset: {
      type: [String, Number],
      default: "0"
    }
  },
  setup(props) {
    const prefixCls = componentName$Y;
    const gutter = inject("gutter");
    const classes = computed(() => {
      return {
        [prefixCls]: true,
        [prefixCls + "-gutter"]: gutter,
        ["nut-col-" + props.span]: true,
        ["nut-col-offset-" + props.offset]: true
      };
    });
    const style = computed(() => {
      return {
        paddingLeft: gutter / 2 + "px",
        paddingRight: gutter / 2 + "px"
      };
    });
    return {
      classes,
      style
    };
  }
});
function _sfc_render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var Col = /* @__PURE__ */ _export_sfc(_sfc_main$1g, [["render", _sfc_render$1a]]);
const { componentName: componentName$X, create: create$1f } = createComponent("row");
const _sfc_main$1f = create$1f({
  props: {
    type: {
      type: String,
      default: ""
    },
    gutter: {
      type: [String, Number],
      default: ""
    },
    justify: {
      type: String,
      default: "start"
    },
    align: {
      type: String,
      default: "flex-start"
    },
    wrap: {
      type: String,
      default: "nowrap"
    }
  },
  setup(props) {
    const prefixCls = componentName$X;
    provide("gutter", props.gutter);
    const getClass = (prefix, type) => {
      return prefix ? type ? `nut-row-${prefix}-${type}` : "" : `nut-row-${type}`;
    };
    const getClasses = () => {
      return `
              ${getClass("", props.type)}
              ${getClass("justify", props.justify)}
              ${getClass("align", props.align)}
              ${getClass("flex", props.wrap)}
              ${prefixCls}
              `;
    };
    return {
      getClasses
    };
  }
});
function _sfc_render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.getClasses())
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var Row = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$19]]);
let count = 0;
const CLSNAME = "nut-overflow-hidden";
const useLockScroll = (isLock) => {
  const lock = () => {
    if (isLock()) {
      !count && document.body.classList.add(CLSNAME);
      count++;
    }
  };
  const unlock = () => {
    if (isLock() && count) {
      count--;
      !count && document.body.classList.remove(CLSNAME);
    }
  };
  return [lock, unlock];
};
const { componentName: componentName$W, create: create$1e } = createComponent("popup");
let _zIndex = 2e3;
const popupProps = __spreadProps(__spreadValues({}, overlayProps), {
  position: {
    type: String,
    default: "center"
  },
  transition: String,
  style: {
    type: Object
  },
  popClass: {
    type: String,
    default: ""
  },
  closeable: {
    type: Boolean,
    default: false
  },
  closeIconPosition: {
    type: String,
    default: "top-right"
  },
  closeIcon: {
    type: String,
    default: "close"
  },
  destroyOnClose: {
    type: Boolean,
    default: true
  },
  teleport: {
    type: [String, Element],
    default: "body"
  },
  overlay: {
    type: Boolean,
    default: true
  },
  round: {
    type: Boolean,
    default: false
  },
  isWrapTeleport: {
    type: Boolean,
    default: true
  }
});
const _sfc_main$1e = create$1e({
  components: {
    [OverLay.name]: OverLay,
    [_sfc_main$1o.name]: _sfc_main$1o
  },
  props: __spreadValues({}, popupProps),
  emits: ["click", "click-close-icon", "open", "close", "opend", "closed", "update:visible", "click-overlay"],
  setup(props, { emit }) {
    const state = reactive({
      zIndex: props.zIndex ? props.zIndex : _zIndex,
      showSlot: true,
      transitionName: `popup-fade-${props.position}`,
      overLayCount: 1,
      keepAlive: false,
      closed: props.closeable
    });
    const [lockScroll, unlockScroll] = useLockScroll(() => props.lockScroll);
    const classes = computed(() => {
      const prefixCls = componentName$W;
      return {
        [prefixCls]: true,
        ["round"]: props.round,
        [`popup-${props.position}`]: true,
        [props.popClass]: true
      };
    });
    const popStyle = computed(() => {
      return __spreadValues({
        zIndex: state.zIndex,
        animationDuration: props.duration ? `${props.duration}s` : "initial"
      }, props.style);
    });
    const open = () => {
      if (!props.visible) {
        if (props.zIndex !== void 0) {
          _zIndex = Number(props.zIndex);
        }
        emit("update:visible", true);
        lockScroll();
        state.zIndex = ++_zIndex;
      }
      if (props.destroyOnClose) {
        state.showSlot = true;
      }
      emit("open");
    };
    const close = () => {
      if (props.visible) {
        unlockScroll();
        emit("update:visible", false);
        if (props.destroyOnClose) {
          setTimeout(() => {
            state.showSlot = false;
            emit("close");
          }, +props.duration * 1e3);
        }
      }
    };
    const onClick = (e) => {
      emit("click", e);
    };
    const onClickCloseIcon = (e) => {
      emit("click-close-icon", e);
      close();
    };
    const onClickOverlay = (e) => {
      if (props.closeOnClickOverlay) {
        emit("click-overlay", e);
        close();
      }
    };
    const onOpened = (e) => {
      emit("opend", e);
    };
    const onClosed = (e) => {
      emit("closed", e);
    };
    onMounted(() => {
      props.transition ? state.transitionName = props.transition : state.transitionName = `popup-slide-${props.position}`;
      props.visible && open();
    });
    onBeforeUnmount(() => {
      props.visible && close();
    });
    onBeforeMount(() => {
      if (props.visible) {
        unlockScroll();
      }
    });
    onActivated(() => {
      if (state.keepAlive) {
        emit("update:visible", true);
        state.keepAlive = false;
      }
    });
    onDeactivated(() => {
      if (props.visible) {
        close();
        state.keepAlive = true;
      }
    });
    watch(() => props.visible, (value) => {
      if (value) {
        open();
      } else {
        close();
      }
    });
    watch(() => props.position, (value) => {
      value === "center" ? state.transitionName = "popup-fade" : state.transitionName = `popup-slide-${value}`;
    });
    watch(() => props.closeable, (value) => {
      state.closed = value;
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      popStyle,
      classes,
      onClick,
      onClickCloseIcon,
      onClickOverlay,
      onOpened,
      onClosed
    });
  }
});
const _hoisted_1$W = { key: 1 };
function _sfc_render$18(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_overlay = resolveComponent("nut-overlay");
  const _component_nut_icon = resolveComponent("nut-icon");
  return _ctx.isWrapTeleport ? (openBlock(), createBlock(Teleport, {
    key: 0,
    to: _ctx.teleport
  }, [
    _ctx.overlay ? (openBlock(), createBlock(_component_nut_overlay, {
      key: 0,
      visible: _ctx.visible,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      class: normalizeClass(_ctx.overlayClass),
      style: normalizeStyle(_ctx.overlayStyle),
      "z-index": _ctx.zIndex,
      "lock-scroll": _ctx.lockScroll,
      duration: _ctx.duration,
      onClick: _ctx.onClickOverlay
    }, null, 8, ["visible", "close-on-click-overlay", "class", "style", "z-index", "lock-scroll", "duration", "onClick"])) : createCommentVNode("", true),
    createVNode(Transition, {
      name: _ctx.transitionName,
      onAfterEnter: _ctx.onOpened,
      onAfterLeave: _ctx.onClosed
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("view", {
          class: normalizeClass(_ctx.classes),
          style: normalizeStyle(_ctx.popStyle),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick && _ctx.onClick(...args))
        }, [
          _ctx.showSlot ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
          _ctx.closed ? (openBlock(), createElementBlock("view", {
            key: 1,
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickCloseIcon && _ctx.onClickCloseIcon(...args)),
            class: normalizeClass(["nutui-popup__close-icon", "nutui-popup__close-icon--" + _ctx.closeIconPosition])
          }, [
            createVNode(_component_nut_icon, {
              name: _ctx.closeIcon,
              size: "12px"
            }, null, 8, ["name"])
          ], 2)) : createCommentVNode("", true)
        ], 6), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ], 8, ["to"])) : (openBlock(), createElementBlock("view", _hoisted_1$W, [
    _ctx.overlay ? (openBlock(), createBlock(_component_nut_overlay, {
      key: 0,
      visible: _ctx.visible,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      class: normalizeClass(_ctx.overlayClass),
      style: normalizeStyle(_ctx.overlayStyle),
      "z-index": _ctx.zIndex,
      "lock-scroll": _ctx.lockScroll,
      duration: _ctx.duration,
      onClick: _ctx.onClickOverlay
    }, null, 8, ["visible", "close-on-click-overlay", "class", "style", "z-index", "lock-scroll", "duration", "onClick"])) : createCommentVNode("", true),
    createVNode(Transition, {
      name: _ctx.transitionName,
      onAfterEnter: _ctx.onOpened,
      onAfterLeave: _ctx.onClosed
    }, {
      default: withCtx(() => [
        withDirectives(createElementVNode("view", {
          class: normalizeClass(_ctx.classes),
          style: normalizeStyle(_ctx.popStyle),
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.onClick && _ctx.onClick(...args))
        }, [
          _ctx.showSlot ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
          _ctx.closed ? (openBlock(), createElementBlock("view", {
            key: 1,
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.onClickCloseIcon && _ctx.onClickCloseIcon(...args)),
            class: normalizeClass(["nutui-popup__close-icon", "nutui-popup__close-icon--" + _ctx.closeIconPosition])
          }, [
            createVNode(_component_nut_icon, {
              name: _ctx.closeIcon,
              size: "12px"
            }, null, 8, ["name"])
          ], 2)) : createCommentVNode("", true)
        ], 6), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ]));
}
var Popup = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$18]]);
const throttle = (func, wait, type) => {
  if (type === 1) {
    var previous = 0;
  } else if (type === 2) {
    var timeout;
  }
  return function() {
    let context = this;
    let args = arguments;
    if (type === 1) {
      let now = Date.now();
      if (now - previous > wait) {
        func.apply(context, args);
        previous = now;
      }
    } else if (type === 2) {
      if (!timeout) {
        timeout = setTimeout(() => {
          timeout = null;
          func.apply(context, args);
        }, wait);
      }
    }
  };
};
const { create: create$1d } = createComponent("video");
const _sfc_main$1d = create$1d({
  props: {
    source: {
      type: Object,
      default: {}
    },
    options: {
      type: Object,
      default: {
        autoplay: false,
        volume: 0.5,
        poster: "",
        loop: false,
        controls: true,
        muted: false,
        disabled: false,
        playsinline: false,
        touchPlay: false,
        preload: ""
      },
      required: true
    },
    model: {
      type: String,
      default: ""
    }
  },
  components: {},
  emits: ["click", "play", "pause", "playend"],
  setup(props, { emit }) {
    const state = reactive({
      videoElm: null,
      initial: true,
      showToolbox: false,
      player: {
        $player: null,
        pos: null
      },
      progressBar: {
        progressElm: null,
        pos: null
      },
      videoSet: {
        loaded: 0,
        displayTime: "00:00",
        totalTime: "00:00",
        progress: {
          width: 0,
          current: 0
        }
      },
      state: {
        controlShow: true,
        vol: 0.5,
        currentTime: 0,
        fullScreen: false,
        playing: false,
        isLoading: false,
        isEnd: false,
        isError: false,
        isMuted: false
      },
      showTouchMask: false
    });
    const root = ref();
    const isDisabled = computed(() => {
      return props.options.disabled;
    });
    watch(props.source, (newValue) => {
      if (newValue.src) {
        nextTick(() => {
          state.videoElm.load();
        });
      }
    });
    watch(props.options, (newValue) => {
      state.state.isMuted = newValue.muted ? newValue.muted : false;
    }, { immediate: true });
    const init = () => {
      state.videoElm = root.value;
      if (props.options.autoplay) {
        state.videoElm.play();
      }
      if (props.options.touchPlay) {
        state.showTouchMask = true;
      }
      if (props.options.playsinline) {
        state.videoElm.setAttribute("playsinline", props.options.playsinline);
        state.videoElm.setAttribute("webkit-playsinline", props.options.playsinline);
        state.videoElm.setAttribute("x5-video-player-type", "h5-page");
        state.videoElm.setAttribute("x5-video-player-fullscreen", false);
      }
      volumeHandle();
      if (state.showToolbox) {
        customerInit();
      } else {
        state.videoElm.addEventListener("play", () => {
          state.state.playing = true;
          emit("play", state.videoElm);
        });
        state.videoElm.addEventListener("pause", () => {
          state.state.playing = false;
          emit("pause", state.videoElm);
        });
        state.videoElm.addEventListener("ended", playEnded);
        state.videoElm.addEventListener("timeupdate", throttle(getPlayTime, 100, 1));
      }
    };
    const customerInit = () => {
      const $player = root.value;
      const $progress = root.value.getElementsByClassName("progress")[0];
      state.player.$player = $player;
      state.progressBar.progressElm = $progress;
      state.progressBar.pos = $progress.getBoundingClientRect();
      state.videoSet.progress.width = Math.round($progress.getBoundingClientRect().width);
    };
    const play = () => {
      if (props.options.autoplay && props.options.disabled) {
        state.state.playing = true;
        return false;
      }
      state.state.playing = !state.state.playing;
      if (state.videoElm) {
        if (state.state.playing) {
          try {
            state.videoElm.play();
            state.videoElm.addEventListener("progress", () => {
              getLoadTime();
            });
            state.videoElm.addEventListener("timeupdate", throttle(getPlayTime, 100, 1));
            state.videoElm.addEventListener("ended", playEnded);
            emit("play", state.videoElm);
          } catch (e) {
            handleError();
          }
        } else {
          state.videoElm.pause();
          emit("pause", state.videoElm);
        }
      }
    };
    const timeFormat = (t) => {
      var h2 = Math.floor(t / 3600);
      if (h2 < 10) {
        h2 = "0" + h2;
      }
      var m = Math.floor(t % 3600 / 60);
      if (m < 10) {
        m = "0" + m;
      }
      var s = Math.round(t % 3600 % 60);
      if (s < 10) {
        s = "0" + s;
      }
      var str = "";
      if (h2 != 0) {
        str = h2 + ":" + m + ":" + s;
      } else {
        str = m + ":" + s;
      }
      return str;
    };
    const getLoadTime = () => {
      if (state.videoSet.loaded)
        state.videoSet.loaded = state.videoElm.buffered.end(0) / state.videoElm.duration * 100;
    };
    const getPlayTime = () => {
      const percent = state.videoElm.currentTime / state.videoElm.duration;
      state.videoSet.progress.current = Math.round(state.videoSet.progress.width * percent);
      state.videoSet.totalTime = timeFormat(state.videoElm.duration);
      state.videoSet.displayTime = timeFormat(state.videoElm.currentTime);
    };
    const playEnded = () => {
      state.state.playing = false;
      state.state.isEnd = true;
      state.videoSet.displayTime = "00:00";
      state.videoSet.progress.current = 0;
      state.videoElm.currentTime = 0;
      emit("playend", state.videoElm);
    };
    const handleError = () => {
      state.state.isError = true;
    };
    const volumeHandle = () => {
      state.state.vol = props.options.volume;
    };
    const handleMuted = () => {
      state.state.isMuted = !state.state.isMuted;
      state.videoElm.muted = state.state.isMuted;
    };
    const touchSlidSrart = () => {
    };
    const touchSlidMove = (e) => {
      let currentX = e.targetTouches[0].pageX;
      let offsetX = currentX - state.progressBar.pos.left;
      if (offsetX <= 0) {
        offsetX = 0;
      }
      if (offsetX >= state.videoSet.progress.width) {
        offsetX = state.videoSet.progress.width;
      }
      state.videoSet.progress.current = offsetX;
      let percent = state.videoSet.progress.current / state.videoSet.progress.width;
      state.videoElm.duration && setPlayTime(percent, state.videoElm.duration);
    };
    const touchSlidEnd = (e) => {
      let currentX = e.changedTouches[0].pageX;
      let offsetX = currentX - state.progressBar.pos.left;
      state.videoSet.progress.current = offsetX;
      let percent = offsetX / state.videoSet.progress.width;
      state.videoElm.duration && setPlayTime(percent, state.videoElm.duration);
    };
    const setPlayTime = (percent, totalTime) => {
      state.videoElm.currentTime = Math.floor(percent * totalTime);
    };
    const retry = () => {
      state.state.isError = false;
      init();
    };
    const fullScreen = () => {
      if (!state.state.fullScreen) {
        state.state.fullScreen = true;
        state.videoElm.webkitRequestFullScreen();
      } else {
        state.state.fullScreen = false;
        document.webkitCancelFullScreen();
      }
    };
    onMounted(() => {
      init();
    });
    return __spreadProps(__spreadValues(__spreadValues({
      root
    }, toRefs(props)), toRefs(state)), {
      handleError,
      isDisabled,
      play,
      handleMuted,
      touchSlidSrart,
      touchSlidMove,
      touchSlidEnd,
      retry,
      fullScreen
    });
  }
});
const _hoisted_1$V = {
  class: "nut-video",
  ref: "videocon"
};
const _hoisted_2$L = ["muted", "autoplay", "loop", "poster", "controls", "preload"];
const _hoisted_3$A = ["src", "type"];
const _hoisted_4$r = { class: "current-time" };
const _hoisted_5$j = { class: "progress-container" };
const _hoisted_6$g = {
  class: "progress",
  ref: "progressBar"
};
const _hoisted_7$b = /* @__PURE__ */ createElementVNode("div", { class: "move-handle" }, null, -1);
const _hoisted_8$8 = [
  _hoisted_7$b
];
const _hoisted_9$6 = {
  class: "played",
  ref: "playedBar"
};
const _hoisted_10$4 = { class: "duration-time" };
const _hoisted_11$4 = { class: "nut-video-error" };
const _hoisted_12$4 = /* @__PURE__ */ createElementVNode("p", { class: "lose" }, "\u89C6\u9891\u52A0\u8F7D\u5931\u8D25", -1);
function _sfc_render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$V, [
    createElementVNode("video", {
      ref: "root",
      class: "nut-video-player",
      muted: _ctx.options.muted,
      autoplay: _ctx.options.autoplay,
      loop: _ctx.options.loop,
      poster: _ctx.options.poster,
      controls: _ctx.options.controls,
      preload: _ctx.options.preload,
      onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args))
    }, [
      createElementVNode("source", {
        src: _ctx.source.src,
        type: _ctx.source.type
      }, null, 8, _hoisted_3$A)
    ], 40, _hoisted_2$L),
    _ctx.showToolbox && !_ctx.isDisabled ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "playing-mask",
      ref: "touchMask",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.play && _ctx.play(...args))
    }, null, 512)) : createCommentVNode("", true),
    _ctx.showToolbox && !_ctx.isDisabled ? withDirectives((openBlock(), createElementBlock("div", {
      key: 1,
      class: "nut-video-play-btn",
      ref: "palyBtn",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.play && _ctx.play(...args))
    }, null, 512)), [
      [vShow, !_ctx.state.playing]
    ]) : createCommentVNode("", true),
    withDirectives(createElementVNode("div", {
      class: normalizeClass(["nut-video-controller", { "show-control": !_ctx.state.playing, "hide-control": _ctx.state.playing }])
    }, [
      createElementVNode("div", {
        class: "control-play-btn",
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.play && _ctx.play(...args))
      }),
      createElementVNode("div", _hoisted_4$r, toDisplayString(_ctx.videoSet.displayTime), 1),
      createElementVNode("div", _hoisted_5$j, [
        createElementVNode("div", _hoisted_6$g, [
          createElementVNode("div", {
            class: "buffered",
            style: normalizeStyle({ width: `${_ctx.videoSet.loaded}%` })
          }, null, 4),
          createElementVNode("div", {
            class: "video-ball",
            style: normalizeStyle({
              transform: `translate3d(${_ctx.videoSet.progress.current}px, -50%, 0)`
            }),
            onTouchmove: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.touchSlidMove($event), ["stop", "prevent"])),
            onTouchstart: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.touchSlidSrart($event), ["stop"])),
            onTouchend: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.touchSlidEnd($event), ["stop"]))
          }, _hoisted_8$8, 36),
          createElementVNode("div", _hoisted_9$6, null, 512)
        ], 512)
      ]),
      createElementVNode("div", _hoisted_10$4, toDisplayString(_ctx.videoSet.totalTime), 1),
      createElementVNode("div", {
        class: normalizeClass(["volume", { muted: _ctx.state.isMuted }]),
        onClick: _cache[7] || (_cache[7] = (...args) => _ctx.handleMuted && _ctx.handleMuted(...args))
      }, null, 2),
      createElementVNode("div", {
        class: "fullscreen-icon",
        onClick: _cache[8] || (_cache[8] = (...args) => _ctx.fullScreen && _ctx.fullScreen(...args))
      })
    ], 2), [
      [vShow, _ctx.showToolbox && !_ctx.isDisabled]
    ]),
    withDirectives(createElementVNode("div", _hoisted_11$4, [
      _hoisted_12$4,
      createElementVNode("p", {
        class: "retry",
        onClick: _cache[9] || (_cache[9] = (...args) => _ctx.retry && _ctx.retry(...args))
      }, "\u70B9\u51FB\u91CD\u8BD5")
    ], 512), [
      [vShow, _ctx.state.isError]
    ])
  ], 512);
}
var Video = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$17]]);
const DISTANCE = 5;
function useTouch$1() {
  const state = reactive({
    startX: 0,
    startY: 0,
    deltaX: 0,
    deltaY: 0,
    offsetX: 0,
    offsetY: 0,
    direction: ""
  });
  const getDirection2 = (x, y) => {
    if (x > y && x > DISTANCE)
      return "horizontal";
    if (y > x && y > DISTANCE)
      return "vertical";
    return "";
  };
  const reset = () => {
    state.startX = 0;
    state.startY = 0;
    state.deltaX = 0;
    state.deltaY = 0;
    state.offsetX = 0;
    state.offsetY = 0;
    state.direction = "";
  };
  const start = (e) => {
    reset();
    state.startX = e.touches[0].clientX;
    state.startY = e.touches[0].clientY;
  };
  const move = (e) => {
    state.deltaX = e.touches[0].clientX - state.startX;
    state.deltaY = e.touches[0].clientY - state.startY;
    state.offsetX = Math.abs(state.deltaX);
    state.offsetY = Math.abs(state.deltaY);
    if (!state.direction) {
      state.direction = getDirection2(state.offsetX, state.offsetY);
    }
  };
  return {
    state,
    start,
    reset,
    move
  };
}
function useExpose$1(apis) {
  const instance = getCurrentInstance();
  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
const { create: create$1c, componentName: componentName$V } = createComponent("swiper");
const _sfc_main$1c = create$1c({
  props: {
    width: {
      type: [Number, String],
      default: window.innerWidth
    },
    height: {
      type: [Number, String],
      default: 0
    },
    direction: {
      type: [String],
      default: "horizontal"
    },
    paginationVisible: {
      type: Boolean,
      default: false
    },
    paginationColor: {
      type: String,
      default: "#fff"
    },
    loop: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 500
    },
    autoPlay: {
      type: [Number, String],
      default: 0
    },
    initPage: {
      type: [Number, String],
      default: 0
    },
    touchable: {
      type: Boolean,
      default: true
    },
    isPreventDefault: {
      type: Boolean,
      default: true
    },
    isStopPropagation: {
      type: Boolean,
      default: true
    }
  },
  emits: ["change"],
  setup(props, { emit, slots }) {
    const container = ref();
    const state = reactive({
      active: 0,
      num: 0,
      rect: null,
      width: 0,
      height: 0,
      moving: false,
      offset: 0,
      touchTime: 0,
      autoplayTimer: 0,
      children: [],
      style: {}
    });
    const touch = useTouch$1();
    const classes = computed(() => {
      const prefixCls = componentName$V;
      return {
        [prefixCls]: true
      };
    });
    const isVertical = computed(() => props.direction === "vertical");
    const delTa = computed(() => {
      return isVertical.value ? touch.state.deltaY : touch.state.deltaX;
    });
    const isCorrectDirection = computed(() => {
      return touch.state.direction === props.direction;
    });
    const childCount = computed(() => state.children.length);
    const size = computed(() => state[isVertical.value ? "height" : "width"]);
    const trackSize = computed(() => childCount.value * size.value);
    const minOffset = computed(() => {
      if (state.rect) {
        const base = isVertical.value ? state.rect.height : state.rect.width;
        return base - size.value * childCount.value;
      }
      return 0;
    });
    const activePagination = computed(() => (state.active + childCount.value) % childCount.value);
    const getStyle = () => {
      state.style = {
        transitionDuration: `${state.moving ? 0 : props.duration}ms`,
        transform: `translate${isVertical.value ? "Y" : "X"}(${state.offset}px)`,
        [isVertical.value ? "height" : "width"]: `${size.value * childCount.value}px`,
        [isVertical.value ? "width" : "height"]: `${isVertical.value ? state.width : state.height}px`
      };
    };
    const relation = (child) => {
      if (child.proxy) {
        state.children.push(child.proxy);
      }
    };
    const range = (num, min, max) => {
      return Math.min(Math.max(num, min), max);
    };
    const requestFrame = (fn) => {
      window.requestAnimationFrame.call(window, fn);
    };
    const getOffset = (active, offset = 0) => {
      let currentPosition = active * size.value;
      if (!props.loop) {
        currentPosition = Math.min(currentPosition, -minOffset.value);
      }
      let targetOffset = offset - currentPosition;
      if (!props.loop) {
        targetOffset = range(targetOffset, minOffset.value, 0);
      }
      return targetOffset;
    };
    const getActive = (pace) => {
      const { active } = state;
      if (pace) {
        if (props.loop) {
          return range(active + pace, -1, childCount.value);
        }
        return range(active + pace, 0, childCount.value - 1);
      }
      return active;
    };
    const move = ({ pace = 0, offset = 0, isEmit = false }) => {
      if (childCount.value <= 1)
        return;
      const { active } = state;
      const targetActive = getActive(pace);
      const targetOffset = getOffset(targetActive, offset);
      if (props.loop) {
        if (state.children[0] && targetOffset !== minOffset.value) {
          const rightBound = targetOffset < minOffset.value;
          state.children[0].setOffset(rightBound ? trackSize.value : 0);
        }
        if (state.children[childCount.value - 1] && targetOffset !== 0) {
          const leftBound = targetOffset > 0;
          state.children[childCount.value - 1].setOffset(leftBound ? -trackSize.value : 0);
        }
      }
      state.active = targetActive;
      state.offset = targetOffset;
      if (isEmit && active !== state.active) {
        emit("change", activePagination.value);
      }
      getStyle();
    };
    const resettPosition = () => {
      state.moving = true;
      if (state.active <= -1) {
        move({ pace: childCount.value });
      }
      if (state.active >= childCount.value) {
        move({ pace: -childCount.value });
      }
    };
    const stopAutoPlay = () => {
      clearTimeout(state.autoplayTimer);
    };
    const prev = () => {
      resettPosition();
      touch.reset();
      requestFrame(() => {
        requestFrame(() => {
          state.moving = false;
          move({
            pace: -1,
            isEmit: true
          });
        });
      });
    };
    const next = () => {
      resettPosition();
      touch.reset();
      requestFrame(() => {
        requestFrame(() => {
          state.moving = false;
          move({
            pace: 1,
            isEmit: true
          });
        });
      });
    };
    const to = (index) => {
      resettPosition();
      touch.reset();
      requestFrame(() => {
        requestFrame(() => {
          state.moving = false;
          let targetIndex;
          if (props.loop && childCount.value === index) {
            targetIndex = state.active === 0 ? 0 : index;
          } else {
            targetIndex = index % childCount.value;
          }
          move({
            pace: targetIndex - state.active,
            isEmit: true
          });
        });
      });
    };
    const autoplay = () => {
      if (props.autoPlay <= 0 || childCount.value <= 1)
        return;
      stopAutoPlay();
      state.autoplayTimer = setTimeout(() => {
        next();
        autoplay();
      }, Number(props.autoPlay));
    };
    const init = (active = +props.initPage) => {
      stopAutoPlay();
      state.rect = container.value.getBoundingClientRect();
      active = Math.min(childCount.value - 1, active);
      state.width = props.width ? +props.width : state.rect.width;
      state.height = props.height ? +props.height : state.rect.height;
      state.active = active;
      state.offset = getOffset(state.active);
      state.moving = true;
      getStyle();
      autoplay();
    };
    const onTouchStart = (e) => {
      if (props.isPreventDefault)
        e.preventDefault();
      if (props.isStopPropagation)
        e.stopPropagation();
      if (!props.touchable)
        return;
      touch.start(e);
      state.touchTime = Date.now();
      stopAutoPlay();
      resettPosition();
    };
    const onTouchMove = (e) => {
      if (props.touchable && state.moving) {
        touch.move(e);
        if (isCorrectDirection.value) {
          move({
            offset: delTa.value
          });
        }
      }
    };
    const onTouchEnd = (e) => {
      if (!props.touchable || !state.moving)
        return;
      const speed = delTa.value / (Date.now() - state.touchTime);
      const isShouldMove = Math.abs(speed) > 0.3 || Math.abs(delTa.value) > +(size.value / 2).toFixed(2);
      if (isShouldMove && isCorrectDirection.value) {
        let pace = 0;
        const offset = isVertical.value ? touch.state.offsetY : touch.state.offsetX;
        if (props.loop) {
          pace = offset > 0 ? delTa.value > 0 ? -1 : 1 : 0;
        } else {
          pace = -Math[delTa.value > 0 ? "ceil" : "floor"](delTa.value / size.value);
        }
        move({
          pace,
          isEmit: true
        });
      } else if (delTa.value) {
        move({ pace: 0 });
      }
      state.moving = false;
      getStyle();
      autoplay();
    };
    provide("parent", {
      props,
      size,
      relation
    });
    useExpose$1({
      prev,
      next,
      to
    });
    onMounted(() => {
      nextTick(() => {
        init();
      });
    });
    onActivated(() => {
      nextTick(() => {
        init();
      });
    });
    onDeactivated(() => {
      stopAutoPlay();
    });
    onBeforeUnmount(() => {
      stopAutoPlay();
    });
    watch(() => props.initPage, (val) => {
      nextTick(() => {
        init(Number(val));
      });
    });
    watch(() => state.children.length, () => {
      nextTick(() => {
        init(state.active);
      });
    });
    watch(() => props.autoPlay, (val) => {
      val > 0 ? autoplay() : stopAutoPlay();
    });
    return {
      state,
      classes,
      container,
      componentName: componentName$V,
      isVertical,
      slots,
      activePagination,
      onTouchStart,
      onTouchMove,
      onTouchEnd
    };
  }
});
function _sfc_render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    ref: "container",
    class: normalizeClass(_ctx.classes),
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
    onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
  }, [
    createElementVNode("view", {
      class: normalizeClass({
        [`${_ctx.componentName}-inner`]: true,
        [`${_ctx.componentName}-vertical`]: _ctx.isVertical
      }),
      style: normalizeStyle(_ctx.state.style)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6),
    renderSlot(_ctx.$slots, "page"),
    _ctx.paginationVisible && !_ctx.slots.page ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: normalizeClass({
        [`${_ctx.componentName}-pagination`]: true,
        [`${_ctx.componentName}-pagination-vertical`]: _ctx.isVertical
      })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.state.children.length, (item, index) => {
        return openBlock(), createElementBlock("i", {
          style: normalizeStyle({
            backgroundColor: _ctx.activePagination === index ? _ctx.paginationColor : "#ddd"
          }),
          key: index
        }, null, 4);
      }), 128))
    ], 2)) : createCommentVNode("", true)
  ], 34);
}
var Swiper = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$16]]);
function useExpose(apis) {
  const instance = getCurrentInstance();
  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
const { create: create$1b, componentName: componentName$U } = createComponent("swiper-item");
const _sfc_main$1b = create$1b({
  props: {},
  setup(props, { slots }) {
    const parent = inject("parent");
    parent["relation"](getCurrentInstance());
    const state = reactive({
      offset: 0
    });
    const classes = computed(() => {
      const prefixCls = componentName$U;
      return {
        [prefixCls]: true
      };
    });
    const style = computed(() => {
      const style2 = {};
      const direction = parent == null ? void 0 : parent.props.direction;
      if (parent == null ? void 0 : parent.size.value) {
        style2[direction === "horizontal" ? "width" : "height"] = `${parent == null ? void 0 : parent.size.value}px`;
      }
      if (state.offset) {
        style2["transform"] = `translate${direction === "horizontal" ? "X" : "Y"}(${state.offset}px)`;
      }
      return style2;
    });
    const setOffset = (offset) => {
      state.offset = offset;
    };
    useExpose({ setOffset });
    return {
      style,
      classes
    };
  }
});
function _sfc_render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var SwiperItem = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$15]]);
const { componentName: componentName$T, create: create$1a } = createComponent("imagepreview");
const _sfc_main$1a = create$1a({
  props: {
    show: {
      type: Boolean,
      default: false
    },
    images: {
      type: Array,
      default: () => []
    },
    videos: {
      type: Array,
      default: () => []
    },
    contentClose: {
      type: Boolean,
      default: false
    },
    initNo: {
      type: Number,
      default: 1
    },
    paginationVisible: {
      type: Boolean,
      default: false
    },
    paginationColor: {
      type: String,
      default: "#fff"
    },
    autoplay: {
      type: [Number, String],
      default: 3e3
    }
  },
  emits: ["close"],
  components: {
    [Popup.name]: Popup,
    [Video.name]: Video,
    [Swiper.name]: Swiper,
    [SwiperItem.name]: SwiperItem
  },
  setup(props, { emit }) {
    toRefs(props);
    const state = reactive({
      showPop: false,
      active: 1,
      maxNo: 1,
      source: {
        src: "https://storage.jd.com/about/big-final.mp4?Expires=3730193075&AccessKey=3LoYX1dQWa6ZXzQl&Signature=ViMFjz%2BOkBxS%2FY1rjtUVqbopbJI%3D",
        type: "video/mp4"
      },
      options: {
        muted: true,
        controls: true
      },
      eleImg: null,
      store: {
        scale: 1,
        moveable: false
      },
      lastTouchEndTime: 0
    });
    const slideChangeEnd = function(page) {
      state.active = page + 1;
    };
    const closeOnImg = () => {
      if (props.contentClose) {
        onClose();
      }
    };
    const onClose = () => {
      state.showPop = false;
      state.store.scale = 1;
      scaleNow();
      state.active = 1;
      emit("close");
    };
    const getDistance = (first, second) => {
      return Math.hypot(Math.abs(second.x - first.x), Math.abs(second.y - first.y));
    };
    const scaleNow = () => {
      state.eleImg.style.transform = "scale(" + state.store.scale + ")";
    };
    const onTouchStart = (event) => {
      console.log("start");
      const curTouchTime = new Date().getTime();
      if (curTouchTime - state.lastTouchEndTime < 300) {
        const store2 = state.store;
        if (store2.scale > 1) {
          store2.scale = 1;
        } else if (store2.scale == 1) {
          store2.scale = 2;
        }
        scaleNow();
      }
      var touches = event.touches;
      var events = touches[0];
      var events2 = touches[1];
      const store = state.store;
      store.moveable = true;
      if (events2) {
        store.oriDistance = getDistance({
          x: events.pageX,
          y: events.pageY
        }, {
          x: events2.pageX,
          y: events2.pageY
        });
      }
      store.originScale = store.scale || 1;
    };
    const onTouchMove = (event) => {
      if (!state.store.moveable) {
        return;
      }
      const store = state.store;
      var touches = event.touches;
      var events = touches[0];
      var events2 = touches[1];
      if (events2) {
        const curDistance = getDistance({
          x: events.pageX,
          y: events.pageY
        }, {
          x: events2.pageX,
          y: events2.pageY
        });
        const curScale = curDistance / store.oriDistance;
        store.scale = store.originScale * curScale;
        if (store.scale > 3) {
          store.scale = 3;
        }
        scaleNow();
      }
    };
    const onTouchEnd = () => {
      console.log("end");
      state.lastTouchEndTime = new Date().getTime();
      const store = state.store;
      store.moveable = false;
      if (store.scale < 1.1 && store.scale > 1 || store.scale < 1) {
        store.scale = 1;
        scaleNow();
      }
    };
    const init = () => {
      state.eleImg = document.querySelector(".nut-imagepreview");
      document.addEventListener("touchmove", onTouchMove);
      document.addEventListener("touchend", onTouchEnd);
      document.addEventListener("touchcancel", onTouchEnd);
    };
    watch(() => props.show, (val) => {
      state.showPop = val;
      init();
    });
    onMounted(() => {
      state.active = props.initNo;
      state.showPop = props.show;
      state.maxNo = props.images.length + props.videos.length;
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      slideChangeEnd,
      onClose,
      closeOnImg,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      getDistance,
      scaleNow
    });
  }
});
const _hoisted_1$U = ["src"];
const _hoisted_2$K = { class: "nut-imagepreview-index" };
function _sfc_render$14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_video = resolveComponent("nut-video");
  const _component_nut_swiper_item = resolveComponent("nut-swiper-item");
  const _component_nut_swiper = resolveComponent("nut-swiper");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    "pop-class": "custom-pop",
    visible: _ctx.showPop,
    "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.showPop = $event),
    onClick: _ctx.onClose,
    style: { "width": "100%" }
  }, {
    default: withCtx(() => [
      createElementVNode("view", {
        class: "nut-imagepreview",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.closeOnImg && _ctx.closeOnImg(...args), ["stop"])),
        onTouchstartCapture: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args))
      }, [
        _ctx.showPop ? (openBlock(), createBlock(_component_nut_swiper, {
          key: 0,
          "auto-play": _ctx.autoplay,
          class: "nut-imagepreview-swiper",
          loop: true,
          "is-preventDefault": false,
          direction: "horizontal",
          onChange: _ctx.slideChangeEnd,
          "init-page": _ctx.initNo > _ctx.maxNo ? _ctx.maxNo - 1 : _ctx.initNo - 1,
          "pagination-visible": _ctx.paginationVisible,
          "pagination-color": _ctx.paginationColor
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.videos, (item, index) => {
              return openBlock(), createBlock(_component_nut_swiper_item, { key: index }, {
                default: withCtx(() => [
                  createVNode(_component_nut_video, {
                    source: item.source,
                    options: item.options
                  }, null, 8, ["source", "options"])
                ]),
                _: 2
              }, 1024);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.images, (item, index) => {
              return openBlock(), createBlock(_component_nut_swiper_item, { key: index }, {
                default: withCtx(() => [
                  createElementVNode("img", {
                    src: item.src,
                    class: "nut-imagepreview-img"
                  }, null, 8, _hoisted_1$U)
                ]),
                _: 2
              }, 1024);
            }), 128))
          ]),
          _: 1
        }, 8, ["auto-play", "onChange", "init-page", "pagination-visible", "pagination-color"])) : createCommentVNode("", true)
      ], 32),
      createElementVNode("view", _hoisted_2$K, toDisplayString(_ctx.active) + " / " + toDisplayString(_ctx.images.length + _ctx.videos.length), 1)
    ]),
    _: 1
  }, 8, ["visible", "onClick"]);
}
var ImagePreview = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$14]]);
class ImagePreviewOptions {
  constructor() {
    __publicField(this, "show", false);
    __publicField(this, "images", []);
    __publicField(this, "initNo", 1);
    __publicField(this, "paginationVisible", false);
    __publicField(this, "paginationColor", "");
    __publicField(this, "teleport", "body");
    __publicField(this, "onClose", () => {
    });
  }
}
class ImagePreviewFunction {
  constructor(_options) {
    __publicField(this, "options", new ImagePreviewOptions());
    let options = Object.assign(this.options, _options);
    let elWarp = document.body;
    let teleport = options.teleport;
    if (teleport != "body") {
      if (typeof teleport == "string") {
        elWarp = document.querySelector(teleport);
      } else {
        elWarp = options.teleport;
      }
    }
    const root = document.createElement("view");
    root.id = "imagepreview-" + new Date().getTime();
    const Wrapper = {
      setup() {
        options.teleport = `#${root.id}`;
        return () => {
          return h(ImagePreview, options);
        };
      }
    };
    const instance = createVNode(Wrapper);
    elWarp.appendChild(root);
    render(instance, root);
  }
}
const _ImagePreview = function(options) {
  return new ImagePreviewFunction(options);
};
_ImagePreview.install = (app) => {
  app.use(ImagePreview);
  app.config.globalProperties.$imagepreview = _ImagePreview;
};
const MIN_DISTANCE = 10;
function getDirection(x, y) {
  if (x > y && x > MIN_DISTANCE) {
    return "horizontal";
  }
  if (y > x && y > MIN_DISTANCE) {
    return "vertical";
  }
  return "";
}
function useTouch() {
  const startX = ref(0);
  const startY = ref(0);
  const deltaX = ref(0);
  const deltaY = ref(0);
  const offsetX = ref(0);
  const offsetY = ref(0);
  const direction = ref("");
  const isVertical = () => direction.value === "vertical";
  const isHorizontal = () => direction.value === "horizontal";
  const reset = () => {
    deltaX.value = 0;
    deltaY.value = 0;
    offsetX.value = 0;
    offsetY.value = 0;
    direction.value = "";
  };
  const start = (event) => {
    reset();
    startX.value = event.touches[0].clientX;
    startY.value = event.touches[0].clientY;
  };
  const move = (event) => {
    const touch = event.touches[0];
    deltaX.value = touch.clientX - startX.value;
    deltaY.value = touch.clientY - startY.value;
    offsetX.value = Math.abs(deltaX.value);
    offsetY.value = Math.abs(deltaY.value);
    if (!direction.value) {
      direction.value = getDirection(offsetX.value, offsetY.value);
    }
  };
  return {
    move,
    start,
    reset,
    startX,
    startY,
    deltaX,
    deltaY,
    offsetX,
    offsetY,
    direction,
    isVertical,
    isHorizontal
  };
}
const { componentName: componentName$S, create: create$19 } = createComponent("swipe");
const _sfc_main$19 = create$19({
  props: {
    name: {
      type: String,
      default: ""
    },
    touchMoveStopPropagation: {
      type: Boolean,
      default: false
    },
    touchMovePreventDefault: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["open", "close"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$S;
      return {
        [prefixCls]: true
      };
    });
    const getRefWidth = (ref2) => {
      var _a;
      return ((_a = ref2.value) == null ? void 0 : _a.clientWidth) || 0;
    };
    const leftRef = ref(), leftRefWidth = computed(() => {
      return getRefWidth(leftRef);
    });
    const rightRef = ref(), rightRefWidth = computed(() => {
      return getRefWidth(rightRef);
    });
    let opened = false;
    let position = "";
    let oldPosition = "";
    const state = reactive({
      offset: 0,
      moving: false
    });
    const open = (p = "") => {
      opened = true;
      if (p) {
        state.offset = p === "left" ? -rightRefWidth.value : leftRefWidth.value;
      }
      emit("open", {
        name: props.name,
        position: position || p
      });
    };
    const close = () => {
      state.offset = 0;
      opened = false;
      emit("close", {
        name: props.name,
        position
      });
    };
    const touchStyle = computed(() => {
      return {
        transform: `translate3d(${state.offset}px, 0, 0)`
      };
    });
    const setoffset = (deltaX) => {
      position = deltaX > 0 ? "right" : "left";
      let offset = deltaX;
      switch (position) {
        case "left":
          if (opened && oldPosition === position) {
            offset = -rightRefWidth.value;
          } else {
            offset = Math.abs(deltaX) > rightRefWidth.value ? -rightRefWidth.value : deltaX;
          }
          break;
        case "right":
          if (opened && oldPosition === position) {
            offset = leftRefWidth.value;
          } else {
            offset = Math.abs(deltaX) > leftRefWidth.value ? leftRefWidth.value : deltaX;
          }
          break;
      }
      state.offset = offset;
    };
    const touch = useTouch();
    const touchMethods = {
      onTouchStart(event) {
        if (props.disabled)
          return;
        touch.start(event);
      },
      onTouchMove(event) {
        if (props.disabled)
          return;
        touch.move(event);
        if (touch.isHorizontal()) {
          state.moving = true;
          setoffset(touch.deltaX.value);
          if (props.touchMovePreventDefault) {
            event.preventDefault();
          }
          if (props.touchMoveStopPropagation) {
            event.stopPropagation();
          }
        }
      },
      onTouchEnd() {
        if (state.moving) {
          state.moving = false;
          oldPosition = position;
          switch (position) {
            case "left":
              if (Math.abs(state.offset) <= rightRefWidth.value / 2) {
                close();
              } else {
                state.offset = -rightRefWidth.value;
                open();
              }
              break;
            case "right":
              if (Math.abs(state.offset) <= leftRefWidth.value / 2) {
                close();
              } else {
                state.offset = leftRefWidth.value;
                open();
              }
              break;
          }
        }
      }
    };
    return __spreadProps(__spreadValues({
      classes,
      touchStyle
    }, touchMethods), {
      leftRef,
      rightRef,
      open,
      close
    });
  }
});
const _hoisted_1$T = {
  class: "nut-swipe__left",
  ref: "leftRef"
};
const _hoisted_2$J = { class: "nut-swipe__content" };
const _hoisted_3$z = {
  class: "nut-swipe__right",
  ref: "rightRef"
};
function _sfc_render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.touchStyle),
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
    onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
  }, [
    createElementVNode("view", _hoisted_1$T, [
      renderSlot(_ctx.$slots, "left")
    ], 512),
    createElementVNode("view", _hoisted_2$J, [
      renderSlot(_ctx.$slots, "default")
    ]),
    createElementVNode("view", _hoisted_3$z, [
      renderSlot(_ctx.$slots, "right")
    ], 512)
  ], 38);
}
var Swipe = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$13]]);
const { componentName: componentName$R, create: create$18 } = createComponent("actionsheet");
const _sfc_main$18 = create$18({
  props: __spreadProps(__spreadValues({}, popupProps), {
    cancelTxt: {
      type: String,
      default: ""
    },
    optionTag: {
      type: String,
      default: "name"
    },
    optionSubTag: {
      type: String,
      default: "subname"
    },
    chooseTagValue: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "#ee0a24"
    },
    description: {
      type: String,
      default: ""
    },
    menuItems: {
      type: Array,
      default: () => []
    }
  }),
  emits: ["cancel", "choose", "update:visible"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$R;
      return {
        [prefixCls]: true
      };
    });
    const isHighlight = (item) => {
      return props.chooseTagValue && props.chooseTagValue === item[props.optionTag] ? props.color : "#1a1a1a";
    };
    const cancelActionSheet = () => {
      emit("cancel");
      emit("update:visible", false);
    };
    const chooseItem = (item, index) => {
      if (!item.disable) {
        emit("choose", item, index);
        emit("update:visible", false);
      }
    };
    const close = () => {
      emit("close");
      emit("update:visible", false);
    };
    return {
      isHighlight,
      cancelActionSheet,
      chooseItem,
      close,
      classes
    };
  }
});
const _hoisted_1$S = { class: "nut-actionsheet-panel" };
const _hoisted_2$I = {
  key: 0,
  class: "nut-actionsheet-title"
};
const _hoisted_3$y = {
  key: 1,
  class: "nut-actionsheet-item desc"
};
const _hoisted_4$q = {
  key: 2,
  class: "nut-actionsheet-menu"
};
const _hoisted_5$i = ["onClick"];
const _hoisted_6$f = { class: "subdesc" };
function _sfc_render$12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createVNode(_component_nut_popup, {
      "pop-class": "popclass",
      visible: _ctx.visible,
      position: "bottom",
      round: "",
      onClickOverlay: _ctx.close
    }, {
      default: withCtx(() => [
        createElementVNode("view", _hoisted_1$S, [
          _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_2$I, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
          _ctx.description ? (openBlock(), createElementBlock("view", _hoisted_3$y, toDisplayString(_ctx.description), 1)) : createCommentVNode("", true),
          _ctx.menuItems.length ? (openBlock(), createElementBlock("view", _hoisted_4$q, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menuItems, (item, index) => {
              return openBlock(), createElementBlock("view", {
                class: normalizeClass(["nut-actionsheet-item", { "nut-actionsheet-item-disabled": item.disable }]),
                style: normalizeStyle({ color: _ctx.isHighlight(item) }),
                key: index,
                onClick: ($event) => _ctx.chooseItem(item, index)
              }, [
                createTextVNode(toDisplayString(item[_ctx.optionTag]), 1),
                createElementVNode("view", _hoisted_6$f, toDisplayString(item[_ctx.optionSubTag]), 1)
              ], 14, _hoisted_5$i);
            }), 128))
          ])) : createCommentVNode("", true),
          _ctx.cancelTxt ? (openBlock(), createElementBlock("view", {
            key: 3,
            class: "nut-actionsheet-cancel",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.cancelActionSheet && _ctx.cancelActionSheet(...args))
          }, toDisplayString(_ctx.cancelTxt), 1)) : createCommentVNode("", true)
        ])
      ]),
      _: 1
    }, 8, ["visible", "onClickOverlay"])
  ], 2);
}
var ActionSheet = /* @__PURE__ */ _export_sfc(_sfc_main$18, [["render", _sfc_render$12]]);
const { componentName: componentName$Q, create: create$17 } = createComponent("backtop");
const _sfc_main$17 = create$17({
  props: {
    bottom: {
      type: Number,
      default: 20
    },
    right: {
      type: Number,
      default: 10
    },
    elId: {
      type: String,
      default: ""
    },
    distance: {
      type: Number,
      default: 200
    },
    zIndex: {
      type: Number,
      default: 10
    },
    isAnimation: {
      type: Boolean,
      default: true
    },
    duration: {
      type: Number,
      default: 1e3
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const state = reactive({
      backTop: false,
      scrollTop: 0,
      scrollEl: window,
      startTime: 0,
      keepAlive: false
    });
    const classes = computed(() => {
      const prefixCls = componentName$Q;
      return {
        [prefixCls]: true,
        show: state.backTop
      };
    });
    const style = computed(() => {
      return {
        right: `${props.right}px`,
        bottom: `${props.bottom}px`,
        zIndex: props.zIndex
      };
    });
    function scrollListener() {
      if (state.scrollEl instanceof Window) {
        state.scrollTop = state.scrollEl.pageYOffset;
      } else {
        state.scrollTop = state.scrollEl.scrollTop;
      }
      state.backTop = state.scrollTop >= props.distance;
    }
    function scroll(y = 0) {
      if (state.scrollEl instanceof Window) {
        window.scrollTo(0, y);
      } else {
        state.scrollEl.scrollTop = y;
      }
    }
    function scrollAnimation() {
      let cid = requestAniFrame2()(function fn() {
        var t = props.duration - Math.max(0, state.startTime - +new Date() + props.duration);
        var y = t * -state.scrollTop / props.duration + state.scrollTop;
        scroll(y);
        cid = requestAniFrame2()(fn);
        if (t == props.duration || y == 0) {
          window.cancelAnimationFrame(cid);
        }
      });
    }
    function addEventListener() {
      state.scrollEl.addEventListener("scroll", scrollListener, false);
      state.scrollEl.addEventListener("resize", scrollListener, false);
    }
    function removeEventListener() {
      state.scrollEl.removeEventListener("scroll", scrollListener, false);
      state.scrollEl.removeEventListener("resize", scrollListener, false);
    }
    function initCancelAniFrame() {
      window.cancelAnimationFrame = window.webkitCancelAnimationFrame;
    }
    function requestAniFrame2() {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(callback) {
        window.setTimeout(callback, 1e3 / 60);
      };
    }
    function click(e) {
      state.startTime = +new Date();
      props.isAnimation && props.duration > 0 ? scrollAnimation() : scroll();
      emit("click", e);
    }
    function init() {
      if (props.elId && document.getElementById(props.elId)) {
        state.scrollEl = document.getElementById(props.elId);
      }
      addEventListener();
      initCancelAniFrame();
    }
    onMounted(() => {
      init();
    });
    onUnmounted(() => {
      removeEventListener();
    });
    onActivated(() => {
      if (state.keepAlive) {
        state.keepAlive = false;
        init();
      }
    });
    onDeactivated(() => {
      state.keepAlive = true;
      removeEventListener();
    });
    return {
      state,
      classes,
      style,
      click
    };
  }
});
function _sfc_render$11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.style),
    onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.click && _ctx.click(...args), ["stop"]))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_nut_icon, {
        size: "19px",
        class: "nut-backtop-main",
        name: "top"
      })
    ])
  ], 6);
}
var BackTop = /* @__PURE__ */ _export_sfc(_sfc_main$17, [["render", _sfc_render$11]]);
const { create: create$16 } = createComponent("collapse");
const _sfc_main$16 = create$16({
  props: {
    active: {
      type: [String, Number, Array]
    },
    accordion: {
      type: Boolean
    },
    titleIcon: {
      type: String,
      default: ""
    },
    titleIconSize: {
      type: String,
      default: "16px"
    },
    titleIconColor: {
      type: String,
      default: ""
    },
    titleIconPosition: {
      type: String,
      default: "left"
    },
    icon: {
      type: String,
      default: ""
    },
    iconSize: {
      type: String,
      default: "16px"
    },
    iconColor: {
      type: String,
      default: ""
    },
    rotate: {
      type: [String, Number],
      default: 180
    }
  },
  emits: ["update:active", "change"],
  setup(props, { emit }) {
    const changeVal = (val) => {
      emit("update:active", val);
      emit("change", val);
    };
    const changeValAry = (name) => {
      const activeItem = props.active instanceof Object ? Object.values(props.active) : props.active;
      let index = -1;
      activeItem.forEach((item, idx) => {
        if (String(item) == String(name)) {
          index = idx;
        }
      });
      index > -1 ? activeItem.splice(index, 1) : activeItem.push(name);
      changeVal(activeItem);
    };
    const isExpanded = (name) => {
      const { accordion, active } = props;
      if (accordion) {
        return typeof active === "number" || typeof active === "string" ? active == name : false;
      }
    };
    provide("collapseParent", {
      children: [],
      props,
      changeValAry,
      changeVal,
      isExpanded
    });
  }
});
function _sfc_render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", null, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main$16, [["render", _sfc_render$10]]);
const { create: create$15, componentName: componentName$P } = createComponent("collapse-item");
const _sfc_main$15 = create$15({
  props: {
    title: {
      type: String,
      default: ""
    },
    subTitle: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    name: {
      type: [Number, String],
      default: -1,
      required: true
    },
    collapseRef: {
      type: Object
    }
  },
  setup(props, ctx) {
    const collapse = inject("collapseParent");
    const parent = reactive(collapse);
    const classes = computed(() => {
      const prefixCls = componentName$P;
      return {
        [prefixCls]: true,
        [`${prefixCls}-icon`]: parent.props.icon
      };
    });
    const relation = (child) => {
      if (child.proxy) {
        parent.children.push(child.proxy);
      }
    };
    relation(getCurrentInstance());
    const proxyData = reactive({
      icon: parent.props.icon,
      iconSize: parent.props.iconSize,
      iconColor: parent.props.iconColor,
      openExpanded: false,
      iconStyle: {
        transform: "rotate(0deg)",
        marginTop: parent.props.iconHeght ? "-" + parent.props.iconHeght / 2 + "px" : "-10px"
      }
    });
    const titleIconStyle = reactive({
      titleIcon: parent.props.titleIcon,
      titleIconSize: parent.props.titleIconSize,
      titleIconColor: parent.props.titleIconColor,
      titleIconPosition: parent.props.titleIconPosition
    });
    const wrapperRef = ref(null);
    const contentRef = ref(null);
    const onTransitionEnd = () => {
      const wrapperRefEle = document.getElementsByClassName("collapse-wrapper")[0];
      wrapperRefEle.style.willChange = "auto";
    };
    const animation = () => {
      const wrapperRefEle = wrapperRef.value;
      const contentRefEle = contentRef.value;
      if (!wrapperRefEle || !contentRefEle) {
        return;
      }
      const offsetHeight = contentRefEle.offsetHeight || "auto";
      if (offsetHeight) {
        const contentHeight = `${offsetHeight}px`;
        wrapperRefEle.style.willChange = "height";
        wrapperRefEle.style.height = !proxyData.openExpanded ? 0 : contentHeight;
        if (parent.props.icon && !proxyData.openExpanded) {
          proxyData.iconStyle["transform"] = "rotate(0deg)";
        } else {
          proxyData.iconStyle["transform"] = "rotate(" + parent.props.rotate + "deg)";
        }
      }
      if (!proxyData.openExpanded) {
        onTransitionEnd();
      }
    };
    const open = () => {
      proxyData.openExpanded = !proxyData.openExpanded;
      animation();
    };
    const defaultOpen = () => {
      open();
      if (parent.props.icon) {
        proxyData["iconStyle"]["transform"] = "rotate(" + parent.props.rotate + "deg)";
      }
    };
    const currentName = computed(() => props.name);
    const toggleOpen = () => {
      if (parent.props.accordion) {
        parent.children.forEach((item, index) => {
          if (currentName.value == item.name) {
            item.changeOpen(!item.openExpanded);
          } else {
            item.changeOpen(false);
            item.animation();
          }
        });
        nextTick(() => {
          parent.changeVal(currentName.value);
          animation();
        });
      } else {
        parent.changeValAry(props.name);
        open();
      }
    };
    const changeOpen = (bol) => {
      proxyData.openExpanded = bol;
    };
    const expanded = computed(() => {
      if (parent) {
        return parent.isExpanded(props.name);
      }
      return null;
    });
    watch(expanded, (value, oldValue) => {
      if (value) {
        proxyData.openExpanded = true;
      }
    });
    watch(() => {
      var _a, _b;
      return (_b = (_a = ctx == null ? void 0 : ctx.slots) == null ? void 0 : _a.default) == null ? void 0 : _b.call(_a);
    }, () => {
      setTimeout(() => {
        animation();
      }, 300);
    });
    onMounted(() => {
      const { name } = props;
      const active = parent && parent.props.active;
      if (typeof active == "number" || typeof active == "string") {
        if (name == active) {
          defaultOpen();
        }
      } else if (Object.values(active) instanceof Array) {
        const f = Object.values(active).filter((item) => item == name);
        if (f.length > 0) {
          defaultOpen();
        }
      }
    });
    return __spreadProps(__spreadValues(__spreadValues(__spreadValues({
      classes
    }, toRefs(proxyData)), toRefs(parent.props)), toRefs(titleIconStyle)), {
      wrapperRef,
      contentRef,
      open,
      toggleOpen,
      changeOpen,
      animation
    });
  }
});
const _hoisted_1$R = { class: "collapse-title" };
const _hoisted_2$H = { class: "collapse-title-value" };
const _hoisted_3$x = ["innerHTML"];
const _hoisted_4$p = {
  key: 0,
  class: "subTitle"
};
const _hoisted_5$h = ["innerHTML"];
const _hoisted_6$e = {
  class: "collapse-wrapper",
  ref: "wrapperRef"
};
const _hoisted_7$a = {
  class: "collapse-content",
  ref: "contentRef"
};
function _sfc_render$$(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", {
      class: normalizeClass(["collapse-item", { "item-expanded": _ctx.openExpanded }, { "nut-collapse-item-disabled": _ctx.disabled }]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.toggleOpen && _ctx.toggleOpen(...args))
    }, [
      createElementVNode("view", _hoisted_1$R, [
        createElementVNode("view", null, [
          createElementVNode("view", _hoisted_2$H, [
            _ctx.titleIcon ? (openBlock(), createBlock(_component_nut_icon, {
              key: 0,
              name: _ctx.titleIcon,
              size: _ctx.titleIconSize,
              color: _ctx.titleIconColor,
              class: normalizeClass([_ctx.titleIconPosition == "left" ? "titleIconLeft" : "titleIconRight"])
            }, null, 8, ["name", "size", "color", "class"])) : createCommentVNode("", true),
            _ctx.$slots.mTitle ? renderSlot(_ctx.$slots, "mTitle", { key: 1 }) : (openBlock(), createElementBlock("view", {
              key: 2,
              innerHTML: _ctx.title,
              class: "collapse-icon-title"
            }, null, 8, _hoisted_3$x))
          ])
        ])
      ]),
      _ctx.$slots.sTitle ? (openBlock(), createElementBlock("view", _hoisted_4$p, [
        renderSlot(_ctx.$slots, "sTitle")
      ])) : (openBlock(), createElementBlock("view", {
        key: 1,
        innerHTML: _ctx.subTitle,
        class: "subTitle"
      }, null, 8, _hoisted_5$h)),
      _ctx.icon ? (openBlock(), createBlock(_component_nut_icon, {
        key: 2,
        name: _ctx.icon,
        size: _ctx.iconSize,
        color: _ctx.iconColor,
        class: normalizeClass(["collapse-icon", { "col-expanded": _ctx.openExpanded }, { "collapse-icon-disabled": _ctx.disabled }]),
        style: normalizeStyle(_ctx.iconStyle)
      }, null, 8, ["name", "size", "color", "class", "style"])) : createCommentVNode("", true)
    ], 2),
    createElementVNode("view", _hoisted_6$e, [
      createElementVNode("view", _hoisted_7$a, [
        renderSlot(_ctx.$slots, "default")
      ], 512)
    ], 512)
  ], 2);
}
var CollapseItem = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$$]]);
const _window = window;
function requestAniFrame() {
  if (typeof _window !== "undefined") {
    return _window.requestAnimationFrame || _window.webkitRequestAnimationFrame || function(callback) {
      _window.setTimeout(callback, 1e3 / 60);
    };
  } else {
    return function(callback) {
      setTimeout(callback, 1e3 / 60);
    };
  }
}
var requestAniFrame$1 = requestAniFrame();
const { componentName: componentName$O, create: create$14 } = createComponent("drag");
const _sfc_main$14 = create$14({
  props: {
    attract: {
      type: Boolean,
      default: false
    },
    direction: {
      type: String,
      default: "all"
    },
    boundary: {
      type: Object,
      default: () => {
        return {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
      }
    }
  },
  setup(props, { emit }) {
    const myDrag = ref();
    const state = reactive({
      keepAlive: false,
      elWidth: 0,
      elHeight: 0,
      screenWidth: 0,
      screenHeight: 0,
      startTop: 0,
      startLeft: 0,
      nx: 0,
      ny: 0,
      xPum: 0,
      yPum: 0,
      position: { x: 0, y: 0 },
      boundary: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    });
    const classes = computed(() => {
      const prefixCls = componentName$O;
      return {
        [prefixCls]: true
      };
    });
    function getInfo() {
      const domElem = document.documentElement;
      state.elWidth = myDrag.value.offsetWidth;
      state.elHeight = myDrag.value.offsetHeight;
      state.screenWidth = domElem.clientWidth;
      state.screenHeight = domElem.clientHeight;
    }
    function goLeft(target) {
      if (state.boundary.left) {
        if (+target.style.left.split("px")[0] > state.boundary.left) {
          target.style.left = +target.style.left.split("px")[0] - 10 + "px";
          requestAniFrame$1(() => {
            goLeft(target);
          });
        } else {
          target.style.left = `${state.boundary.left}px`;
        }
      } else {
        if (+target.style.left.split("px")[0] > 10) {
          target.style.left = +target.style.left.split("px")[0] - 10 + "px";
          requestAniFrame$1(() => {
            goLeft(target);
          });
        } else {
          target.style.left = "0px";
        }
      }
    }
    function goRight(target, rightLocation) {
      if (rightLocation - parseInt(target.style.left.split("px")[0]) > 10) {
        target.style.left = parseInt(target.style.left.split("px")[0]) + 10 + "px";
        requestAniFrame$1(() => {
          goRight(target, rightLocation);
        });
      } else {
        target.style.left = rightLocation + "px";
      }
    }
    function touchMove(e) {
      e.preventDefault();
      const target = e.currentTarget;
      if (e.targetTouches.length === 1) {
        const touch = e.targetTouches[0];
        state.nx = touch.clientX - state.position.x;
        state.ny = touch.clientY - state.position.y;
        state.xPum = state.startLeft + state.nx;
        state.yPum = state.startTop + state.ny;
        const rightLocation = state.screenWidth - state.elWidth - state.boundary.right;
        if (Math.abs(state.xPum) > rightLocation) {
          state.xPum = rightLocation;
        } else if (state.xPum <= state.boundary.left) {
          state.xPum = state.boundary.left;
        }
        if (state.yPum < state.boundary.top) {
          state.yPum = state.boundary.top;
        } else if (state.yPum > state.screenHeight - state.elHeight - state.boundary.bottom) {
          state.yPum = state.screenHeight - state.elHeight - state.boundary.bottom;
        }
        if (props.direction != "y") {
          target.style.left = state.xPum + "px";
        }
        if (props.direction != "x") {
          target.style.top = state.yPum + "px";
        }
      }
    }
    function touchEnd(e) {
      const target = e.currentTarget;
      const touch = e.changedTouches[0];
      let currX = touch.clientX;
      const rightLocation = state.screenWidth - state.elWidth - state.boundary.right;
      if (currX > rightLocation) {
        currX = rightLocation;
      } else if (currX < state.boundary.left) {
        currX = state.boundary.left;
      } else {
        currX = currX < state.screenWidth / 2 ? state.boundary.left : rightLocation;
      }
      if (props.direction != "y" && props.attract) {
        if (currX < state.screenWidth / 2) {
          requestAniFrame$1(() => {
            goLeft(target);
          });
        } else {
          requestAniFrame$1(() => {
            goRight(target, rightLocation);
          });
        }
      }
      if (props.direction != "x") {
        target.style.top = state.yPum + "px";
      }
    }
    function touchStart(e) {
      const target = e.currentTarget;
      const touches = e.touches[0];
      const touch = e.targetTouches[0];
      state.startTop = target.offsetTop;
      state.startLeft = target.offsetLeft;
      state.position.x = touches.clientX;
      state.position.y = touches.clientY;
      state.nx = touch.clientX - state.position.x;
      state.ny = touch.clientY - state.position.y;
      state.xPum = state.startLeft + state.nx;
      state.yPum = state.startTop + state.ny;
    }
    onMounted(() => {
      getInfo();
      state.boundary = props.boundary;
    });
    onActivated(() => {
      if (state.keepAlive) {
        state.keepAlive = false;
      }
    });
    onDeactivated(() => {
      state.keepAlive = true;
      myDrag.removeEventListener("touchstart", touchStart);
      myDrag.removeEventListener("touchmove", touchMove);
      myDrag.removeEventListener("touchend", touchEnd);
    });
    return {
      classes,
      myDrag,
      touchStart,
      touchMove,
      touchEnd
    };
  }
});
function _sfc_render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    ref: "myDrag",
    onTouchstart: _cache[0] || (_cache[0] = ($event) => _ctx.touchStart($event)),
    onTouchmove: _cache[1] || (_cache[1] = ($event) => _ctx.touchMove($event)),
    onTouchend: _cache[2] || (_cache[2] = ($event) => _ctx.touchEnd($event))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34);
}
var Drag = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$_]]);
const { componentName: componentName$N, create: create$13 } = createComponent("dialog");
const _sfc_main$13 = create$13({
  inheritAttrs: false,
  components: {
    [Popup.name]: Popup,
    [Button.name]: Button
  },
  props: __spreadProps(__spreadValues({}, popupProps), {
    closeOnClickOverlay: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    content: {
      type: String,
      default: ""
    },
    noFooter: {
      type: Boolean,
      default: false
    },
    noOkBtn: {
      type: Boolean,
      default: false
    },
    noCancelBtn: {
      type: Boolean,
      default: false
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    okText: {
      type: String,
      default: "\u786E\u5B9A"
    },
    okBtnDisabled: {
      type: Boolean,
      default: false
    },
    cancelAutoClose: {
      type: Boolean,
      default: true
    },
    textAlign: {
      type: String,
      default: "center"
    },
    closeOnPopstate: {
      type: Boolean,
      default: false
    },
    footerDirection: {
      type: String,
      default: "horizontal"
    }
  }),
  emits: ["update", "update:visible", "ok", "cancel", "open", "opened", "close", "closed"],
  setup(props, { emit }) {
    const showPopup = ref(props.visible);
    onMounted(() => {
      if (props.closeOnPopstate) {
        window.addEventListener("popstate", function() {
          closed();
        });
      }
    });
    watch(() => props.visible, (value) => {
      showPopup.value = value;
    });
    const classes = computed(() => {
      return {
        [componentName$N]: true
      };
    });
    const update = (val) => {
      emit("update", val);
      emit("update:visible", val);
    };
    const closed = () => {
      update(false);
      emit("closed");
    };
    const onCancel = () => {
      emit("cancel");
      if (props.cancelAutoClose) {
        closed();
      }
    };
    const onOk = () => {
      emit("ok");
      closed();
    };
    return {
      closed,
      classes,
      onCancel,
      onOk,
      showPopup
    };
  }
});
const _hoisted_1$Q = {
  key: 0,
  class: "nut-dialog__header"
};
const _hoisted_2$G = ["innerHTML"];
function _sfc_render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    teleport: _ctx.teleport,
    visible: _ctx.showPopup,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.showPopup = $event),
    "close-on-click-overlay": _ctx.closeOnClickOverlay,
    "lock-scroll": _ctx.lockScroll,
    round: "",
    onClickOverlay: _ctx.closed,
    onClickCloseIcon: _ctx.closed
  }, {
    default: withCtx(() => [
      createElementVNode("view", {
        class: normalizeClass(_ctx.classes)
      }, [
        _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_1$Q, [
          _ctx.$slots.header ? renderSlot(_ctx.$slots, "header", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(_ctx.title), 1)
          ], 64))
        ])) : createCommentVNode("", true),
        createElementVNode("view", {
          class: "nut-dialog__content",
          style: normalizeStyle({ textAlign: _ctx.textAlign })
        }, [
          _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock("view", {
            key: 1,
            innerHTML: _ctx.content
          }, null, 8, _hoisted_2$G))
        ], 4),
        !_ctx.noFooter ? (openBlock(), createElementBlock("view", {
          key: 1,
          class: normalizeClass(["nut-dialog__footer", { [_ctx.footerDirection]: _ctx.footerDirection }])
        }, [
          _ctx.$slots.footer ? renderSlot(_ctx.$slots, "footer", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !_ctx.noCancelBtn ? (openBlock(), createBlock(_component_nut_button, {
              key: 0,
              size: "small",
              plain: "",
              type: "primary",
              class: "nut-dialog__footer-cancel",
              onClick: _ctx.onCancel
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.cancelText), 1)
              ]),
              _: 1
            }, 8, ["onClick"])) : createCommentVNode("", true),
            !_ctx.noOkBtn ? (openBlock(), createBlock(_component_nut_button, {
              key: 1,
              size: "small",
              type: "primary",
              class: normalizeClass(["nut-dialog__footer-ok", { disabled: _ctx.okBtnDisabled }]),
              disabled: _ctx.okBtnDisabled,
              onClick: _ctx.onOk
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.okText), 1)
              ]),
              _: 1
            }, 8, ["class", "disabled", "onClick"])) : createCommentVNode("", true)
          ], 64))
        ], 2)) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["teleport", "visible", "close-on-click-overlay", "lock-scroll", "onClickOverlay", "onClickCloseIcon"]);
}
var Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$13, [["render", _sfc_render$Z]]);
class DialogOptions {
  constructor() {
    __publicField(this, "title", "");
    __publicField(this, "content", "");
    __publicField(this, "cancelText", "\u53D6\u6D88");
    __publicField(this, "okText", "\u786E\u5B9A");
    __publicField(this, "textAlign", "center");
    __publicField(this, "teleport", "body");
    __publicField(this, "onUpdate", (value) => {
    });
    __publicField(this, "onOk", () => {
    });
    __publicField(this, "onCancel", () => {
    });
    __publicField(this, "onClose", () => {
    });
    __publicField(this, "onClosed", () => {
    });
    __publicField(this, "visible", true);
    __publicField(this, "noFooter", false);
    __publicField(this, "noOkBtn", false);
    __publicField(this, "noCancelBtn", false);
    __publicField(this, "okBtnDisabled", false);
    __publicField(this, "closeOnPopstate", false);
    __publicField(this, "lockScroll", false);
  }
}
class DialogFunction {
  constructor(_options) {
    __publicField(this, "options", new DialogOptions());
    __publicField(this, "close", () => {
    });
    __publicField(this, "setDefaultOptions", (options) => {
    });
    __publicField(this, "resetDefaultOptions", () => {
    });
    let options = Object.assign(this.options, _options);
    let elWarp = document.body;
    let teleport = options.teleport;
    if (teleport != "body") {
      if (typeof teleport == "string") {
        elWarp = document.querySelector(teleport);
      } else {
        elWarp = options.teleport;
      }
    }
    const root = document.createElement("view");
    root.id = "dialog-" + new Date().getTime();
    const Wrapper = {
      setup() {
        options.onUpdate = (val) => {
          if (val == false) {
            elWarp.removeChild(root);
          }
        };
        options.teleport = `#${root.id}`;
        return () => {
          return h(Dialog, options);
        };
      }
    };
    const instance = createVNode(Wrapper);
    elWarp.appendChild(root);
    render(instance, root);
  }
}
const _Dialog = function(options) {
  return new DialogFunction(options);
};
_Dialog.install = (app) => {
  app.use(Dialog);
  app.config.globalProperties.$dialog = _Dialog;
};
const { componentName: componentName$M, create: create$12 } = createComponent("infiniteloading");
const _sfc_main$12 = create$12({
  props: {
    hasMore: {
      type: Boolean,
      default: true
    },
    threshold: {
      type: Number,
      default: 200
    },
    pullIcon: {
      type: String,
      default: "https://img10.360buyimg.com/imagetools/jfs/t1/169863/6/4565/6306/60125948E7e92774e/40b3a0cf42852bcb.png"
    },
    pullTxt: {
      type: String,
      default: "\u677E\u5F00\u5237\u65B0"
    },
    loadIcon: {
      type: String,
      default: "https://img10.360buyimg.com/imagetools/jfs/t1/169863/6/4565/6306/60125948E7e92774e/40b3a0cf42852bcb.png"
    },
    loadTxt: {
      type: String,
      default: "\u52A0\u8F7D\u4E2D\xB7\xB7\xB7"
    },
    loadMoreTxt: {
      type: String,
      default: "\u54CE\u5440\uFF0C\u8FD9\u91CC\u662F\u5E95\u90E8\u4E86\u5566"
    },
    useWindow: {
      type: Boolean,
      default: true
    },
    containerId: {
      type: String,
      default: ""
    },
    useCapture: {
      type: Boolean,
      default: false
    },
    isOpenRefresh: {
      type: Boolean,
      default: false
    }
  },
  emits: ["scroll-change", "load-more", "refresh"],
  setup(props, { emit, slots }) {
    const state = reactive({
      scrollEl: window,
      scroller: null,
      refreshTop: null,
      beforeScrollTop: 0,
      isTouching: false,
      isInfiniting: false,
      refreshMaxH: 0,
      y: 0,
      x: 0,
      distance: 0
    });
    const classes = computed(() => {
      const prefixCls = componentName$M;
      return {
        [prefixCls]: true
      };
    });
    const getStyle = computed(() => {
      return {
        height: state.distance < 0 ? `0px` : `${state.distance}px`,
        transition: state.isTouching ? `height 0s cubic-bezier(0.25,0.1,0.25,1)` : `height 0.2s cubic-bezier(0.25,0.1,0.25,1)`
      };
    });
    const getParentElement = (el) => {
      return !!props.containerId ? document.querySelector(`#${props.containerId}`) : el && el.parentNode;
    };
    const requestAniFrame2 = () => {
      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || function(callback) {
        window.setTimeout(callback, 1e3 / 60);
      };
    };
    const getWindowScrollTop = () => {
      return window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
    };
    const calculateTopPosition = (el) => {
      return !el ? 0 : el.offsetTop + calculateTopPosition(el.offsetParent);
    };
    const isScrollAtBottom = () => {
      let offsetDistance = 0;
      let resScrollTop = 0;
      let direction = "down";
      const windowScrollTop = getWindowScrollTop();
      if (props.useWindow) {
        if (state.scroller) {
          offsetDistance = calculateTopPosition(state.scroller) + state.scroller.offsetHeight - windowScrollTop - window.innerHeight;
        }
        resScrollTop = windowScrollTop;
      } else {
        const { scrollHeight, clientHeight, scrollTop } = state.scrollEl;
        offsetDistance = scrollHeight - clientHeight - scrollTop;
        resScrollTop = scrollTop;
      }
      if (state.beforeScrollTop > resScrollTop) {
        direction = "up";
      } else {
        direction = "down";
      }
      state.beforeScrollTop = resScrollTop;
      emit("scroll-change", resScrollTop);
      return offsetDistance <= props.threshold && direction == "down";
    };
    const infiniteDone = () => {
      state.isInfiniting = false;
    };
    const handleScroll = () => {
      requestAniFrame2()(() => {
        if (!isScrollAtBottom() || !props.hasMore || state.isInfiniting) {
          return false;
        } else {
          state.isInfiniting = true;
          emit("load-more", infiniteDone);
        }
      });
    };
    const scrollListener = () => {
      state.scrollEl.addEventListener("scroll", handleScroll, props.useCapture);
    };
    const refreshDone = () => {
      state.distance = 0;
      state.isTouching = false;
    };
    const touchStart = (event) => {
      if (state.beforeScrollTop == 0 && !state.isTouching && props.isOpenRefresh) {
        state.y = event.touches[0].pageY;
        state.isTouching = true;
        const childHeight = state.refreshTop.firstElementChild.offsetHeight;
        state.refreshMaxH = Math.floor(childHeight * 1 + 10);
      }
    };
    const touchMove = (event) => {
      state.distance = event.touches[0].pageY - state.y;
      if (state.distance > 0 && state.isTouching) {
        event.preventDefault();
        if (state.distance >= state.refreshMaxH)
          state.distance = state.refreshMaxH;
      } else {
        state.distance = 0;
        state.isTouching = false;
      }
    };
    const touchEnd = () => {
      if (state.distance < state.refreshMaxH) {
        state.distance = 0;
      } else {
        emit("refresh", refreshDone);
      }
    };
    onMounted(() => {
      const parentElement = getParentElement(state.scroller);
      state.scrollEl = props.useWindow ? window : parentElement;
      scrollListener();
    });
    onUnmounted(() => {
      state.scrollEl.removeEventListener("scroll", handleScroll, props.useCapture);
    });
    const isKeepAlive = ref(false);
    onActivated(() => {
      if (isKeepAlive.value) {
        isKeepAlive.value = false;
        scrollListener();
      }
    });
    onDeactivated(() => {
      isKeepAlive.value = true;
      state.scrollEl.removeEventListener("scroll", handleScroll, props.useCapture);
    });
    return __spreadProps(__spreadValues({
      classes
    }, toRefs(state)), {
      touchStart,
      touchMove,
      touchEnd,
      getStyle
    });
  }
});
const _hoisted_1$P = { class: "top-box" };
const _hoisted_2$F = { class: "top-text" };
const _hoisted_3$w = { class: "nut-infinite-container" };
const _hoisted_4$o = { class: "nut-infinite-bottom" };
const _hoisted_5$g = {
  key: 0,
  class: "bottom-box"
};
const _hoisted_6$d = { class: "bottom-text" };
const _hoisted_7$9 = {
  key: 1,
  class: "tips"
};
function _sfc_render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    ref: "scroller",
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.touchStart && _ctx.touchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.touchMove && _ctx.touchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.touchEnd && _ctx.touchEnd(...args))
  }, [
    createElementVNode("view", {
      class: "nut-infinite-top",
      ref: "refreshTop",
      style: normalizeStyle(_ctx.getStyle)
    }, [
      createElementVNode("view", _hoisted_1$P, [
        createVNode(_component_nut_icon, {
          class: "top-img",
          name: _ctx.pullIcon
        }, null, 8, ["name"]),
        createElementVNode("view", _hoisted_2$F, toDisplayString(_ctx.pullTxt), 1)
      ])
    ], 4),
    createElementVNode("view", _hoisted_3$w, [
      renderSlot(_ctx.$slots, "default")
    ]),
    createElementVNode("view", _hoisted_4$o, [
      _ctx.isInfiniting ? (openBlock(), createElementBlock("view", _hoisted_5$g, [
        createVNode(_component_nut_icon, {
          class: "bottom-img",
          name: _ctx.loadIcon
        }, null, 8, ["name"]),
        createElementVNode("view", _hoisted_6$d, toDisplayString(_ctx.loadTxt), 1)
      ])) : !_ctx.hasMore ? (openBlock(), createElementBlock("view", _hoisted_7$9, toDisplayString(_ctx.loadMoreTxt), 1)) : createCommentVNode("", true)
    ])
  ], 34);
}
var InfiniteLoading = /* @__PURE__ */ _export_sfc(_sfc_main$12, [["render", _sfc_render$Y]]);
const { componentName: componentName$L, create: create$11 } = createComponent("notify");
const _sfc_main$11 = create$11({
  components: {
    [Popup.name]: Popup
  },
  props: {
    id: String,
    color: { type: String, default: "" },
    msg: { type: String, default: "" },
    duration: { type: Number, default: 3e3 },
    className: {
      type: String,
      default: ""
    },
    background: { type: String, default: "" },
    type: {
      type: String,
      default: "danger"
    },
    showPopup: {
      type: Boolean,
      default: false
    },
    onClose: Function,
    onClick: Function,
    unmount: Function
  },
  setup(props, { slots }) {
    let timer = null;
    const state = reactive({
      mounted: false
    });
    onMounted(() => {
      state.mounted = true;
    });
    const clickCover = () => {
      props.onClick && props.onClick();
    };
    const clearTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const hide = () => {
      state.mounted = false;
    };
    const show = () => {
      clearTimer();
      if (props.duration) {
        timer = setTimeout(() => {
          hide();
        }, props.duration);
      }
    };
    if (props.duration) {
      show();
    }
    watch(() => props.duration, (val) => {
      if (val) {
        show();
      }
    });
    const onAfterLeave = () => {
      clearTimer();
      props.unmount && props.unmount(props.id);
      props.onClose && props.onClose();
    };
    return { state, hide, onAfterLeave, clickCover };
  }
});
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "toast-fade",
    onAfterLeave: _ctx.onAfterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("view", {
        class: normalizeClass(["popup-top", "nut-notify", `nut-notify--${_ctx.type}`, { className: _ctx.className }]),
        style: normalizeStyle({ color: _ctx.color, background: _ctx.background }),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickCover && _ctx.clickCover(...args))
      }, [
        _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.msg), 1)
        ], 64))
      ], 6), [
        [vShow, _ctx.state.mounted]
      ])
    ]),
    _: 3
  }, 8, ["onAfterLeave"]);
}
var Notify = /* @__PURE__ */ _export_sfc(_sfc_main$11, [["render", _sfc_render$X]]);
const defaultOptions$1 = {
  type: "base",
  showPopup: false,
  msg: "",
  color: void 0,
  background: void 0,
  duration: 3e3,
  className: "",
  onClosed: null,
  onClick: null,
  onOpened: null,
  textTimer: null,
  unmount: null
};
let idsMap$1 = [];
let optsMap$1 = [];
const clearNotify = (id) => {
  if (id) {
    const container = document.getElementById(id);
    optsMap$1 = optsMap$1.filter((item) => item.id !== id);
    idsMap$1 = idsMap$1.filter((item) => item !== id);
    if (container) {
      document.body.removeChild(container);
    }
  } else {
    idsMap$1.forEach((item) => {
      const container = document.getElementById(item);
      if (container) {
        document.body.removeChild(container);
      }
    });
    optsMap$1 = [];
    idsMap$1 = [];
  }
};
const updateNotify = (opts) => {
  const container = document.getElementById(opts.id);
  if (container) {
    const currentOpt = optsMap$1.find((item) => item.id === opts.id);
    if (currentOpt) {
      opts = __spreadValues(__spreadValues(__spreadValues({}, defaultOptions$1), currentOpt), opts);
    } else {
      opts = __spreadValues(__spreadValues({}, defaultOptions$1), opts);
    }
    const instance = createVNode(Notify, opts);
    render(instance, container);
    return instance.component.ctx;
  }
};
const mountNotify = (opts) => {
  opts.unmount = clearNotify;
  let _id;
  if (opts.id) {
    _id = opts.id;
    if (idsMap$1.find((item) => item === opts.id)) {
      return updateNotify(opts);
    }
  } else {
    _id = new Date().getTime() + "";
  }
  opts = __spreadValues(__spreadValues({}, defaultOptions$1), opts);
  opts.id = _id;
  idsMap$1.push(opts.id);
  optsMap$1.push(opts);
  const container = document.createElement("view");
  container.id = opts.id;
  const instance = createVNode(Notify, opts);
  render(instance, container);
  document.body.appendChild(container);
  setTimeout(() => {
    instance.showPopup = true;
  }, 0);
  return instance.component.ctx;
};
const errorMsg$1 = (msg) => {
  if (!msg) {
    console.warn("[NutUI Notify]: msg\u4E0D\u80FD\u4E3A\u7A7A");
    return;
  }
};
const NotifyFunction = {
  text(msg, obj = {}) {
    errorMsg$1(msg);
    return mountNotify(__spreadProps(__spreadValues({}, obj), { msg }));
  },
  primary(msg, obj = {}) {
    errorMsg$1(msg);
    return mountNotify(__spreadProps(__spreadValues({}, obj), { msg, type: "primary" }));
  },
  success(msg, obj = {}) {
    errorMsg$1(msg);
    return mountNotify(__spreadProps(__spreadValues({}, obj), { msg, type: "success" }));
  },
  danger(msg, obj = {}) {
    errorMsg$1(msg);
    return mountNotify(__spreadProps(__spreadValues({}, obj), { msg, type: "danger" }));
  },
  warn(msg, obj = {}) {
    errorMsg$1(msg);
    return mountNotify(__spreadProps(__spreadValues({}, obj), { msg, type: "warning" }));
  },
  hide() {
    clearNotify();
  },
  install(app) {
    app.config.globalProperties.$notify = NotifyFunction;
  }
};
function isWindow(val) {
  return val === window;
}
const useRect = (elementRef) => {
  const element = unref(elementRef);
  if (isWindow(element)) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
  }
  if (element && element.getBoundingClientRect) {
    return element.getBoundingClientRect();
  }
  return {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  };
};
const { componentName: componentName$K, create: create$10 } = createComponent("range");
const _sfc_main$10 = create$10({
  props: {
    range: {
      type: Boolean,
      default: false
    },
    disabled: Boolean,
    activeColor: String,
    inactiveColor: String,
    buttonColor: String,
    hiddenRange: {
      type: Boolean,
      default: false
    },
    hiddenTag: {
      type: Boolean,
      default: false
    },
    min: {
      type: [Number, String],
      default: 0
    },
    max: {
      type: [Number, String],
      default: 100
    },
    step: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: [Number, Array],
      default: 0
    }
  },
  emits: ["change", "drag-end", "drag-start", "update:modelValue"],
  setup(props, { emit, slots }) {
    const buttonIndex = ref(0);
    let startValue;
    let currentValue;
    const root = ref();
    const dragStatus = ref();
    const touch = useTouch();
    const scope = computed(() => Number(props.max) - Number(props.min));
    const classes = computed(() => {
      const prefixCls = componentName$K;
      return {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-show-number`]: !props.hiddenRange
      };
    });
    const wrapperStyle = computed(() => {
      return {
        background: props.inactiveColor
      };
    });
    const buttonStyle = computed(() => {
      return {
        borderColor: props.buttonColor
      };
    });
    const isRange = (val) => !!props.range && Array.isArray(val);
    const calcMainAxis = () => {
      const { modelValue, min } = props;
      if (isRange(modelValue)) {
        return `${(modelValue[1] - modelValue[0]) * 100 / scope.value}%`;
      }
      return `${(modelValue - Number(min)) * 100 / scope.value}%`;
    };
    const calcOffset = () => {
      const { modelValue, min } = props;
      if (isRange(modelValue)) {
        return `${(modelValue[0] - Number(min)) * 100 / scope.value}%`;
      }
      return `0%`;
    };
    const barStyle = computed(() => {
      return {
        width: calcMainAxis(),
        left: calcOffset(),
        background: props.activeColor,
        transition: dragStatus.value ? "none" : void 0
      };
    });
    const format = (value) => {
      const { min, max, step } = props;
      value = Math.max(+min, Math.min(value, +max));
      return Math.round(value / +step) * +step;
    };
    const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
    const handleOverlap = (value) => {
      if (value[0] > value[1]) {
        return value.slice(0).reverse();
      }
      return value;
    };
    const updateValue = (value, end) => {
      if (isRange(value)) {
        value = handleOverlap(value).map(format);
      } else {
        value = format(value);
      }
      if (!isSameValue(value, props.modelValue)) {
        emit("update:modelValue", value);
      }
      if (end && !isSameValue(value, startValue)) {
        emit("change", value);
      }
    };
    const onClick = (event) => {
      if (props.disabled) {
        return;
      }
      const { min, modelValue } = props;
      const rect = useRect(root);
      const delta = event.clientX - rect.left;
      const total = rect.width;
      const value = Number(min) + delta / total * scope.value;
      if (isRange(modelValue)) {
        const [left, right] = modelValue;
        const middle = (left + right) / 2;
        if (value <= middle) {
          updateValue([value, right], true);
        } else {
          updateValue([left, value], true);
        }
      } else {
        updateValue(value, true);
      }
    };
    const onTouchStart = (event) => {
      if (props.disabled) {
        return;
      }
      touch.start(event);
      currentValue = props.modelValue;
      if (isRange(currentValue)) {
        startValue = currentValue.map(format);
      } else {
        startValue = format(currentValue);
      }
      dragStatus.value = "start";
    };
    const onTouchMove = (event) => {
      if (props.disabled) {
        return;
      }
      if (dragStatus.value === "start") {
        emit("drag-start");
      }
      touch.move(event);
      dragStatus.value = "draging";
      const rect = useRect(root);
      const delta = touch.deltaX.value;
      const total = rect.width;
      const diff = delta / total * scope.value;
      if (isRange(startValue)) {
        currentValue[buttonIndex.value] = startValue[buttonIndex.value] + diff;
      } else {
        currentValue = startValue + diff;
      }
      updateValue(currentValue);
      event.stopPropagation();
      event.preventDefault();
    };
    const onTouchEnd = () => {
      if (props.disabled) {
        return;
      }
      if (dragStatus.value === "draging") {
        updateValue(currentValue, true);
        emit("drag-end");
      }
      dragStatus.value = "";
    };
    const curValue = (idx) => {
      const value = typeof idx === "number" ? props.modelValue[idx] : props.modelValue;
      return value;
    };
    return __spreadProps(__spreadValues({
      root,
      classes,
      wrapperStyle,
      buttonStyle,
      onClick,
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }, toRefs(props)), {
      barStyle,
      curValue,
      buttonIndex
    });
  }
});
const _hoisted_1$O = { class: "nut-range-container" };
const _hoisted_2$E = {
  key: 0,
  class: "min"
};
const _hoisted_3$v = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "onTouchstart"];
const _hoisted_4$n = {
  key: 0,
  class: "number"
};
const _hoisted_5$f = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax"];
const _hoisted_6$c = {
  key: 0,
  class: "number"
};
const _hoisted_7$8 = {
  key: 1,
  class: "max"
};
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$O, [
    !_ctx.hiddenRange ? (openBlock(), createElementBlock("view", _hoisted_2$E, toDisplayString(+_ctx.min), 1)) : createCommentVNode("", true),
    createElementVNode("view", {
      ref: "root",
      style: normalizeStyle(_ctx.wrapperStyle),
      class: normalizeClass(_ctx.classes),
      onClick: _cache[9] || (_cache[9] = withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["stop"]))
    }, [
      createElementVNode("view", {
        class: "nut-range-bar",
        style: normalizeStyle(_ctx.barStyle)
      }, [
        _ctx.range ? (openBlock(), createElementBlock(Fragment, { key: 0 }, renderList([0, 1], (index) => {
          return createElementVNode("view", {
            key: index,
            role: "slider",
            class: normalizeClass({
              "nut-range-button-wrapper-left": index == 0,
              "nut-range-button-wrapper-right": index == 1
            }),
            tabindex: _ctx.disabled ? -1 : 0,
            "aria-valuemin": +_ctx.min,
            "aria-valuenow": _ctx.curValue(index),
            "aria-valuemax": +_ctx.max,
            "aria-orientation": "horizontal",
            onTouchstart: withModifiers((e) => {
              if (typeof index === "number") {
                _ctx.buttonIndex = index;
              }
              _ctx.onTouchStart(e);
            }, ["stop", "prevent"]),
            onTouchmove: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args), ["stop", "prevent"])),
            onTouchend: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
            onTouchcancel: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
            onClick: _cache[3] || (_cache[3] = (e) => e.stopPropagation())
          }, [
            _ctx.$slots.button ? renderSlot(_ctx.$slots, "button", { key: 0 }) : (openBlock(), createElementBlock("view", {
              key: 1,
              class: "nut-range-button",
              style: normalizeStyle(_ctx.buttonStyle)
            }, [
              !_ctx.hiddenTag ? (openBlock(), createElementBlock("view", _hoisted_4$n, toDisplayString(_ctx.curValue(index)), 1)) : createCommentVNode("", true)
            ], 4))
          ], 42, _hoisted_3$v);
        }), 64)) : (openBlock(), createElementBlock("view", {
          key: 1,
          role: "slider",
          class: "nut-range-button-wrapper",
          tabindex: _ctx.disabled ? -1 : 0,
          "aria-valuemin": +_ctx.min,
          "aria-valuenow": _ctx.curValue(),
          "aria-valuemax": +_ctx.max,
          "aria-orientation": "horizontal",
          onTouchstart: _cache[4] || (_cache[4] = withModifiers((e) => {
            _ctx.onTouchStart(e);
          }, ["stop", "prevent"])),
          onTouchmove: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args), ["stop", "prevent"])),
          onTouchend: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
          onTouchcancel: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
          onClick: _cache[8] || (_cache[8] = (e) => e.stopPropagation())
        }, [
          _ctx.$slots.button ? renderSlot(_ctx.$slots, "button", { key: 0 }) : (openBlock(), createElementBlock("view", {
            key: 1,
            class: "nut-range-button",
            style: normalizeStyle(_ctx.buttonStyle)
          }, [
            !_ctx.hiddenTag ? (openBlock(), createElementBlock("view", _hoisted_6$c, toDisplayString(_ctx.curValue()), 1)) : createCommentVNode("", true)
          ], 4))
        ], 40, _hoisted_5$f))
      ], 4)
    ], 6),
    !_ctx.hiddenRange ? (openBlock(), createElementBlock("view", _hoisted_7$8, toDisplayString(+_ctx.max), 1)) : createCommentVNode("", true)
  ]);
}
var Range = /* @__PURE__ */ _export_sfc(_sfc_main$10, [["render", _sfc_render$W]]);
const { create: create$$, componentName: componentName$J } = createComponent("steps");
const _sfc_main$$ = create$$({
  props: {
    direction: {
      type: String,
      default: "horizontal"
    },
    current: {
      type: [String, Number],
      default: "0"
    },
    progressDot: {
      type: Boolean,
      default: false
    }
  },
  setup(props, { emit, slots }) {
    const state = reactive({
      children: []
    });
    const classes = computed(() => {
      const prefixCls = componentName$J;
      return {
        [prefixCls]: true,
        [`${prefixCls}-${props.direction}`]: true,
        [`${prefixCls}-dot`]: !!props.progressDot
      };
    });
    const relation = (child) => {
      child && state.children.push(child);
    };
    provide("parent", {
      relation,
      state,
      props
    });
    return () => {
      var _a;
      return h("view", {
        class: classes.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const { create: create$_, componentName: componentName$I } = createComponent("step");
const _sfc_main$_ = create$_({
  props: {
    title: {
      type: String,
      default: ""
    },
    content: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      default: null
    },
    iconColor: {
      type: String,
      default: ""
    },
    size: {
      type: [String, Number],
      default: "12px"
    }
  },
  setup(props, { emit, slots }) {
    const { proxy } = getCurrentInstance();
    const parent = inject("parent");
    parent["relation"](proxy);
    const state = reactive({
      dot: parent.props.progressDot
    });
    const index = computed(() => parent.state.children.indexOf(proxy) + 1);
    const getCurrentStatus = () => {
      const activeIndex = index.value;
      if (activeIndex < +parent.props.current)
        return "finish";
      return activeIndex === +parent.props.current ? "process" : "wait";
    };
    const status = computed(() => {
      return getCurrentStatus();
    });
    const classes = computed(() => {
      const prefixCls = componentName$I;
      return {
        [prefixCls]: true,
        [`${prefixCls}-${status.value}`]: true
      };
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      index,
      classes
    });
  }
});
const _hoisted_1$N = { class: "nut-step-head" };
const _hoisted_2$D = /* @__PURE__ */ createElementVNode("view", { class: "nut-step-line" }, null, -1);
const _hoisted_3$u = {
  key: 2,
  class: "nut-step-inner"
};
const _hoisted_4$m = { class: "nut-step-main" };
const _hoisted_5$e = { class: "nut-step-title" };
const _hoisted_6$b = ["innerHTML"];
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", _hoisted_1$N, [
      _hoisted_2$D,
      createElementVNode("view", {
        class: normalizeClass(["nut-step-icon", [!_ctx.dot ? _ctx.icon ? "is-icon" : "is-text" : ""]])
      }, [
        _ctx.icon ? (openBlock(), createBlock(_component_nut_icon, {
          key: 0,
          class: "nut-step-icon-inner",
          color: _ctx.iconColor,
          name: _ctx.icon,
          size: _ctx.size
        }, null, 8, ["color", "name", "size"])) : _ctx.dot ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [], 64)) : (openBlock(), createElementBlock("view", _hoisted_3$u, toDisplayString(_ctx.index), 1))
      ], 2)
    ]),
    createElementVNode("view", _hoisted_4$m, [
      createElementVNode("view", _hoisted_5$e, toDisplayString(_ctx.title), 1),
      _ctx.content ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "nut-step-content",
        innerHTML: _ctx.content
      }, null, 8, _hoisted_6$b)) : createCommentVNode("", true)
    ])
  ], 2);
}
var Step = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$V]]);
const { componentName: componentName$H, create: create$Z } = createComponent("switch");
const _sfc_main$Z = create$Z({
  props: {
    modelValue: {
      type: [String, Number, Boolean],
      default: false
    },
    disable: {
      type: Boolean,
      default: false
    },
    activeColor: {
      type: String,
      default: ""
    },
    inactiveColor: {
      type: String,
      default: ""
    },
    activeText: {
      type: String,
      default: ""
    },
    inactiveText: {
      type: String,
      default: ""
    },
    activeValue: {
      type: [String, Number, Boolean],
      default: true
    },
    inactiveValue: {
      type: [String, Number, Boolean],
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    name: {
      type: String,
      default: "loading1"
    },
    size: {
      type: [String, Number],
      default: "12px"
    },
    color: {
      type: String,
      default: ""
    }
  },
  emits: ["change", "update:modelValue"],
  setup(props, { emit }) {
    const isActive = computed(() => props.modelValue === props.activeValue);
    const classes = computed(() => {
      const prefixCls = componentName$H;
      return {
        [prefixCls]: true,
        [isActive.value ? "switch-open" : "switch-close"]: true,
        [`${prefixCls}-disable`]: props.disable,
        [`${prefixCls}-base`]: true
      };
    });
    const style = computed(() => {
      return {
        backgroundColor: isActive.value ? props.activeColor : props.inactiveColor
      };
    });
    const onClick = (event) => {
      if (props.disable || props.loading)
        return;
      const value = isActive.value ? props.inactiveValue : props.activeValue;
      emit("update:modelValue", value);
      emit("update:loading");
      emit("change", value, event);
    };
    return {
      classes,
      style,
      onClick
    };
  }
});
const _hoisted_1$M = { class: "switch-button" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args)),
    style: normalizeStyle(_ctx.style)
  }, [
    createElementVNode("view", _hoisted_1$M, [
      _ctx.loading ? (openBlock(), createBlock(_component_nut_icon, {
        key: 0,
        name: _ctx.name,
        size: _ctx.size,
        color: _ctx.color
      }, null, 8, ["name", "size", "color"])) : createCommentVNode("", true),
      _ctx.activeText ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        withDirectives(createElementVNode("view", { class: "nut-switch-label open" }, toDisplayString(_ctx.activeText), 513), [
          [vShow, _ctx.modelValue]
        ]),
        withDirectives(createElementVNode("view", { class: "nut-switch-label close" }, toDisplayString(_ctx.inactiveText), 513), [
          [vShow, !_ctx.modelValue]
        ])
      ], 64)) : createCommentVNode("", true)
    ])
  ], 6);
}
var Switch = /* @__PURE__ */ _export_sfc(_sfc_main$Z, [["render", _sfc_render$U]]);
const { create: create$Y } = createComponent("toast");
const _sfc_main$Y = create$Y({
  components: {
    [_sfc_main$1o.name]: _sfc_main$1o
  },
  props: {
    id: String,
    msg: String,
    duration: {
      type: Number,
      default: 2e3
    },
    center: {
      type: Boolean,
      default: true
    },
    type: String,
    customClass: String,
    bottom: {
      type: String,
      default: "30px"
    },
    size: {
      type: [String, Number],
      default: "base"
    },
    icon: String,
    textAlignCenter: {
      type: Boolean,
      default: true
    },
    loadingRotate: {
      type: Boolean,
      default: true
    },
    bgColor: {
      type: String,
      default: "rgba(0, 0, 0, .8)"
    },
    onClose: Function,
    unmount: Function,
    cover: {
      type: Boolean,
      default: false
    },
    coverColor: {
      type: String,
      default: "rgba(0, 0, 0, 0)"
    },
    title: {
      type: String,
      default: ""
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    let timer;
    const state = reactive({
      mounted: false
    });
    onMounted(() => {
      state.mounted = true;
    });
    const clearTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const hide = () => {
      state.mounted = false;
    };
    const show = () => {
      clearTimer();
      if (props.duration) {
        timer = setTimeout(() => {
          hide();
        }, props.duration);
      }
    };
    const clickCover = () => {
      if (props.closeOnClickOverlay) {
        hide();
      }
    };
    if (props.duration) {
      show();
    }
    watch(() => props.duration, (val) => {
      if (val) {
        show();
      }
    });
    const hasIcon = computed(() => {
      if (props.type !== "text") {
        return true;
      } else {
        return !!props.icon;
      }
    });
    const toastBodyClass = computed(() => {
      return [
        "nut-toast",
        { "nut-toast-center": props.center },
        { "nut-toast-has-icon": hasIcon.value },
        { "nut-toast-cover": props.cover },
        { "nut-toast-loading": props.type === "loading" },
        props.customClass,
        "nut-toast-" + props.size
      ];
    });
    const onAfterLeave = () => {
      clearTimer();
      props.unmount(props.id);
      props.onClose && props.onClose();
    };
    return {
      state,
      hide,
      clickCover,
      hasIcon,
      toastBodyClass,
      onAfterLeave
    };
  }
});
const _hoisted_1$L = {
  key: 0,
  class: "nut-toast-icon-wrapper"
};
const _hoisted_2$C = {
  key: 1,
  class: "nut-toast-title"
};
const _hoisted_3$t = ["innerHTML"];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createBlock(Transition, {
    name: "toast-fade",
    onAfterLeave: _ctx.onAfterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createElementVNode("view", {
        class: normalizeClass(_ctx.toastBodyClass),
        style: normalizeStyle({
          bottom: _ctx.center ? "auto" : _ctx.bottom,
          "background-color": _ctx.coverColor
        }),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickCover && _ctx.clickCover(...args))
      }, [
        createElementVNode("view", {
          class: "nut-toast-inner",
          style: normalizeStyle({
            "text-align": _ctx.textAlignCenter ? "center" : "left",
            "background-color": _ctx.bgColor
          })
        }, [
          _ctx.hasIcon ? (openBlock(), createElementBlock("view", _hoisted_1$L, [
            createVNode(_component_nut_icon, {
              size: "20",
              color: "#ffffff",
              name: _ctx.icon
            }, null, 8, ["name"])
          ])) : createCommentVNode("", true),
          _ctx.title ? (openBlock(), createElementBlock("div", _hoisted_2$C, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
          createElementVNode("view", {
            class: "nut-toast-text",
            innerHTML: _ctx.msg
          }, null, 8, _hoisted_3$t)
        ], 4)
      ], 6), [
        [vShow, _ctx.state.mounted]
      ])
    ]),
    _: 1
  }, 8, ["onAfterLeave"]);
}
var Toast = /* @__PURE__ */ _export_sfc(_sfc_main$Y, [["render", _sfc_render$T]]);
const defaultOptions = {
  msg: "",
  id: "",
  duration: 2e3,
  center: true,
  type: "text",
  title: "",
  customClass: "",
  bottom: "30px",
  size: "base",
  icon: null,
  textAlignCenter: true,
  loadingRotate: true,
  bgColor: "rgba(0, 0, 0, .8)",
  onClose: null,
  unmount: null,
  cover: false,
  coverColor: "rgba(0, 0, 0, 0)",
  closeOnClickOverlay: false
};
let idsMap = [];
let optsMap = [];
const clearToast = (id) => {
  if (id) {
    const container = document.getElementById(id);
    optsMap = optsMap.filter((item) => item.id !== id);
    idsMap = idsMap.filter((item) => item !== id);
    if (container) {
      document.body.removeChild(container);
    }
  } else {
    idsMap.forEach((item) => {
      const container = document.getElementById(item);
      if (container) {
        document.body.removeChild(container);
      }
    });
    optsMap = [];
    idsMap = [];
  }
};
const updateToast = (opts) => {
  const container = document.getElementById(opts.id);
  if (container) {
    const currentOpt = optsMap.find((item) => item.id === opts.id);
    if (currentOpt) {
      opts = __spreadValues(__spreadValues(__spreadValues({}, defaultOptions), currentOpt), opts);
    } else {
      opts = __spreadValues(__spreadValues({}, defaultOptions), opts);
    }
    const instance = createVNode(Toast, opts);
    render(instance, container);
    return instance.component.ctx;
  }
};
const mountToast = (opts) => {
  opts.unmount = clearToast;
  let _id;
  if (opts.id) {
    _id = opts.id;
    if (idsMap.find((item) => item === opts.id)) {
      return updateToast(opts);
    }
  } else {
    _id = new Date().getTime() + "";
  }
  opts = __spreadValues(__spreadValues({}, defaultOptions), opts);
  opts.id = _id;
  idsMap.push(opts.id);
  optsMap.push(opts);
  const container = document.createElement("div");
  container.id = opts.id;
  const instance = createVNode(Toast, opts);
  render(instance, container);
  document.body.appendChild(container);
  return instance.component.ctx;
};
const errorMsg = (msg) => {
  if (!msg) {
    console.warn("[NutUI Toast]: msg\u4E0D\u80FD\u4E3A\u7A7A");
    return;
  }
};
const ToastFunction = {
  text(msg, opts = {}) {
    errorMsg(msg);
    return mountToast(__spreadProps(__spreadValues({}, opts), { type: "text", msg }));
  },
  success(msg, opts = {}) {
    errorMsg(msg);
    return mountToast(__spreadProps(__spreadValues({ icon: "success" }, opts), { msg, type: "success" }));
  },
  fail(msg, opts = {}) {
    errorMsg(msg);
    return mountToast(__spreadProps(__spreadValues({ icon: "failure" }, opts), { msg, type: "fail" }));
  },
  warn(msg, opts = {}) {
    errorMsg(msg);
    return mountToast(__spreadProps(__spreadValues({ icon: "tips" }, opts), { msg, type: "warn" }));
  },
  loading(msg, opts = {}) {
    return mountToast(__spreadProps(__spreadValues({
      icon: "loading"
    }, opts), {
      msg,
      type: "loading"
    }));
  },
  hide(id) {
    clearToast(id);
  },
  install(app) {
    app.use(Toast);
    app.config.globalProperties.$toast = ToastFunction;
  }
};
const { create: create$X } = createComponent("progress");
const _sfc_main$X = create$X({
  props: {
    percentage: {
      type: [Number, String],
      default: 0,
      required: true
    },
    size: {
      type: String,
      default: "base"
    },
    status: {
      type: String,
      default: ""
    },
    strokeWidth: {
      type: [Number, String],
      default: ""
    },
    textInside: {
      type: Boolean,
      default: false
    },
    showText: {
      type: Boolean,
      default: true
    },
    strokeColor: {
      type: String,
      default: ""
    },
    textColor: {
      tyep: String,
      default: ""
    },
    iconName: {
      type: String,
      default: "checked"
    },
    iconColor: {
      type: String,
      default: "#439422"
    }
  },
  setup(props, { emit }) {
    const height = ref(props.strokeWidth + "px");
    const progressOuter = ref();
    const left = ref();
    const bgStyle = computed(() => {
      return {
        width: props.percentage + "%",
        background: props.strokeColor || ""
      };
    });
    const textStyle = computed(() => {
      return {
        color: props.textColor || ""
      };
    });
    watch(() => props.percentage, (values) => {
      console.log("progressOuter.value.offsetWidth", progressOuter.value.offsetWidth);
      console.log("values", values);
      left.value = progressOuter.value.offsetWidth * Number(values) * 0.01 - 5 + "px";
    });
    onMounted(() => {
      left.value = progressOuter.value.offsetWidth * Number(props.percentage) * 0.01 - 5 + "px";
    });
    return {
      height,
      bgStyle,
      textStyle,
      progressOuter,
      left
    };
  }
});
const _hoisted_1$K = { class: "nut-progress" };
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("div", _hoisted_1$K, [
    createElementVNode("div", {
      class: normalizeClass(["nut-progress-outer", [
        _ctx.showText && !_ctx.textInside ? "nut-progress-outer-part" : "",
        _ctx.size ? "nut-progress-" + _ctx.size : ""
      ]]),
      ref: "progressOuter",
      style: normalizeStyle({ height: _ctx.height })
    }, [
      createElementVNode("div", {
        class: normalizeClass(["nut-progress-inner", _ctx.status == "active" ? "nut-active" : ""]),
        style: normalizeStyle(_ctx.bgStyle)
      }, [
        _ctx.showText && _ctx.textInside ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "nut-progress-text nut-progress-insidetext",
          style: normalizeStyle({ lineHeight: _ctx.height, left: _ctx.left })
        }, [
          createElementVNode("span", {
            style: normalizeStyle(_ctx.textStyle)
          }, toDisplayString(_ctx.percentage) + "%", 5)
        ], 4)) : createCommentVNode("", true)
      ], 6)
    ], 6),
    _ctx.showText && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "nut-progress-text",
      style: normalizeStyle({ lineHeight: _ctx.height })
    }, [
      _ctx.status == "active" || _ctx.status == "" ? (openBlock(), createElementBlock("span", {
        key: 0,
        style: normalizeStyle(_ctx.textStyle)
      }, toDisplayString(_ctx.percentage) + "%", 5)) : _ctx.status == "icon" ? (openBlock(), createBlock(_component_nut_icon, {
        key: 1,
        size: "16px",
        name: _ctx.iconName,
        color: _ctx.iconColor
      }, null, 8, ["name", "color"])) : createCommentVNode("", true)
    ], 4)) : createCommentVNode("", true)
  ]);
}
var Progress = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$S]]);
const { componentName: componentName$G, create: create$W } = createComponent("circleprogress");
const _sfc_main$W = create$W({
  props: {
    progress: {
      type: [Number, String],
      required: true
    },
    strokeInnerWidth: {
      type: [Number, String],
      default: 10
    },
    isAuto: {
      tyep: Boolean,
      default: false
    },
    progressOption: {
      type: Object,
      default: () => {
      }
    }
  },
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$G;
      return {
        [prefixCls]: true
      };
    });
    const option = computed(() => {
      let baseOption = {
        radius: 50,
        strokeOutWidth: 10,
        backColor: "#d9d9d9",
        progressColor: "red",
        cy: 1,
        cx: 1,
        size: 1,
        startPosition: ""
      };
      Object.assign(baseOption, props.progressOption);
      baseOption.cy = baseOption.cx = baseOption.radius + baseOption.strokeOutWidth;
      baseOption.size = (baseOption.radius + baseOption.strokeOutWidth) * 2;
      baseOption.startPosition = "rotate(-90," + baseOption.cx + "," + baseOption.cy + ")";
      return baseOption;
    });
    const arcLength = computed(() => {
      let circleLength = Math.floor(2 * Math.PI * option.value.radius);
      let progressLength = props.progress / 100 * circleLength;
      return `${progressLength},${circleLength}`;
    });
    return {
      classes,
      option,
      arcLength
    };
  }
});
const _hoisted_1$J = ["height", "width"];
const _hoisted_2$B = ["r", "cx", "cy", "stroke", "stroke-width"];
const _hoisted_3$s = ["r", "cx", "cy", "stroke", "stroke-dasharray", "stroke-width", "transform"];
const _hoisted_4$l = { class: "nut-circleprogress-content" };
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle({ height: _ctx.option.size + "px", width: _ctx.option.size + "px" })
  }, [
    (openBlock(), createElementBlock("svg", {
      height: _ctx.option.size,
      width: _ctx.option.size,
      "x-mlns": "http://www.w3.org/200/svg"
    }, [
      createElementVNode("circle", {
        r: _ctx.option.radius,
        cx: _ctx.option.cx,
        cy: _ctx.option.cy,
        stroke: _ctx.option.backColor,
        "stroke-width": _ctx.option.strokeOutWidth,
        fill: "none"
      }, null, 8, _hoisted_2$B),
      createElementVNode("circle", {
        r: _ctx.option.radius,
        cx: _ctx.option.cx,
        cy: _ctx.option.cy,
        stroke: _ctx.option.progressColor,
        "stroke-dasharray": _ctx.arcLength,
        "stroke-width": _ctx.strokeInnerWidth,
        fill: "none",
        transform: _ctx.option.startPosition,
        "stroke-linecap": "round",
        style: { "transition": "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease 0s" }
      }, null, 8, _hoisted_3$s)
    ], 8, _hoisted_1$J)),
    createElementVNode("div", _hoisted_4$l, [
      !_ctx.isAuto ? renderSlot(_ctx.$slots, "default", { key: 0 }, () => [
        createTextVNode(toDisplayString(_ctx.progress) + "%", 1)
      ]) : renderSlot(_ctx.$slots, "default", { key: 1 })
    ])
  ], 6);
}
var CircleProgress = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$R]]);
const { componentName: componentName$F, create: create$V } = createComponent("noticebar");
const _sfc_main$V = create$V({
  props: {
    direction: {
      type: String,
      default: "across"
    },
    list: {
      type: Array,
      default: () => {
        return [];
      }
    },
    standTime: {
      type: Number,
      default: 1e3
    },
    complexAm: {
      type: Boolean,
      default: false
    },
    height: {
      type: Number,
      default: 40
    },
    text: {
      type: String,
      default: ""
    },
    closeMode: {
      type: Boolean,
      default: false
    },
    wrapable: {
      type: Boolean,
      default: false
    },
    leftIcon: { type: String, default: "" },
    color: {
      type: String,
      default: ""
    },
    background: {
      type: String,
      default: ""
    },
    delay: {
      type: [String, Number],
      default: 1
    },
    scrollable: {
      type: Boolean,
      default: true
    },
    speed: {
      type: Number,
      default: 50
    }
  },
  components: {
    ScrollItem: function(props) {
      props.item.props.style = props.style;
      return h(props.item);
    }
  },
  emits: ["click", "close"],
  setup(props, { emit, slots }) {
    console.log("componentName", componentName$F);
    const wrap = ref(null);
    const content = ref(null);
    const state = reactive({
      wrapWidth: 0,
      firstRound: true,
      duration: 0,
      offsetWidth: 0,
      showNoticeBar: true,
      animationClass: "",
      animate: false,
      scrollList: [],
      distance: 0,
      timer: null,
      keepAlive: false
    });
    const classes = computed(() => {
      const prefixCls = componentName$F;
      return {
        [prefixCls]: true
      };
    });
    const iconShow = computed(() => {
      if (props.leftIcon == "close") {
        return false;
      } else {
        return true;
      }
    });
    const barStyle = computed(() => {
      let style = {};
      props.color && (style.color = props.color);
      props.background && (style.background = props.background);
      if (props.direction == "vertical") {
        style.height = `${props.height}px`;
      }
      return style;
    });
    const contentStyle = computed(() => {
      return {
        paddingLeft: state.firstRound ? 0 : state.wrapWidth + "px",
        animationDelay: (state.firstRound ? props.delay : 0) + "s",
        animationDuration: state.duration + "s"
      };
    });
    const iconBg = computed(() => {
      let iconBg2 = "";
      if (props.leftIcon) {
        iconBg2 = props.leftIcon;
      }
      return iconBg2;
    });
    const horseLampStyle = computed(() => {
      let styles = {};
      if (props.complexAm) {
        styles = {
          transform: `translateY(${state.distance}px)`
        };
      } else {
        if (state.animate) {
          let a = ~~(props.height / props.speed / 4);
          styles = {
            transition: `all ${a == 0 ? ~~(props.height / props.speed) : a}s`,
            "margin-top": `-${props.height}px`
          };
        }
      }
      return styles;
    });
    watch(() => props.text, (value) => {
      initScrollWrap(value);
    });
    watch(() => props.list, (value) => {
      state.scrollList = [].concat(value);
    });
    const initScrollWrap = (value) => {
      if (state.showNoticeBar == false) {
        return;
      }
      setTimeout(() => {
        if (!wrap.value || !content.value) {
          return;
        }
        const wrapWidth = wrap.value.getBoundingClientRect().width;
        const offsetWidth = content.value.getBoundingClientRect().width;
        if (props.scrollable && offsetWidth > wrapWidth) {
          state.wrapWidth = wrapWidth;
          state.offsetWidth = offsetWidth;
          state.duration = offsetWidth / props.speed;
          state.animationClass = "play";
        } else {
          state.animationClass = "";
        }
      });
    };
    const handleClick = (event) => {
      emit("click", event);
    };
    const onClickIcon = (event) => {
      state.showNoticeBar = !props.closeMode;
      emit("close", event);
    };
    const onAnimationEnd = () => {
      state.firstRound = false;
      setTimeout(() => {
        state.duration = (state.offsetWidth + state.wrapWidth) / props.speed;
        state.animationClass = "play-infinite";
      }, 0);
    };
    const startRollEasy = () => {
      showhorseLamp();
      state.timer = setInterval(showhorseLamp, ~~(props.height / props.speed / 4 * 1e3) + props.standTime);
    };
    const showhorseLamp = () => {
      state.animate = true;
      setTimeout(() => {
        state.scrollList.push(state.scrollList[0]);
        state.scrollList.shift();
        state.animate = false;
      }, ~~(props.height / props.speed / 4 * 1e3));
    };
    const startRoll = () => {
      state.timer = setInterval(() => {
        let chunk = 100;
        for (let i = 0; i < chunk; i++) {
          scroll(i, i < chunk - 1 ? false : true);
        }
      }, props.standTime + 100 * props.speed);
    };
    const scroll = (n, last) => {
      setTimeout(() => {
        state.distance -= props.height / 100;
        if (last) {
          state.scrollList.push(state.scrollList[0]);
          state.scrollList.shift();
          state.distance = 0;
        }
      }, n * props.speed);
    };
    const go = (item) => {
      emit("click", item);
    };
    const handleClickIcon = () => {
      emit("close", state.scrollList[0]);
    };
    onMounted(() => {
      console.log(props.direction);
      if (props.direction == "vertical") {
        if (slots.default) {
          state.scrollList = [].concat(slots.default()[0].children);
        } else {
          state.scrollList = [].concat(props.list);
        }
        console.log(state.scrollList);
        setTimeout(() => {
          props.complexAm ? startRoll() : startRollEasy();
        }, props.standTime);
      } else {
        initScrollWrap(props.text);
      }
    });
    onActivated(() => {
      if (state.keepAlive) {
        state.keepAlive = false;
      }
    });
    onDeactivated(() => {
      state.keepAlive = true;
      clearInterval(state.timer);
    });
    onUnmounted(() => {
      clearInterval(state.timer);
    });
    return __spreadProps(__spreadValues(__spreadValues({}, toRefs(props)), toRefs(state)), {
      classes,
      iconShow,
      barStyle,
      contentStyle,
      iconBg,
      horseLampStyle,
      wrap,
      content,
      handleClick,
      onClickIcon,
      onAnimationEnd,
      go,
      handleClickIcon,
      slots
    });
  }
});
const _hoisted_1$I = {
  ref: "wrap",
  class: "wrap"
};
const _hoisted_2$A = ["onClick"];
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_ScrollItem = resolveComponent("ScrollItem");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.direction == "across" ? withDirectives((openBlock(), createElementBlock("view", {
      key: 0,
      class: normalizeClass(["nut-noticebar-page", { withicon: _ctx.closeMode, close: _ctx.closeMode, wrapable: _ctx.wrapable }]),
      style: normalizeStyle(_ctx.barStyle),
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.iconShow ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "left-icon",
        style: normalizeStyle({ "background-image": `url(${_ctx.iconBg})` })
      }, [
        !_ctx.iconBg ? (openBlock(), createBlock(_component_nut_icon, {
          key: 0,
          name: "notice",
          size: "16",
          color: _ctx.color
        }, null, 8, ["color"])) : createCommentVNode("", true)
      ], 4)) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_1$I, [
        createElementVNode("view", {
          ref: "content",
          class: normalizeClass(["content", [_ctx.animationClass, { "nut-ellipsis": !_ctx.scrollable && !_ctx.wrapable }]]),
          style: normalizeStyle(_ctx.contentStyle),
          onAnimationend: _cache[0] || (_cache[0] = (...args) => _ctx.onAnimationEnd && _ctx.onAnimationEnd(...args)),
          onWebkitAnimationEnd: _cache[1] || (_cache[1] = (...args) => _ctx.onAnimationEnd && _ctx.onAnimationEnd(...args))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.text), 1)
          ])
        ], 38)
      ], 512),
      _ctx.closeMode ? (openBlock(), createElementBlock("view", {
        key: 1,
        class: "right-icon",
        onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.onClickIcon && _ctx.onClickIcon(...args), ["stop"]))
      }, [
        createVNode(_component_nut_icon, {
          name: "close",
          color: _ctx.color
        }, null, 8, ["color"])
      ])) : createCommentVNode("", true)
    ], 6)), [
      [vShow, _ctx.showNoticeBar]
    ]) : createCommentVNode("", true),
    _ctx.scrollList.length > 0 && _ctx.direction == "vertical" ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: "nut-noticebar-vertical",
      style: normalizeStyle(_ctx.barStyle)
    }, [
      _ctx.slots.default ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "horseLamp_list",
        style: normalizeStyle(_ctx.horseLampStyle)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.scrollList, (item, index) => {
          return openBlock(), createBlock(_component_ScrollItem, {
            key: index,
            style: normalizeStyle({ height: _ctx.height + "px", "line-height": _ctx.height + "px" }),
            item
          }, null, 8, ["style", "item"]);
        }), 128))
      ], 4)) : (openBlock(), createElementBlock("ul", {
        key: 1,
        class: "horseLamp_list",
        style: normalizeStyle(_ctx.horseLampStyle)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.scrollList, (item, index) => {
          return openBlock(), createElementBlock("li", {
            class: "horseLamp_list_item",
            key: index,
            style: normalizeStyle({ height: _ctx.height }),
            onClick: ($event) => _ctx.go(item)
          }, toDisplayString(item), 13, _hoisted_2$A);
        }), 128))
      ], 4)),
      createElementVNode("view", {
        class: "go",
        onClick: _cache[4] || (_cache[4] = ($event) => !_ctx.slots.rightIcon && _ctx.handleClickIcon())
      }, [
        _ctx.slots.rightIcon ? renderSlot(_ctx.$slots, "rightIcon", { key: 0 }) : _ctx.closeMode ? (openBlock(), createBlock(_component_nut_icon, {
          key: 1,
          type: "cross",
          color: _ctx.color,
          size: "11px"
        }, null, 8, ["color"])) : createCommentVNode("", true)
      ])
    ], 4)) : createCommentVNode("", true)
  ], 2);
}
var NoticeBar = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$Q]]);
const { create: create$U } = createComponent("searchbar");
const _sfc_main$U = create$U({
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    inputType: {
      type: String,
      default: "text"
    },
    maxLength: {
      type: [String, Number],
      default: "9999"
    },
    placeholder: {
      type: String,
      default: "\u8BF7\u8F93\u5165"
    },
    clearable: {
      type: Boolean,
      default: true
    },
    background: {
      type: String,
      default: ""
    },
    inputBackground: {
      type: String,
      default: ""
    }
  },
  emits: ["change", "update:modelValue", "blur", "focus", "clear", "search"],
  setup(props, { emit }) {
    const state = reactive({
      active: false
    });
    const searchbarStyle = computed(() => {
      return {
        background: props.background
      };
    });
    const inputSearchbarStyle = computed(() => {
      return {
        background: props.inputBackground
      };
    });
    const valueChange = (event) => {
      const input = event.target;
      let val = input.value;
      if (props.maxLength && val.length > Number(props.maxLength)) {
        val = val.slice(0, Number(props.maxLength));
      }
      emit("update:modelValue", val, event);
      emit("change", val, event);
    };
    const valueFocus = (event) => {
      const input = event.target;
      let value = input.value;
      state.active = true;
      emit("focus", value, event);
    };
    const valueBlur = (event) => {
      setTimeout(() => {
        state.active = false;
      }, 0);
      const input = event.target;
      let value = input.value;
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.slice(0, Number(props.maxLength));
      }
      emit("blur", value, event);
    };
    const handleClear = (event) => {
      emit("update:modelValue", "", event);
      emit("change", "", event);
      emit("clear", "");
    };
    const handleSubmit = () => {
      emit("search", props.modelValue);
    };
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      valueChange,
      valueFocus,
      valueBlur,
      handleClear,
      handleSubmit,
      searchbarStyle,
      inputSearchbarStyle
    });
  }
});
const _hoisted_1$H = {
  key: 0,
  class: "nut-searchbar__search-icon nut-searchbar__left-search-icon"
};
const _hoisted_2$z = {
  key: 0,
  class: "nut-searchbar__search-icon nut-searchbar__iptleft-search-icon"
};
const _hoisted_3$r = { class: "nut-searchbar__input-inner" };
const _hoisted_4$k = ["type", "maxlength", "placeholder", "value"];
const _hoisted_5$d = {
  key: 1,
  class: "nut-searchbar__search-icon nut-searchbar__iptright-sarch-icon"
};
const _hoisted_6$a = {
  key: 1,
  class: "nut-searchbar__search-icon nut-searchbar__right-search-icon"
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: "nut-searchbar",
    style: normalizeStyle(_ctx.searchbarStyle)
  }, [
    _ctx.$slots.leftout ? (openBlock(), createElementBlock("view", _hoisted_1$H, [
      renderSlot(_ctx.$slots, "leftout")
    ])) : createCommentVNode("", true),
    createElementVNode("view", {
      class: "nut-searchbar__search-input",
      style: normalizeStyle(_ctx.inputSearchbarStyle)
    }, [
      _ctx.$slots.leftin ? (openBlock(), createElementBlock("view", _hoisted_2$z, [
        renderSlot(_ctx.$slots, "leftin")
      ])) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_3$r, [
        createElementVNode("form", {
          action: "#",
          onSubmit: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.handleSubmit && _ctx.handleSubmit(...args), ["prevent"]))
        }, [
          createElementVNode("input", {
            class: "nut-searchbar__input-bar",
            type: _ctx.inputType,
            maxlength: _ctx.maxLength,
            placeholder: _ctx.placeholder,
            value: _ctx.modelValue,
            onInput: _cache[0] || (_cache[0] = (...args) => _ctx.valueChange && _ctx.valueChange(...args)),
            onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.valueFocus && _ctx.valueFocus(...args)),
            onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.valueBlur && _ctx.valueBlur(...args))
          }, null, 40, _hoisted_4$k)
        ], 32),
        _ctx.clearable ? withDirectives((openBlock(), createElementBlock("view", {
          key: 0,
          onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClear && _ctx.handleClear(...args)),
          class: "nut-searchbar__input-clear"
        }, [
          createVNode(_component_nut_icon, {
            name: "circle-close",
            size: "12",
            color: "#555"
          })
        ], 512)), [
          [vShow, _ctx.modelValue.length > 0]
        ]) : createCommentVNode("", true)
      ]),
      _ctx.$slots.rightin ? (openBlock(), createElementBlock("view", _hoisted_5$d, [
        renderSlot(_ctx.$slots, "rightin")
      ])) : createCommentVNode("", true)
    ], 4),
    _ctx.$slots.rightout ? (openBlock(), createElementBlock("view", _hoisted_6$a, [
      renderSlot(_ctx.$slots, "rightout")
    ])) : createCommentVNode("", true)
  ], 4);
}
var SearchBar = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$P]]);
const { componentName: componentName$E, create: create$T } = createComponent("empty");
const defaultStatus = {
  empty: "https://static-ftcms.jd.com/p/files/61a9e3183985005b3958672b.png",
  error: "https://ftcms.jd.com/p/files/61a9e33ee7dcdbcc0ce62736.png",
  network: "https://static-ftcms.jd.com/p/files/61a9e31de7dcdbcc0ce62734.png"
};
const _sfc_main$T = create$T({
  props: {
    image: {
      type: String,
      default: "empty"
    },
    imageSize: {
      type: [Number, String],
      default: ""
    },
    description: {
      type: String,
      default: "\u65E0\u5185\u5BB9"
    }
  },
  setup(props) {
    const { image, imageSize } = toRefs(props);
    const imgStyle = computed(() => {
      if (!imageSize.value) {
        return "";
      }
      if (typeof imageSize.value === "number") {
        return `width:${imageSize.value}px;height:${imageSize.value}px`;
      }
      return `width:${imageSize.value};height:${imageSize.value}`;
    });
    const isHttpUrl = image.value.startsWith("https://") || image.value.startsWith("http://") || image.value.startsWith("//");
    const imageUrl = isHttpUrl ? image.value : defaultStatus[image.value];
    return {
      imageUrl,
      imgStyle
    };
  }
});
const _hoisted_1$G = { class: "nut-empty" };
const _hoisted_2$y = ["src"];
const _hoisted_3$q = {
  key: 1,
  class: "nut-empty-description"
};
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$G, [
    createElementVNode("view", {
      class: "nut-empty-image",
      style: normalizeStyle(_ctx.imgStyle)
    }, [
      _ctx.$slots.image ? renderSlot(_ctx.$slots, "image", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.imageUrl ? (openBlock(), createElementBlock("img", {
          key: 0,
          class: "img",
          src: _ctx.imageUrl
        }, null, 8, _hoisted_2$y)) : createCommentVNode("", true)
      ], 64))
    ], 4),
    _ctx.$slots.description ? renderSlot(_ctx.$slots, "description", { key: 0 }) : (openBlock(), createElementBlock("view", _hoisted_3$q, toDisplayString(_ctx.description), 1)),
    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 2 }) : createCommentVNode("", true)
  ]);
}
var Empty = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$O]]);
const { componentName: componentName$D, create: create$S } = createComponent("navbar");
const _sfc_main$S = create$S({
  props: {
    leftShow: { type: Boolean, default: true },
    title: { type: String, default: "" },
    titIcon: { type: String, default: "" },
    icon: { type: String, default: "" },
    desc: { type: String, default: "" },
    defaultIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [
    "click",
    "on-click-back",
    "on-click-title",
    "on-click-right",
    "on-click-desc",
    "on-click-icon",
    "on-click-more",
    "on-click-clear",
    "on-click-send",
    "on-click-slot",
    "on-click-slot-send",
    "switch-tab"
  ],
  setup(props, { emit }) {
    const activeIndex = ref(props.defaultIndex);
    const classes = computed(() => {
      const prefixCls = componentName$D;
      return {
        [prefixCls]: true
      };
    });
    function handleLeft() {
      emit("on-click-back");
    }
    function handleCenter() {
      emit("on-click-title");
    }
    function handleCenterIcon() {
      emit("on-click-icon");
    }
    function handleClear() {
      emit("on-click-clear");
    }
    function handleSend() {
      emit("on-click-send");
    }
    function handleSlot() {
      emit("on-click-slot");
    }
    function handleSends() {
      emit("on-click-slot-send");
    }
    return {
      classes,
      handleLeft,
      handleCenter,
      handleCenterIcon,
      handleClear,
      handleSend,
      handleSlot,
      handleSends,
      activeIndex
    };
  }
});
const _hoisted_1$F = { class: "nut-navbar__left" };
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", _hoisted_1$F, [
      _ctx.leftShow ? (openBlock(), createBlock(_component_nut_icon, {
        key: 0,
        color: "#979797",
        name: "left",
        onClick: _ctx.handleLeft
      }, null, 8, ["onClick"])) : createCommentVNode("", true)
    ]),
    createElementVNode("view", {
      class: normalizeClass(["nut-navbar__title", { icon: _ctx.icon }])
    }, [
      _ctx.title ? (openBlock(), createElementBlock("view", {
        key: 0,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleCenter && _ctx.handleCenter(...args))
      }, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
      _ctx.titIcon ? (openBlock(), createBlock(_component_nut_icon, {
        key: 1,
        class: "icon",
        name: _ctx.titIcon,
        onClick: _ctx.handleCenterIcon
      }, null, 8, ["name", "onClick"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "content")
    ], 2),
    _ctx.desc || _ctx.icon ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: normalizeClass(["nut-navbar__right", { icon: _ctx.icon }])
    }, [
      _ctx.desc ? (openBlock(), createElementBlock("view", {
        key: 0,
        style: normalizeStyle({ "text-align": _ctx.descTextAlign }),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClear && _ctx.handleClear(...args))
      }, toDisplayString(_ctx.desc), 5)) : createCommentVNode("", true),
      _ctx.icon ? (openBlock(), createElementBlock("view", {
        key: 1,
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleSends && _ctx.handleSends(...args))
      }, [
        renderSlot(_ctx.$slots, "icons")
      ])) : createCommentVNode("", true),
      createElementVNode("view", null, [
        _ctx.icon ? (openBlock(), createBlock(_component_nut_icon, {
          key: 0,
          class: "rightIcon",
          name: _ctx.icon,
          onClick: _ctx.handleSend
        }, null, 8, ["name", "onClick"])) : createCommentVNode("", true)
      ])
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var Navbar = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$N]]);
const { componentName: componentName$C, create: create$R } = createComponent("fixednav");
const _sfc_main$R = create$R({
  components: {
    [OverLay.name]: OverLay
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    overlay: {
      type: Boolean,
      default: true
    },
    navList: {
      default: () => [],
      type: Array
    },
    activeText: {
      default: "\u6536\u8D77\u5BFC\u822A",
      type: String
    },
    unActiveText: {
      default: "\u5FEB\u901F\u5BFC\u822A",
      type: String
    },
    position: {
      default: () => {
        return {
          top: "auto",
          bottom: "auto"
        };
      },
      type: Object
    },
    type: {
      default: "right",
      type: String
    }
  },
  components: {},
  emits: ["update:visible", "selected"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$C;
      return {
        [prefixCls]: true,
        active: props.visible,
        [props.type]: true
      };
    });
    const updateValue = (value = !props.visible) => {
      emit("update:visible", value);
    };
    const selected = (item, event) => {
      emit("selected", {
        item,
        event
      });
    };
    return { classes, updateValue, selected };
  }
});
const _hoisted_1$E = { class: "nut-fixednav__list" };
const _hoisted_2$x = ["onClick"];
const _hoisted_3$p = ["src"];
const _hoisted_4$j = { class: "span" };
const _hoisted_5$c = {
  key: 0,
  class: "b"
};
const _hoisted_6$9 = { class: "text" };
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_overlay = resolveComponent("nut-overlay");
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.position)
  }, [
    _ctx.overlay ? (openBlock(), createBlock(_component_nut_overlay, {
      key: 0,
      visible: _ctx.visible,
      "z-index": 200,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.updateValue(false))
    }, null, 8, ["visible"])) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "list", {}, () => [
      createElementVNode("view", _hoisted_1$E, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.navList, (item, index) => {
          return openBlock(), createElementBlock("view", {
            class: "nut-fixednav__list-item",
            onClick: ($event) => _ctx.selected(item, $event),
            key: item.id || index
          }, [
            createElementVNode("img", {
              src: item.icon
            }, null, 8, _hoisted_3$p),
            createElementVNode("view", _hoisted_4$j, toDisplayString(item.text), 1),
            item.num ? (openBlock(), createElementBlock("view", _hoisted_5$c, toDisplayString(item.num), 1)) : createCommentVNode("", true)
          ], 8, _hoisted_2$x);
        }), 128))
      ])
    ]),
    createElementVNode("div", {
      class: "nut-fixednav__btn",
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.updateValue())
    }, [
      renderSlot(_ctx.$slots, "btn", {}, () => [
        createVNode(_component_nut_icon, {
          name: "left",
          color: "#fff"
        }),
        createElementVNode("view", _hoisted_6$9, toDisplayString(_ctx.visible ? _ctx.activeText : _ctx.unActiveText), 1)
      ])
    ])
  ], 6);
}
var FixedNav = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$M]]);
const { componentName: componentName$B, create: create$Q } = createComponent("menu");
const _sfc_main$Q = create$Q({
  props: {
    activeColor: {
      type: String,
      default: ""
    },
    overlay: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 0
    }
  },
  setup(props, { emit, slots }) {
    const barRef = ref();
    const offset = ref(0);
    const useChildren = () => {
      const publicChildren = reactive([]);
      const internalChildren = reactive([]);
      const linkChildren2 = (value) => {
        const link = (child) => {
          if (child.proxy) {
            internalChildren.push(child);
            publicChildren.push(child.proxy);
          }
        };
        provide("menuParent", Object.assign({
          link,
          children: publicChildren,
          internalChildren
        }, value));
      };
      return {
        children: publicChildren,
        linkChildren: linkChildren2
      };
    };
    const { children, linkChildren } = useChildren();
    const opened = computed(() => children.some((item) => item.state.showWrapper));
    const classes = computed(() => {
      const prefixCls = componentName$B;
      return {
        [prefixCls]: true
      };
    });
    const updateOffset = () => {
      if (barRef.value) {
        const rect = useRect(barRef);
        offset.value = rect.bottom;
      }
    };
    linkChildren({ props, offset });
    const toggleItem = (active) => {
      children.forEach((item, index) => {
        if (index === active) {
          updateOffset();
          item.toggle();
        } else if (item.state.showPopup) {
          item.toggle(false, { immediate: true });
        }
      });
    };
    return {
      toggleItem,
      children,
      opened,
      classes,
      barRef
    };
  }
});
const _hoisted_1$D = ["onClick"];
const _hoisted_2$w = { class: "nut-menu__title-text" };
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", {
      class: normalizeClass(["nut-menu__bar", { opened: _ctx.opened }]),
      ref: "barRef"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.children, (item, index) => {
        return openBlock(), createElementBlock("view", {
          key: index,
          class: normalizeClass(["nut-menu__item", { disabled: item.disabled, active: item.state.showPopup }]),
          onClick: ($event) => !item.disabled && _ctx.toggleItem(index),
          style: normalizeStyle({ color: item.state.showPopup ? _ctx.activeColor : "" })
        }, [
          createElementVNode("view", {
            class: normalizeClass(["nut-menu__title", { active: item.state.showPopup }])
          }, [
            createElementVNode("view", _hoisted_2$w, toDisplayString(item.renderTitle()), 1),
            createVNode(_component_nut_icon, {
              name: item.titleIcon,
              size: "10",
              class: "nut-menu__title-icon"
            }, null, 8, ["name"])
          ], 2)
        ], 14, _hoisted_1$D);
      }), 128))
    ], 2),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var Menu = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$L]]);
const { componentName: componentName$A, create: create$P } = createComponent("menu-item");
const _sfc_main$P = create$P({
  props: {
    title: String,
    options: {
      type: Array,
      default: []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: null,
    cols: {
      type: Number,
      default: 1
    },
    titleIcon: {
      type: String,
      default: "down-arrow"
    }
  },
  components: {
    [_sfc_main$1o.name]: _sfc_main$1o,
    [Popup.name]: Popup
  },
  emits: ["update:modelValue", "change"],
  setup(props, { emit, slots }) {
    const state = reactive({
      showPopup: false,
      transition: true,
      showWrapper: false,
      isShowPlaceholderElement: false
    });
    const useParent = () => {
      const parent2 = inject("menuParent", null);
      if (parent2) {
        const instance = getCurrentInstance();
        const { link } = parent2;
        link(instance);
        return {
          parent: parent2
        };
      }
    };
    const { parent } = useParent();
    const classes = computed(() => {
      const prefixCls = componentName$A;
      return {
        [prefixCls]: true
      };
    });
    const toggle = (show = !state.showPopup, options = {}) => {
      if (show === state.showPopup) {
        return;
      }
      state.showPopup = show;
      state.isShowPlaceholderElement = show;
      if (show) {
        state.showWrapper = true;
      }
    };
    const renderTitle = () => {
      var _a;
      if (props.title) {
        return props.title;
      }
      const match = (_a = props.options) == null ? void 0 : _a.find((option) => option.value === props.modelValue);
      return match ? match.text : "";
    };
    const onClick = (option) => {
      state.showPopup = false;
      state.isShowPlaceholderElement = false;
      if (option.value !== props.modelValue) {
        emit("update:modelValue", option.value);
        emit("change", option.value);
      }
    };
    const handleClose = () => {
      state.showWrapper = false;
      state.isShowPlaceholderElement = false;
    };
    const handleClickOutside = () => {
      state.showPopup = false;
    };
    return {
      classes,
      renderTitle,
      state,
      parent,
      toggle,
      onClick,
      handleClose,
      handleClickOutside
    };
  }
});
const _hoisted_1$C = { class: "nut-menu-item__content" };
const _hoisted_2$v = ["onClick"];
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_popup = resolveComponent("nut-popup");
  return withDirectives((openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    withDirectives(createElementVNode("div", {
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClickOutside && _ctx.handleClickOutside(...args)),
      class: "placeholder-element",
      style: normalizeStyle({ height: _ctx.parent.offset.value + "px" })
    }, null, 4), [
      [vShow, _ctx.state.isShowPlaceholderElement]
    ]),
    createVNode(_component_nut_popup, mergeProps({
      style: { top: _ctx.parent.offset.value + "px" },
      overlayStyle: { top: _ctx.parent.offset.value + "px" }
    }, _ctx.$attrs, {
      visible: _ctx.state.showPopup,
      "onUpdate:visible": _cache[1] || (_cache[1] = ($event) => _ctx.state.showPopup = $event),
      position: "top",
      duration: _ctx.parent.props.duration,
      "pop-class": "nut-menu__pop",
      overlayClass: "nut-menu__overlay",
      overlay: _ctx.parent.props.overlay,
      onClosed: _ctx.handleClose,
      isWrapTeleport: false
    }), {
      default: withCtx(() => [
        createElementVNode("view", _hoisted_1$C, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index) => {
            return openBlock(), createElementBlock("view", {
              key: index,
              class: normalizeClass(["nut-menu-item__option", { active: option.value === _ctx.modelValue }]),
              style: normalizeStyle({ "flex-basis": 100 / _ctx.cols + "%" }),
              onClick: ($event) => _ctx.onClick(option)
            }, [
              option.value === _ctx.modelValue ? (openBlock(), createBlock(_component_nut_icon, {
                key: 0,
                name: "Check",
                color: _ctx.parent.props.activeColor
              }, null, 8, ["color"])) : createCommentVNode("", true),
              createElementVNode("view", {
                style: normalizeStyle({ color: option.value === _ctx.modelValue ? _ctx.parent.props.activeColor : "" })
              }, toDisplayString(option.text), 5)
            ], 14, _hoisted_2$v);
          }), 128)),
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["style", "overlayStyle", "visible", "duration", "overlay", "onClosed"])
  ], 2)), [
    [vShow, _ctx.state.showWrapper]
  ]);
}
var MenuItem = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$K]]);
const { create: create$O } = createComponent("tabbar");
const _sfc_main$O = create$O({
  props: {
    visible: {
      type: [Number, String],
      default: 0
    },
    bottom: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "base"
    },
    size: {
      type: String,
      default: "20px"
    },
    unactiveColor: {
      type: String,
      default: "#000000"
    },
    activeColor: {
      type: String,
      default: ""
    },
    safeAreaInsetBottom: {
      type: Boolean,
      default: false
    }
  },
  emits: ["tab-switch", "update:visible"],
  setup(props, { emit, slots }) {
    const mdValue = reactive({
      val: props.visible,
      children: []
    });
    function changeIndex(active) {
      emit("update:visible", active);
      parentData.modelValue = active;
      emit("tab-switch", parentData.children[active], active);
    }
    let parentData = reactive({
      children: mdValue.children,
      size: props.size,
      modelValue: mdValue.val,
      unactiveColor: props.unactiveColor,
      activeColor: props.activeColor,
      changeIndex
    });
    provide("parent", parentData);
    watch(() => props.visible, (value) => {
      parentData.modelValue = value;
    });
    return {
      changeIndex
    };
  }
});
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-tabbar", { "nut-tabbar-bottom": _ctx.bottom, "nut-tabbar-safebottom": _ctx.safeAreaInsetBottom }])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var Tabbar = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$J]]);
const { create: create$N } = createComponent("tabbar-item");
const _sfc_main$N = create$N({
  props: {
    tabTitle: {
      type: String,
      default: ""
    },
    icon: {
      type: String,
      default: ""
    },
    href: {
      type: String,
      default: ""
    },
    num: {
      type: String,
      default: ""
    },
    activeImg: {
      type: String,
      default: ""
    },
    img: {
      type: String,
      default: ""
    },
    classPrefix: {
      type: String,
      default: "nut-icon"
    },
    fontClassName: {
      type: String,
      default: "nutui-iconfont"
    },
    to: [Object, String]
  },
  setup(props, ctx) {
    const parent = inject("parent");
    const state = reactive({
      size: parent.size,
      unactiveColor: parent.unactiveColor,
      activeColor: parent.activeColor,
      active: parent.modelValue,
      index: 0
    });
    const router = useRouter();
    const relation = (child) => {
      if (child.proxy) {
        let index = parent.children.length;
        state.index = index;
        parent.children.push(child.proxy);
      }
    };
    relation(getCurrentInstance());
    function change(index) {
      parent.changeIndex(index);
    }
    const choosed = computed(() => {
      if (parent) {
        return parent.modelValue;
      }
      return null;
    });
    watch(choosed, (value, oldValue) => {
      state.active = value;
      setTimeout(() => {
        if (parent.children[value].href) {
          window.location.href = parent.children[value].href;
        }
        if (parent.children[value].to) {
          let to = parent.children[value].to;
          router.push(to);
        }
      });
    });
    return {
      state,
      change
    };
  }
});
const _hoisted_1$B = { class: "nut-tabbar-item_icon-box" };
const _hoisted_2$u = {
  key: 0,
  class: "nut-tabbar-item_icon-box_tips nut-tabbar-item_icon-box_num"
};
const _hoisted_3$o = {
  key: 1,
  class: "nut-tabbar-item_icon-box_tips nut-tabbar-item_icon-box_nums"
};
const _hoisted_4$i = { key: 2 };
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["nut-tabbar-item", { "nut-tabbar-item__icon--unactive": _ctx.state.active != _ctx.state.index }]),
    style: normalizeStyle({
      color: _ctx.state.active == _ctx.state.index ? _ctx.state.activeColor : _ctx.state.unactiveColor
    }),
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.change(_ctx.state.index))
  }, [
    createElementVNode("view", _hoisted_1$B, [
      _ctx.num && _ctx.num <= 99 ? (openBlock(), createElementBlock("view", _hoisted_2$u, toDisplayString(_ctx.num), 1)) : _ctx.num && _ctx.num > 100 ? (openBlock(), createElementBlock("view", _hoisted_3$o, toDisplayString("99+"))) : createCommentVNode("", true),
      _ctx.icon ? (openBlock(), createElementBlock("view", _hoisted_4$i, [
        createVNode(_component_nut_icon, {
          class: "nut-tabbar-item_icon-box_icon",
          size: _ctx.state.size,
          name: _ctx.icon,
          "font-class-name": _ctx.fontClassName,
          "class-prefix": _ctx.classPrefix
        }, null, 8, ["size", "name", "font-class-name", "class-prefix"])
      ])) : createCommentVNode("", true),
      !_ctx.icon && _ctx.activeImg ? (openBlock(), createElementBlock("div", {
        key: 3,
        class: "nut-tabbar-item_icon-box_icon",
        style: normalizeStyle({
          backgroundImage: `url(${_ctx.state.active == _ctx.state.index ? _ctx.activeImg : _ctx.img})`,
          width: _ctx.state.size,
          height: _ctx.state.size
        })
      }, null, 4)) : createCommentVNode("", true),
      createElementVNode("view", {
        class: normalizeClass(["nut-tabbar-item_icon-box_nav-word", { "nut-tabbar-item_icon-box_big-word": !_ctx.icon && !_ctx.activeImg }])
      }, toDisplayString(_ctx.tabTitle), 3)
    ])
  ], 6);
}
var TabbarItem = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$I]]);
const { componentName: componentName$z, create: create$M } = createComponent("elevator");
const _sfc_main$M = create$M({
  props: {
    height: {
      type: [Number, String],
      default: "200px"
    },
    acceptKey: {
      type: [String],
      default: "title"
    },
    indexList: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  emits: ["click-item", "click-index"],
  setup(props, context) {
    const spaceHeight = 23;
    const listview = ref(null);
    const state = reactive({
      anchorIndex: 0,
      listHeight: [],
      listGroup: [],
      touchState: {
        y1: 0,
        y2: 0
      },
      scrollStart: false,
      currentIndex: 0
    });
    const classes = computed(() => {
      const prefixCls = componentName$z;
      return {
        [prefixCls]: true
      };
    });
    const resetScrollState = () => {
      state.anchorIndex = 0;
      state.listHeight = [];
      state.listGroup = [];
      state.currentIndex = 0;
      state.scrollStart = false;
      state.touchState = {
        y1: 0,
        y2: 0
      };
    };
    const getData = (el, name) => {
      const prefix = "data-";
      return el.getAttribute(prefix + name);
    };
    const setListGroup = (el) => {
      nextTick(() => {
        if (!state.listGroup.includes(el) && el != null) {
          state.listGroup.push(el);
        }
      });
    };
    const calculateHeight = () => {
      let height = 0;
      state.listHeight.push(height);
      for (let i = 0; i < state.listGroup.length; i++) {
        let item = state.listGroup[i];
        height += item.clientHeight;
        state.listHeight.push(height);
      }
    };
    const scrollTo = (index) => {
      if (!index && index !== 0) {
        return;
      }
      if (!state.listHeight.length) {
        calculateHeight();
      }
      if (index < 0)
        index = 0;
      if (index > state.listHeight.length - 2)
        index = state.listHeight.length - 2;
      state.currentIndex = index;
      listview.value.scrollTo(0, state.listHeight[index]);
    };
    const touchStart = (e) => {
      state.scrollStart = true;
      let index = getData(e.target, "index");
      let firstTouch = e.touches[0];
      state.touchState.y1 = firstTouch.pageY;
      state.anchorIndex = +index;
      state.currentIndex = +index;
      console.log(state.currentIndex);
      scrollTo(+index);
    };
    const touchMove = (e) => {
      let firstTouch = e.touches[0];
      state.touchState.y2 = firstTouch.pageY;
      let delta = (state.touchState.y2 - state.touchState.y1) / spaceHeight | 0;
      state.currentIndex = state.anchorIndex + delta;
      scrollTo(state.currentIndex);
    };
    const touchEnd = () => {
      resetScrollState();
    };
    const handleClickItem = (key, item) => {
      context.emit("click-item", key, item);
    };
    const handleClickIndex = (key) => {
      context.emit("click-index", key);
    };
    return __spreadProps(__spreadValues({
      classes
    }, toRefs(state)), {
      setListGroup,
      listview,
      touchStart,
      touchMove,
      touchEnd,
      handleClickItem,
      handleClickIndex
    });
  }
});
const _hoisted_1$A = { class: "nut-elevator__list__item__code" };
const _hoisted_2$t = ["onClick", "innerHTML"];
const _hoisted_3$n = { class: "nut-elevator__bars__inner" };
const _hoisted_4$h = ["data-index", "onClick"];
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", {
      class: "nut-elevator__list",
      ref: "listview",
      style: normalizeStyle({ height: isNaN(+_ctx.height) ? _ctx.height : `${_ctx.height}px` })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.indexList, (item) => {
        return openBlock(), createElementBlock("view", {
          class: "nut-elevator__list__item",
          key: item[_ctx.acceptKey],
          ref_for: true,
          ref: _ctx.setListGroup
        }, [
          createElementVNode("view", _hoisted_1$A, toDisplayString(item[_ctx.acceptKey]), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(item.list, (subitem) => {
            return openBlock(), createElementBlock("view", {
              class: "nut-elevator__list__item__name",
              key: subitem["id"],
              onClick: ($event) => _ctx.handleClickItem(item[_ctx.acceptKey], subitem),
              innerHTML: subitem.name
            }, null, 8, _hoisted_2$t);
          }), 128))
        ]);
      }), 128))
    ], 4),
    _ctx.indexList.length ? withDirectives((openBlock(), createElementBlock("view", {
      key: 0,
      class: "nut-elevator__code--current"
    }, toDisplayString(_ctx.indexList[_ctx.currentIndex][_ctx.acceptKey]), 513)), [
      [vShow, _ctx.scrollStart]
    ]) : createCommentVNode("", true),
    createElementVNode("view", {
      class: "nut-elevator__bars",
      onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.touchStart && _ctx.touchStart(...args)),
      onTouchmove: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.touchMove && _ctx.touchMove(...args), ["stop", "prevent"])),
      onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.touchEnd && _ctx.touchEnd(...args))
    }, [
      createElementVNode("view", _hoisted_3$n, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.indexList, (item, index) => {
          return openBlock(), createElementBlock("view", {
            class: "nut-elevator__bars__inner__item",
            "data-index": index,
            key: item[_ctx.acceptKey],
            onClick: ($event) => _ctx.handleClickIndex(item[_ctx.acceptKey])
          }, toDisplayString(item[_ctx.acceptKey]), 9, _hoisted_4$h);
        }), 128))
      ])
    ], 32)
  ], 2);
}
var Elevator = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$H]]);
const { componentName: componentName$y, create: create$L } = createComponent("pagination");
const _sfc_main$L = create$L({
  props: {
    modelValue: {
      type: Number,
      default: 1
    },
    mode: {
      type: String,
      default: "multi"
    },
    prevText: {
      type: String,
      default: "\u4E0A\u4E00\u9875"
    },
    nextText: {
      type: String,
      default: "\u4E0B\u4E00\u9875"
    },
    pageCount: {
      type: [String, Number],
      default: ""
    },
    totalItems: {
      type: [String, Number],
      default: "0"
    },
    itemsPerPage: {
      type: [String, Number],
      default: "10"
    },
    showPageSize: {
      type: [String, Number],
      default: "5"
    },
    forceEllipses: {
      type: Boolean,
      default: false
    }
  },
  components: {},
  emits: ["change", "update:modelValue"],
  setup(props, { emit }) {
    const { modelValue, mode, showPageSize, forceEllipses } = toRefs(props);
    const countRef = computed(() => {
      const { pageCount, totalItems, itemsPerPage } = toRefs(props);
      const num = +pageCount.value || Math.ceil(+totalItems.value / +itemsPerPage.value);
      return Math.max(1, num);
    });
    const select = (curPage, isSelect) => {
      if (curPage > countRef.value || curPage < 1)
        return;
      if (curPage != modelValue.value)
        emit("update:modelValue", curPage);
      if (isSelect)
        emit("change", curPage);
    };
    const setPage = (number, text, active) => {
      return { number, text, active };
    };
    const pages = computed(() => {
      if (mode.value == "simple")
        return;
      let items = [];
      const pageCount = countRef.value;
      const pageSize = showPageSize.value;
      let startPage = 1;
      let endPage = pageCount;
      const partialShow = pageCount > pageSize;
      if (partialShow) {
        startPage = Math.max(modelValue.value - Math.floor(pageSize / 2), 1);
        endPage = startPage + pageSize - 1;
        if (endPage > pageCount) {
          endPage = pageCount;
          startPage = endPage - pageSize + 1;
        }
      }
      for (var i = startPage; i <= endPage; i++) {
        const page = setPage(i, i, modelValue.value == i);
        items.push(page);
      }
      if (partialShow && pageSize > 0 && forceEllipses.value) {
        if (startPage > 1) {
          const prevPage = setPage(startPage - 1, "...");
          items.unshift(prevPage);
        }
        if (endPage < pageCount) {
          const nextPage = setPage(endPage + 1, "...");
          items.push(nextPage);
        }
      }
      return items;
    });
    watchEffect(() => {
      select(modelValue.value, false);
    });
    return {
      modelValue,
      select,
      countRef,
      mode,
      pages,
      forceEllipses
    };
  }
});
const _hoisted_1$z = { class: "nut-pagination" };
const _hoisted_2$s = {
  key: 0,
  class: "nut-pagination-contain"
};
const _hoisted_3$m = ["onClick"];
const _hoisted_4$g = {
  key: 1,
  class: "nut-pagination-contain"
};
const _hoisted_5$b = { class: "nut-pagination-simple" };
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$z, [
    createElementVNode("view", {
      class: normalizeClass(["nut-pagination-prev", _ctx.mode == "multi" ? "" : "simple-border", _ctx.modelValue == 1 ? "disabled" : ""]),
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.select(_ctx.modelValue - 1, true))
    }, [
      renderSlot(_ctx.$slots, "prev-text", {}, () => [
        createTextVNode(toDisplayString(_ctx.prevText), 1)
      ])
    ], 2),
    _ctx.mode == "multi" ? (openBlock(), createElementBlock("view", _hoisted_2$s, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pages, (item, index) => {
        return openBlock(), createElementBlock("view", {
          key: index + "pagination",
          class: normalizeClass(["nut-pagination-item", item.active ? "active" : ""]),
          onClick: ($event) => _ctx.select(item.number, true)
        }, [
          renderSlot(_ctx.$slots, "page", { item }, () => [
            createTextVNode(toDisplayString(item.text), 1)
          ])
        ], 10, _hoisted_3$m);
      }), 128))
    ])) : createCommentVNode("", true),
    _ctx.mode == "simple" ? (openBlock(), createElementBlock("view", _hoisted_4$g, [
      createElementVNode("view", _hoisted_5$b, toDisplayString(_ctx.modelValue) + "/" + toDisplayString(_ctx.countRef), 1)
    ])) : createCommentVNode("", true),
    createElementVNode("view", {
      class: normalizeClass(["nut-pagination-next", _ctx.modelValue >= _ctx.countRef ? "disabled" : ""]),
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.select(_ctx.modelValue + 1, true))
    }, [
      renderSlot(_ctx.$slots, "next-text", {}, () => [
        createTextVNode(toDisplayString(_ctx.nextText), 1)
      ])
    ], 2)
  ]);
}
var Pagination = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$G]]);
const { create: create$K } = createComponent("tabs");
class Title {
  constructor() {
    __publicField(this, "title", "");
    __publicField(this, "titleSlot");
    __publicField(this, "paneKey", "");
    __publicField(this, "disabled", false);
  }
}
const _sfc_main$K = create$K({
  props: {
    modelValue: {
      type: [String, Number],
      default: 0
    },
    color: {
      type: String,
      default: ""
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: String,
      default: "normal"
    },
    type: {
      type: String,
      default: "line"
    },
    titleScroll: {
      type: Boolean,
      default: false
    },
    ellipsis: {
      type: Boolean,
      default: true
    },
    background: {
      type: String,
      default: ""
    },
    animatedTime: {
      type: [Number, String],
      default: 300
    },
    titleGutter: {
      type: [Number, String],
      default: 0
    }
  },
  components: {},
  emits: ["update:modelValue", "click", "change"],
  setup(props, { emit, slots }) {
    provide("activeKey", { activeKey: computed(() => props.modelValue) });
    const titles = ref([]);
    const currentIndex = ref(props.modelValue || 0);
    const renderTitles = (vnodes) => {
      vnodes.forEach((vnode, index) => {
        var _a, _b, _c, _d, _e;
        let type = vnode.type;
        type = type.name || type;
        if (type == "nut-tabpane") {
          let title = new Title();
          if (((_a = vnode.props) == null ? void 0 : _a.title) || ((_b = vnode.props) == null ? void 0 : _b["pane-key"])) {
            title.title = (_c = vnode.props) == null ? void 0 : _c.title;
            title.paneKey = ((_d = vnode.props) == null ? void 0 : _d["pane-key"]) || index;
            title.disabled = (_e = vnode.props) == null ? void 0 : _e.disabled;
          }
          titles.value.push(title);
        } else {
          renderTitles(vnode.children);
        }
      });
    };
    const init = (vnodes = slots.default()) => {
      titles.value = [];
      if (vnodes.length) {
        renderTitles(vnodes);
      }
    };
    watch(() => slots.default(), (vnodes) => {
      init(vnodes);
    });
    watch(() => props.modelValue, (value) => {
      let index = titles.value.findIndex((item) => item.paneKey == value);
      if (index == -1) {
        console.error("[NutUI] <Tabs> \u8BF7\u68C0\u67E5 v-model \u503C\u662F\u5426\u4E3A paneKey ,\u5982 paneKey \u672A\u8BBE\u7F6E\uFF0C\u8BF7\u91C7\u7528\u4E0B\u6807\u63A7\u5236 .");
      } else {
        currentIndex.value = index;
      }
    });
    onMounted(init);
    onActivated(init);
    const contentStyle = computed(() => {
      return {
        transform: props.direction == "horizontal" ? `translate3d(-${currentIndex.value * 100}%, 0, 0)` : `translate3d( 0,-${currentIndex.value * 100}%, 0)`,
        transitionDuration: `${props.animatedTime}ms`
      };
    });
    const tabsNavStyle = computed(() => {
      return {
        background: props.background
      };
    });
    const tabsActiveStyle = computed(() => {
      return {
        color: props.type == "smile" ? props.color : "",
        background: props.type == "line" ? props.color : ""
      };
    });
    const titleStyle = computed(() => {
      return {
        marginLeft: pxCheck(props.titleGutter),
        marginRight: pxCheck(props.titleGutter)
      };
    });
    const methods = {
      tabChange: (item, index) => {
        emit("click", item);
        if (item.disabled) {
          return;
        }
        currentIndex.value = index;
        emit("update:modelValue", item.paneKey);
        emit("change", item);
      }
    };
    return __spreadValues({
      titles,
      contentStyle,
      tabsNavStyle,
      tabsActiveStyle,
      titleStyle
    }, methods);
  }
});
const _hoisted_1$y = ["onClick"];
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-tabs", [_ctx.direction]])
  }, [
    createElementVNode("view", {
      class: normalizeClass(["nut-tabs__titles", { [_ctx.type]: _ctx.type, scrollable: _ctx.titleScroll, [_ctx.size]: _ctx.size }]),
      style: normalizeStyle(_ctx.tabsNavStyle)
    }, [
      _ctx.$slots.titles ? renderSlot(_ctx.$slots, "titles", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.titles, (item, index) => {
        return openBlock(), createElementBlock("view", {
          class: normalizeClass(["nut-tabs__titles-item", { active: item.paneKey == _ctx.modelValue, disabled: item.disabled }]),
          style: normalizeStyle(_ctx.titleStyle),
          onClick: ($event) => _ctx.tabChange(item, index),
          key: item.paneKey
        }, [
          _ctx.type == "line" ? (openBlock(), createElementBlock("view", {
            key: 0,
            class: "nut-tabs__titles-item__line",
            style: normalizeStyle(_ctx.tabsActiveStyle)
          }, null, 4)) : createCommentVNode("", true),
          _ctx.type == "smile" ? (openBlock(), createElementBlock("view", {
            key: 1,
            class: "nut-tabs__titles-item__smile",
            style: normalizeStyle(_ctx.tabsActiveStyle)
          }, [
            createVNode(_component_nut_icon, {
              color: _ctx.color,
              name: "joy-smile"
            }, null, 8, ["color"])
          ], 4)) : createCommentVNode("", true),
          createElementVNode("view", {
            class: normalizeClass(["nut-tabs__titles-item__text", { ellipsis: _ctx.ellipsis && !_ctx.titleScroll && _ctx.direction == "horizontal" }])
          }, toDisplayString(item.title), 3)
        ], 14, _hoisted_1$y);
      }), 128))
    ], 6),
    createElementVNode("view", {
      class: "nut-tabs__content",
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 2);
}
var Tabs = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$F]]);
const { create: create$J } = createComponent("tabpane");
const _sfc_main$J = create$J({
  props: {
    title: {
      type: [String, Number],
      default: ""
    },
    paneKey: {
      type: [String, Number],
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const parent = inject("activeKey");
    return { activeKey: parent.activeKey };
  }
});
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-tabpane", { active: _ctx.paneKey == _ctx.activeKey }])
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var TabPane = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$E]]);
const { componentName: componentName$x, create: create$I } = createComponent("indicator");
const _sfc_main$I = create$I({
  props: {
    size: {
      type: Number,
      default: 3,
      required: true
    },
    current: {
      type: Number,
      default: 1,
      required: true
    },
    block: {
      type: Boolean,
      default: false
    },
    align: {
      type: String,
      default: "center"
    },
    fillZero: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const { block, align } = toRefs(props);
    const classes = computed(() => {
      const prefixCls = componentName$x;
      return {
        [prefixCls]: true,
        [`${prefixCls}--block`]: block.value,
        [`${prefixCls}--align__${align.value}`]: block.value && align.value
      };
    });
    return { classes, componentName: componentName$x };
  }
});
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.size, (item) => {
      return openBlock(), createElementBlock(Fragment, { key: item }, [
        item === _ctx.current ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: normalizeClass(`${_ctx.componentName}--number`)
        }, toDisplayString(_ctx.fillZero && item < 10 ? `0${item}` : item), 3)) : (openBlock(), createElementBlock("view", {
          key: 1,
          class: normalizeClass(`${_ctx.componentName}--dot`)
        }, null, 2))
      ], 64);
    }), 128))
  ], 2);
}
var Indicator = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$D]]);
function flattenVNodes(children, childName) {
  const result = [];
  const traverse = (children2) => {
    if (!Array.isArray(children2))
      return;
    children2.forEach((child) => {
      var _a;
      if (!isVNode(child))
        return;
      if (childName) {
        if (child.type && child.type.name === childName) {
          result.push(child);
          return;
        }
      } else {
        result.push(child);
      }
      if ((_a = child.component) == null ? void 0 : _a.subTree) {
        traverse(child.component.subTree.children);
      }
      if (child.children) {
        traverse(child.children);
      }
    });
  };
  traverse(children);
  return result;
}
function sortChildren(parent, internalChildren, childName) {
  const vnodes = flattenVNodes(parent.subTree.children, childName);
  internalChildren.sort((a, b) => {
    return vnodes.indexOf(a.vnode) - vnodes.indexOf(b.vnode);
  });
}
function useProvide(key, childName) {
  const internalChildren = shallowReactive([]);
  const parent = getCurrentInstance();
  const add = (child) => {
    if (!child.proxy)
      return;
    internalChildren.push(markRaw(child));
    sortChildren(parent, internalChildren, childName);
  };
  const remove = (child) => {
    internalChildren.splice(internalChildren.indexOf(markRaw(child)), 1);
  };
  const extend = Object.assign;
  return (value) => {
    provide(key, extend({
      add,
      remove,
      internalChildren
    }, value));
    return {
      internalChildren
    };
  };
}
const { componentName: componentName$w } = createComponent("grid");
const GRID_KEY = Symbol("grid");
const gridProps = {
  columnNum: {
    type: [Number, String],
    default: 4
  },
  iconSize: {
    type: [Number, String],
    default: 28
  },
  iconColor: {
    type: String
  },
  border: {
    type: Boolean,
    default: true
  },
  gutter: {
    type: [Number, String],
    default: 0
  },
  center: {
    type: Boolean,
    default: true
  },
  square: {
    type: Boolean,
    default: false
  },
  reverse: {
    type: Boolean,
    default: false
  },
  direction: {
    type: String
  },
  clickable: {
    type: Boolean,
    default: false
  }
};
const component$3 = {
  props: gridProps,
  setup(props, { slots }) {
    useProvide(GRID_KEY, `${componentName$w}-item`)({ props });
    const rootClass = computed(() => {
      const prefixCls = componentName$w;
      return {
        [prefixCls]: true,
        [`${prefixCls}--border`]: props.border && !props.gutter
      };
    });
    const rootStyle = computed(() => {
      const style = {};
      if (props.gutter) {
        style.paddingLeft = pxCheck(props.gutter);
      }
      return style;
    });
    return () => {
      var _a;
      return h("view", {
        class: rootClass.value,
        style: rootStyle.value
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
};
const { create: create$H } = createComponent("grid");
const _sfc_main$H = create$H(component$3);
function useInject(key) {
  const parent = inject(key, null);
  if (parent) {
    const instance = getCurrentInstance();
    const { add, remove, internalChildren } = parent;
    add(instance);
    onUnmounted(() => remove(instance));
    const index = computed(() => internalChildren.indexOf(instance));
    return {
      parent,
      index
    };
  }
  return {
    parent: null,
    index: ref(-1)
  };
}
const { create: create$G, componentName: componentName$v } = createComponent("grid-item");
const _sfc_main$G = create$G({
  props: {
    text: {
      type: String
    },
    icon: {
      type: String
    },
    iconSize: {
      type: [Number, String]
    },
    iconColor: {
      type: String
    },
    to: {
      type: [String, Object]
    },
    url: {
      type: String,
      default: ""
    },
    replace: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const Parent = useInject(GRID_KEY);
    if (!Parent.parent)
      return;
    const index = Parent.index;
    const parent = Parent.parent.props;
    const rootClass = computed(() => {
      const prefixCls = componentName$v;
      return {
        [prefixCls]: true
      };
    });
    const rootStyle = computed(() => {
      const style = {
        flexBasis: `${100 / +parent.columnNum}%`
      };
      if (parent.square) {
        style.paddingTop = `${100 / +parent.columnNum}%`;
      } else if (parent.gutter) {
        style.paddingRight = pxCheck(parent.gutter);
        if (index.value >= parent.columnNum) {
          style.marginTop = pxCheck(parent.gutter);
        }
      }
      return style;
    });
    const contentClass = computed(() => {
      const prefixCls = `${componentName$v}__content`;
      return {
        [`${prefixCls}`]: true,
        [`${prefixCls}--border`]: parent.border,
        [`${prefixCls}--surround`]: parent.border && parent.gutter,
        [`${prefixCls}--center`]: parent.center,
        [`${prefixCls}--square`]: parent.square,
        [`${prefixCls}--reverse`]: parent.reverse,
        [`${prefixCls}--${parent.direction}`]: !!parent.direction,
        [`${prefixCls}--clickable`]: parent.clickable || props.to || props.url
      };
    });
    const iconProps = computed(() => {
      return {
        name: props.icon,
        size: props.iconSize || parent.iconSize,
        color: props.iconColor || parent.iconColor
      };
    });
    const router = useRouter();
    const handleClick = (event) => {
      emit("click", event);
      if (props.to && router) {
        router[props.replace ? "replace" : "push"](props.to);
      } else if (props.url) {
        props.replace ? location.replace(props.url) : location.href = props.url;
      }
    };
    return {
      rootClass,
      rootStyle,
      contentClass,
      iconProps,
      handleClick
    };
  }
});
const _hoisted_1$x = {
  key: 3,
  class: "nut-grid-item__text"
};
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.rootClass),
    style: normalizeStyle(_ctx.rootStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createElementVNode("view", {
      class: normalizeClass(_ctx.contentClass)
    }, [
      _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 0 }) : (openBlock(), createBlock(_component_nut_icon, {
          key: 1,
          name: _ctx.iconProps.name,
          size: _ctx.iconProps.size,
          color: _ctx.iconProps.color
        }, null, 8, ["name", "size", "color"])),
        _ctx.$slots.text ? renderSlot(_ctx.$slots, "text", { key: 2 }) : (openBlock(), createElementBlock("view", _hoisted_1$x, toDisplayString(_ctx.text), 1))
      ], 64))
    ], 2)
  ], 6);
}
var GridItem = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$C]]);
const { componentName: componentName$u, create: create$F } = createComponent("sidenavbar");
const _sfc_main$F = create$F({
  props: {
    offset: {
      type: [String, Number],
      default: 15
    }
  },
  emits: [],
  setup: (props, context) => {
    const list = ref(null);
    const state = reactive({
      count: 1,
      observer: null
    });
    const classes = computed(() => {
      const prefixCls = componentName$u;
      return {
        [prefixCls]: true
      };
    });
    const setPaddingLeft = (nodeList, level = 1) => {
      for (let i = 0; i < nodeList.length; i++) {
        let item = nodeList[i];
        item.children[0].style.paddingLeft = props.offset * level + "px";
        if (!item.className.includes("nut-sidenavbaritem")) {
          setPaddingLeft(Array.from(item.children[1].children), ++state.count);
        }
      }
      state.count--;
    };
    const handleSlots = () => {
      let childNodes = list.value.childNodes;
      if (childNodes.length) {
        childNodes = Array.from(childNodes).filter((item) => item.nodeType !== 3).map((item) => {
          return item;
        });
        setPaddingLeft(childNodes);
      }
    };
    onMounted(() => {
      handleSlots();
      state.observer = new MutationObserver(function() {
        state.count = 1;
        handleSlots();
      });
      state.observer.observe(list.value, {
        attributes: false,
        childList: true,
        characterData: false,
        subtree: false
      });
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      list,
      classes
    });
  }
});
const _hoisted_1$w = { class: "nut-sidenavbar__content" };
const _hoisted_2$r = {
  class: "nut-sidenavbar__content__list",
  ref: "list"
};
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", _hoisted_1$w, [
      createElementVNode("view", _hoisted_2$r, [
        renderSlot(_ctx.$slots, "default")
      ], 512)
    ])
  ], 2);
}
var SideNavBar = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$B]]);
const { componentName: componentName$t, create: create$E } = createComponent("sidenavbaritem");
const _sfc_main$E = create$E({
  props: {
    title: {
      type: String,
      default: ""
    },
    ikey: {
      type: String,
      default: ""
    }
  },
  emits: ["click"],
  setup: (props, context) => {
    const classes = computed(() => {
      const prefixCls = componentName$t;
      return {
        [prefixCls]: true
      };
    });
    const handleClick = () => {
      context.emit("click");
    };
    return {
      classes,
      handleClick
    };
  }
});
const _hoisted_1$v = ["ikey"];
const _hoisted_2$q = { class: "nut-sidenavbaritem__title" };
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: "nut-sidenavbaritem",
    onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"])),
    ikey: _ctx.ikey
  }, [
    createElementVNode("span", _hoisted_2$q, toDisplayString(_ctx.title), 1)
  ], 8, _hoisted_1$v);
}
var SideNavBarItem = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$A]]);
const { componentName: componentName$s, create: create$D } = createComponent("subsidenavbar");
const _sfc_main$D = create$D({
  props: {
    title: {
      type: String,
      default: ""
    },
    ikey: {
      type: [String, Number],
      default: ""
    },
    open: {
      type: Boolean,
      default: true
    }
  },
  emits: ["title-click"],
  setup: (props, context) => {
    const state = reactive({
      direction: ""
    });
    const classes = computed(() => {
      const prefixCls = componentName$s;
      return {
        [prefixCls]: true
      };
    });
    const style = computed(() => {
      return {
        height: !state.direction ? "auto" : "0px"
      };
    });
    const handleClick = () => {
      context.emit("title-click");
      state.direction = !state.direction ? "up" : "";
    };
    onMounted(() => {
      state.direction = props.open ? "" : "up";
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      classes,
      style,
      handleClick
    });
  }
});
const _hoisted_1$u = ["ikey"];
const _hoisted_2$p = { class: "nut-subsidenavbar__title__text" };
const _hoisted_3$l = { class: "nut-subsidenavbar__title__icon" };
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    ikey: _ctx.ikey
  }, [
    createElementVNode("view", {
      class: "nut-subsidenavbar__title",
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"]))
    }, [
      createElementVNode("span", _hoisted_2$p, toDisplayString(_ctx.title), 1),
      createElementVNode("span", _hoisted_3$l, [
        createVNode(_component_nut_icon, {
          name: "down-arrow",
          class: normalizeClass(_ctx.direction)
        }, null, 8, ["class"])
      ])
    ]),
    createElementVNode("view", {
      class: normalizeClass(["nut-subsidenavbar__list", !_ctx.direction ? "nutFadeIn" : "nutFadeOut"]),
      style: normalizeStyle(_ctx.style)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)
  ], 10, _hoisted_1$u);
}
var SubSideNavBar = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$z]]);
const Utils = {
  isLeapYear: function(y) {
    return y % 4 == 0 && y % 100 != 0 || y % 400 == 0;
  },
  getWhatDay: function(year, month, day) {
    const date = new Date(year + "/" + month + "/" + day);
    const index = date.getDay();
    const dayNames = [
      "\u661F\u671F\u65E5",
      "\u661F\u671F\u4E00",
      "\u661F\u671F\u4E8C",
      "\u661F\u671F\u4E09",
      "\u661F\u671F\u56DB",
      "\u661F\u671F\u4E94",
      "\u661F\u671F\u516D"
    ];
    return dayNames[index];
  },
  getMonthPreDay: function(year, month) {
    const date = new Date(year + "/" + month + "/01");
    let day = date.getDay();
    if (day == 0) {
      day = 7;
    }
    return day;
  },
  getMonthDays: function(year, month) {
    if (/^0/.test(month)) {
      month = month.split("")[1];
    }
    return [
      0,
      31,
      this.isLeapYear(Number(year)) ? 29 : 28,
      31,
      30,
      31,
      30,
      31,
      31,
      30,
      31,
      30,
      31
    ][month];
  },
  getNumTwoBit: function(n) {
    n = Number(n);
    return (n > 9 ? "" : "0") + n;
  },
  date2Str: function(date, split) {
    split = split || "-";
    const y = date.getFullYear();
    const m = this.getNumTwoBit(date.getMonth() + 1);
    const d = this.getNumTwoBit(date.getDate());
    return [y, m, d].join(split);
  },
  getDay: function(i) {
    i = i || 0;
    let date = new Date();
    const diff = i * (1e3 * 60 * 60 * 24);
    date = new Date(date.getTime() + diff);
    return this.date2Str(date);
  },
  compareDate: function(date1, date2) {
    const startTime = new Date(date1.replace("-", "/").replace("-", "/"));
    const endTime = new Date(date2.replace("-", "/").replace("-", "/"));
    if (startTime >= endTime) {
      return false;
    }
    return true;
  },
  isEqual: function(date1, date2) {
    const startTime = new Date(date1).getTime();
    const endTime = new Date(date2).getTime();
    if (startTime == endTime) {
      return true;
    }
    return false;
  }
};
const { create: create$C } = createComponent("calendar-item");
const _sfc_main$C = create$C({
  props: {
    type: {
      type: String,
      default: "one"
    },
    isAutoBackFill: {
      type: Boolean,
      default: false
    },
    poppable: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: "\u65E5\u5386\u9009\u62E9"
    },
    defaultValue: {
      type: String,
      default: null
    },
    startDate: {
      type: String,
      default: Utils.getDay(0)
    },
    endDate: {
      type: String,
      default: Utils.getDay(365)
    }
  },
  emits: ["choose", "update", "close"],
  setup(props, { emit }) {
    const weeks = ref(["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"]);
    const months = ref(null);
    const monthsPanel = ref(null);
    const weeksPanel = ref(null);
    const state = reactive({
      yearMonthTitle: "",
      currDate: "",
      unLoadPrev: false,
      touchParams: {
        startY: 0,
        endY: 0,
        startTime: 0,
        endTime: 0,
        lastY: 0,
        lastTime: 0
      },
      transformY: 0,
      translateY: 0,
      scrollDistance: 0,
      defaultData: [],
      chooseData: [],
      monthsData: [],
      dayPrefix: "calendar-month-day",
      startData: "",
      endData: "",
      isRange: props.type === "range",
      timer: 0
    });
    const splitDate = (date) => {
      return date.split("-");
    };
    const isStart = (currDate) => {
      return Utils.isEqual(state.currDate[0], currDate);
    };
    const isEnd = (currDate) => {
      return Utils.isEqual(state.currDate[1], currDate);
    };
    const getCurrDate = (day, month, isRange) => {
      return isRange ? month.curData[3] + "-" + month.curData[4] + "-" + Utils.getNumTwoBit(+day.day) : month.curData[0] + "-" + month.curData[1] + "-" + Utils.getNumTwoBit(+day.day);
    };
    const getClass = (day, month, isRange) => {
      const currDate = getCurrDate(day, month, isRange);
      if (day.type == "curr") {
        if (!state.isRange && Utils.isEqual(state.currDate, currDate) || state.isRange && (isStart(currDate) || isEnd(currDate))) {
          return `${state.dayPrefix}-active`;
        } else if (props.startDate && Utils.compareDate(currDate, props.startDate) || props.endDate && Utils.compareDate(props.endDate, currDate)) {
          return `${state.dayPrefix}-disabled`;
        } else if (state.isRange && Array.isArray(state.currDate) && Object.values(state.currDate).length == 2 && Utils.compareDate(state.currDate[0], currDate) && Utils.compareDate(currDate, state.currDate[1])) {
          return `${state.dayPrefix}-choose`;
        } else {
          return null;
        }
      } else {
        return `${state.dayPrefix}-disabled`;
      }
    };
    const confirm = () => {
      if (state.isRange && state.chooseData.length == 2 || !state.isRange) {
        emit("choose", state.chooseData);
        if (props.poppable) {
          emit("update");
        }
      }
    };
    const chooseDay = (day, month, isFirst, isRange) => {
      if (getClass(day, month, isRange) != `${state.dayPrefix}-disabled`) {
        let days = [...month.curData];
        days = isRange ? days.splice(3) : days.splice(0, 3);
        days[2] = typeof day.day == "number" ? Utils.getNumTwoBit(day.day) : day.day;
        days[3] = `${days[0]}-${days[1]}-${days[2]}`;
        days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
        if (!state.isRange) {
          state.currDate = days[3];
          state.chooseData = [...days];
        } else {
          if (Object.values(state.currDate).length == 2) {
            state.currDate = [days[3]];
          } else {
            if (Utils.compareDate(state.currDate[0], days[3])) {
              Array.isArray(state.currDate) && state.currDate.push(days[3]);
            } else {
              Array.isArray(state.currDate) && state.currDate.unshift(days[3]);
            }
          }
          if (state.chooseData.length == 2 || !state.chooseData.length) {
            state.chooseData = [...days];
          } else {
            if (Utils.compareDate(state.chooseData[3], days[3])) {
              state.chooseData = [[...state.chooseData], [...days]];
            } else {
              state.chooseData = [[...days], [...state.chooseData]];
            }
          }
        }
        if (props.isAutoBackFill && !isFirst) {
          confirm();
        }
      }
    };
    const getCurrData = (type) => {
      const monthData = type == "prev" ? state.monthsData[0] : state.monthsData[state.monthsData.length - 1];
      let year = parseInt(monthData.curData[0]);
      let month = parseInt(monthData.curData[1].toString().replace(/^0/, ""));
      switch (type) {
        case "prev":
          month == 1 && (year -= 1);
          month = month == 1 ? 12 : --month;
          break;
        case "next":
          month == 12 && (year += 1);
          month = month == 12 ? 1 : ++month;
          break;
      }
      return [
        year,
        Utils.getNumTwoBit(month),
        Utils.getMonthDays(String(year), String(month))
      ];
    };
    const getDaysStatus = (days, type) => {
      if (type == "prev" && days >= 7) {
        days -= 7;
      }
      return Array.from(Array(days), (v, k) => {
        return {
          day: k + 1,
          type
        };
      });
    };
    const getMonth = (curData, type) => {
      const preMonthDays = Utils.getMonthPreDay(+curData[0], +curData[1]);
      const currMonthDays = Utils.getMonthDays(curData[0], curData[1]);
      const title = {
        year: curData[0],
        month: curData[1]
      };
      const monthInfo = {
        curData,
        title: `${title.year}\u5E74${title.month}\u6708`,
        monthData: [
          ...getDaysStatus(preMonthDays, "prev"),
          ...getDaysStatus(currMonthDays, "curr")
        ]
      };
      if (type == "next") {
        if (!state.endData || !Utils.compareDate(`${state.endData[0]}-${state.endData[1]}-${Utils.getMonthDays(state.endData[0], state.endData[1])}`, `${curData[0]}-${curData[1]}-${curData[2]}`)) {
          state.monthsData.push(monthInfo);
        }
      } else {
        if (!state.startData || !Utils.compareDate(`${curData[0]}-${curData[1]}-${curData[2]}`, `${state.startData[0]}-${state.startData[1]}-01`)) {
          state.monthsData.unshift(monthInfo);
        } else {
          state.unLoadPrev = true;
        }
      }
    };
    const initData = () => {
      state.startData = props.startDate ? splitDate(props.startDate) : "";
      state.endData = props.endDate ? splitDate(props.endDate) : "";
      if (!props.defaultValue) {
        state.currDate = state.isRange ? [Utils.date2Str(new Date()), Utils.getDay(1)] : Utils.date2Str(new Date());
      } else {
        state.currDate = state.isRange ? [...props.defaultValue] : props.defaultValue;
      }
      if (state.isRange && Array.isArray(state.currDate)) {
        if (props.startDate && Utils.compareDate(state.currDate[0], props.startDate)) {
          state.currDate.splice(0, 1, props.startDate);
        }
        if (props.endDate && Utils.compareDate(props.endDate, state.currDate[1])) {
          state.currDate.splice(1, 1, props.endDate);
        }
        state.defaultData = [
          ...splitDate(state.currDate[0]),
          ...splitDate(state.currDate[1])
        ];
      } else {
        if (props.startDate && Utils.compareDate(state.currDate, props.startDate)) {
          state.currDate = props.startDate;
        } else if (props.endDate && !Utils.compareDate(state.currDate, props.endDate)) {
          state.currDate = props.endDate;
        }
        state.defaultData = [...splitDate(state.currDate)];
      }
      getMonth(state.defaultData, "next");
      state.yearMonthTitle = state.monthsData[0].title;
      let i = 1;
      do {
        getMonth(getCurrData("next"), "next");
      } while (i++ < 4);
      if (state.isRange) {
        chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[0], true);
        chooseDay({ day: state.defaultData[5], type: "curr" }, state.monthsData[0], true, true);
      } else {
        chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[0], true);
      }
    };
    const isActive = (day, month) => {
      return state.isRange && day.type == "curr" && getClass(day, month) == "calendar-month-day-active";
    };
    const isStartTip = (day, month) => {
      if (isActive(day, month)) {
        return isStart(getCurrDate(day, month));
      } else {
        return false;
      }
    };
    const isEndTip = (day, month) => {
      return isActive(day, month);
    };
    const isCurrDay = (month, day) => {
      const date = `${month.curData[0]}-${month.curData[1]}-${day}`;
      return Utils.isEqual(date, Utils.date2Str(new Date()));
    };
    const loadScroll = () => {
      if (!props.poppable) {
        return false;
      }
      requestAniFrame$1(() => {
        if ((weeksPanel == null ? void 0 : weeksPanel.value) && (monthsPanel == null ? void 0 : monthsPanel.value)) {
          const top = weeksPanel == null ? void 0 : weeksPanel.value.getBoundingClientRect().bottom;
          const monthsDoms = monthsPanel.value.getElementsByClassName("calendar-month");
          for (let i = 0; i < monthsDoms.length; i++) {
            if (monthsDoms[i].getBoundingClientRect().top <= top && monthsDoms[i].getBoundingClientRect().bottom >= top) {
              state.yearMonthTitle = state.monthsData[i].title;
            } else if (state.scrollDistance === 0) {
              state.yearMonthTitle = state.monthsData[0].title;
            }
          }
        }
      });
    };
    const setTransform = (translateY = 0, type, time = 1e3) => {
      if (monthsPanel == null ? void 0 : monthsPanel.value) {
        if (type === "end") {
          monthsPanel.value.style.webkitTransition = `transform ${time}ms cubic-bezier(0.19, 1, 0.22, 1)`;
          clearTimeout(state.timer);
          state.timer = setTimeout(() => {
            loadScroll();
          }, time);
        } else {
          monthsPanel.value.style.webkitTransition = "";
          loadScroll();
        }
        monthsPanel.value.style.webkitTransform = `translateY(${translateY}px)`;
        state.scrollDistance = translateY;
      }
    };
    const setMove = (move, type, time) => {
      var _a, _b;
      let updateMove = move + state.transformY;
      const h2 = ((_a = months.value) == null ? void 0 : _a.offsetHeight) || 0;
      const offsetHeight = ((_b = monthsPanel.value) == null ? void 0 : _b.offsetHeight) || 0;
      if (type === "end") {
        if (updateMove > 0) {
          updateMove = 0;
        }
        if (updateMove < 0 && updateMove < -offsetHeight + h2) {
          updateMove = -offsetHeight + h2;
        }
        if (offsetHeight <= h2 && state.monthsData.length == 1) {
          updateMove = 0;
        }
        setTransform(updateMove, type, time);
      } else {
        if (updateMove > 0 && updateMove > 100) {
          updateMove = 100;
        }
        if (updateMove < -offsetHeight + h2 - 100 && state.monthsData.length > 1) {
          updateMove = -offsetHeight + h2 - 100;
        }
        if (updateMove < 0 && updateMove < -100 && state.monthsData.length == 1) {
          updateMove = -100;
        }
        setTransform(updateMove);
      }
    };
    const touchStart = (event) => {
      const changedTouches = event.changedTouches[0];
      state.touchParams.startY = changedTouches.pageY;
      state.touchParams.startTime = event.timeStamp || Date.now();
      state.transformY = state.scrollDistance;
    };
    const touchMove = (event) => {
      const changedTouches = event.changedTouches[0];
      state.touchParams.lastY = changedTouches.pageY;
      state.touchParams.lastTime = event.timeStamp || Date.now();
      const move = state.touchParams.lastY - state.touchParams.startY;
      if (Math.abs(move) < 5) {
        return false;
      }
      setMove(move);
    };
    const touchEnd = (event) => {
      var _a, _b;
      const changedTouches = event.changedTouches[0];
      state.touchParams.lastY = changedTouches.pageY;
      state.touchParams.lastTime = event.timeStamp || Date.now();
      let move = state.touchParams.lastY - state.touchParams.startY;
      if (Math.abs(move) < 5) {
        return false;
      }
      const updateMove = move + state.transformY;
      const h2 = ((_a = months.value) == null ? void 0 : _a.offsetHeight) || 0;
      const offsetHeight = ((_b = monthsPanel.value) == null ? void 0 : _b.offsetHeight) || 0;
      if (updateMove > 0) {
        getMonth(getCurrData("prev"), "prev");
      } else if (updateMove < 0 && updateMove < -offsetHeight + (Math.abs(move) > h2 ? Math.abs(move) : h2) * 5) {
        getMonth(getCurrData("next"), "next");
        if (Math.abs(move) >= 300) {
          getMonth(getCurrData("next"), "next");
        }
      }
      let moveTime = state.touchParams.lastTime - state.touchParams.startTime;
      if (moveTime <= 300) {
        move = move * 2;
        moveTime = moveTime + 1e3;
        setMove(move, "end", moveTime);
      } else {
        setMove(move, "end");
      }
    };
    const resetRender = () => {
      state.chooseData.splice(0);
      state.monthsData.splice(0);
      state.scrollDistance = 0;
      state.translateY = 0;
      setTransform(state.scrollDistance);
      initData();
    };
    initData();
    watch(() => props.defaultValue, (val) => {
      if (val) {
        resetRender();
      }
    });
    return __spreadValues(__spreadValues({
      weeks,
      touchStart,
      touchMove,
      touchEnd,
      getClass,
      isStartTip,
      isEndTip,
      chooseDay,
      isCurrDay,
      confirm,
      monthsPanel,
      months,
      weeksPanel
    }, toRefs(state)), toRefs(props));
  }
});
const _hoisted_1$t = { class: "calendar-title" };
const _hoisted_2$o = { class: "calendar-curr-month" };
const _hoisted_3$k = {
  class: "calendar-weeks",
  ref: "weeksPanel"
};
const _hoisted_4$f = {
  class: "calendar-months-panel",
  ref: "monthsPanel"
};
const _hoisted_5$a = { class: "calendar-loading-tip" };
const _hoisted_6$8 = { class: "calendar-month-title" };
const _hoisted_7$7 = { class: "calendar-month-con" };
const _hoisted_8$7 = ["onClick"];
const _hoisted_9$5 = { class: "calendar-day" };
const _hoisted_10$3 = {
  key: 0,
  class: "calendar-curr-tips"
};
const _hoisted_11$3 = {
  key: 1,
  class: "calendar-day-tip"
};
const _hoisted_12$3 = {
  key: 2,
  class: "calendar-day-tip"
};
const _hoisted_13$2 = {
  key: 0,
  class: "nut-calendar-footer"
};
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-calendar nut-calendar-taro", {
      "nut-calendar-tile": !_ctx.poppable,
      "nut-calendar-nofooter": _ctx.isAutoBackFill
    }])
  }, [
    createElementVNode("view", {
      class: normalizeClass(["nut-calendar-header", { "nut-calendar-header-tile": !_ctx.poppable }])
    }, [
      _ctx.poppable ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createElementVNode("view", _hoisted_1$t, toDisplayString(_ctx.title), 1),
        createElementVNode("view", _hoisted_2$o, toDisplayString(_ctx.yearMonthTitle), 1)
      ], 64)) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_3$k, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weeks, (item, index) => {
          return openBlock(), createElementBlock("view", {
            class: "calendar-week-item",
            key: index
          }, toDisplayString(item), 1);
        }), 128))
      ], 512)
    ], 2),
    createElementVNode("view", {
      class: "nut-calendar-content",
      ref: "months",
      onTouchstart: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.touchStart && _ctx.touchStart(...args), ["stop"])),
      onTouchmove: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.touchMove && _ctx.touchMove(...args), ["stop", "prevent"])),
      onTouchend: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.touchEnd && _ctx.touchEnd(...args), ["stop"]))
    }, [
      createElementVNode("view", _hoisted_4$f, [
        createElementVNode("view", _hoisted_5$a, toDisplayString(!_ctx.unLoadPrev ? "\u52A0\u8F7D\u4E0A\u4E00\u4E2A\u6708" : "\u6CA1\u6709\u66F4\u65E9\u6708\u4EFD"), 1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.monthsData, (month, index) => {
          return openBlock(), createElementBlock("view", {
            class: "calendar-month",
            key: index
          }, [
            createElementVNode("view", _hoisted_6$8, toDisplayString(month.title), 1),
            createElementVNode("view", _hoisted_7$7, [
              createElementVNode("view", {
                class: normalizeClass(["calendar-month-item", _ctx.type === "range" ? "month-item-range" : ""])
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(month.monthData, (day, i) => {
                  return openBlock(), createElementBlock("view", {
                    key: i,
                    class: normalizeClass(["calendar-month-day", _ctx.getClass(day, month)]),
                    onClick: ($event) => _ctx.chooseDay(day, month)
                  }, [
                    createElementVNode("view", _hoisted_9$5, toDisplayString(day.type == "curr" ? day.day : ""), 1),
                    _ctx.isCurrDay(month, day.day) ? (openBlock(), createElementBlock("view", _hoisted_10$3, "\u4ECA\u5929")) : createCommentVNode("", true),
                    _ctx.isStartTip(day, month) ? (openBlock(), createElementBlock("view", _hoisted_11$3, toDisplayString("\u5F00\u59CB"))) : _ctx.isEndTip(day, month) ? (openBlock(), createElementBlock("view", _hoisted_12$3, toDisplayString("\u7ED3\u675F"))) : createCommentVNode("", true)
                  ], 10, _hoisted_8$7);
                }), 128))
              ], 2)
            ])
          ]);
        }), 128))
      ], 512)
    ], 544),
    _ctx.poppable && !_ctx.isAutoBackFill ? (openBlock(), createElementBlock("view", _hoisted_13$2, [
      createElementVNode("view", {
        class: "calendar-confirm-btn",
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.confirm && _ctx.confirm(...args))
      }, "\u786E\u5B9A")
    ])) : createCommentVNode("", true)
  ], 2);
}
var CalendarItem = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$y]]);
const { create: create$B } = createComponent("calendar");
const _sfc_main$B = create$B({
  components: {
    [CalendarItem.name]: CalendarItem
  },
  props: {
    type: {
      type: String,
      default: "one"
    },
    isAutoBackFill: {
      type: Boolean,
      default: false
    },
    poppable: {
      type: Boolean,
      default: true
    },
    visible: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: "\u65E5\u5386\u9009\u62E9"
    },
    defaultValue: {
      type: String
    },
    startDate: {
      type: String,
      default: Utils.getDay(0)
    },
    endDate: {
      type: String,
      default: Utils.getDay(365)
    }
  },
  emits: ["choose", "close", "update:visible"],
  setup(props, { emit }) {
    const calendarRef = ref(null);
    const update = () => {
      emit("update:visible", false);
    };
    const close = () => {
      emit("close");
      emit("update:visible", false);
    };
    const choose = (param) => {
      close();
      emit("choose", param);
    };
    const closePopup = () => {
      close();
    };
    return {
      closePopup,
      update,
      close,
      choose,
      calendarRef
    };
  }
});
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_calendar_item = resolveComponent("nut-calendar-item");
  const _component_nut_popup = resolveComponent("nut-popup");
  return _ctx.poppable ? (openBlock(), createBlock(_component_nut_popup, {
    key: 0,
    visible: _ctx.visible,
    position: "bottom",
    round: "",
    closeable: true,
    onClickOverlay: _ctx.closePopup,
    onClickCloseIcon: _ctx.closePopup
  }, {
    default: withCtx(() => [
      createVNode(_component_nut_calendar_item, {
        props: "",
        ref: "calendarRef",
        type: _ctx.type,
        "is-auto-back-fill": _ctx.isAutoBackFill,
        poppable: _ctx.poppable,
        title: _ctx.title,
        "default-value": _ctx.defaultValue,
        "start-date": _ctx.startDate,
        "end-date": _ctx.endDate,
        onUpdate: _ctx.update,
        onClose: _ctx.close,
        onChoose: _ctx.choose
      }, null, 8, ["type", "is-auto-back-fill", "poppable", "title", "default-value", "start-date", "end-date", "onUpdate", "onClose", "onChoose"])
    ]),
    _: 1
  }, 8, ["visible", "onClickOverlay", "onClickCloseIcon"])) : (openBlock(), createBlock(_component_nut_calendar_item, {
    key: 1,
    type: _ctx.type,
    "is-auto-back-fill": _ctx.isAutoBackFill,
    poppable: _ctx.poppable,
    title: _ctx.title,
    "default-value": _ctx.defaultValue,
    "start-date": _ctx.startDate,
    "end-date": _ctx.endDate,
    onClose: _ctx.close,
    onChoose: _ctx.choose
  }, null, 8, ["type", "is-auto-back-fill", "poppable", "title", "default-value", "start-date", "end-date", "onClose", "onChoose"]));
}
var Calendar = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$x]]);
const { create: create$A, componentName: componentName$r } = createComponent("checkbox");
const _sfc_main$A = create$A({
  components: {
    nutIcon: _sfc_main$1o
  },
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    textPosition: {
      type: String,
      default: "right"
    },
    iconSize: {
      type: [String, Number],
      default: "18"
    },
    iconName: {
      type: String,
      default: "check-normal"
    },
    iconActiveName: {
      type: String,
      default: "checked"
    },
    label: {
      type: String,
      default: ""
    }
  },
  emits: ["change", "update:modelValue"],
  setup(props, { emit, slots }) {
    const parent = inject("parent");
    const hasParent = computed(() => !!parent);
    const pValue = computed(() => {
      if (hasParent.value) {
        return parent.value.value.includes(props.label);
      } else {
        return props.modelValue;
      }
    });
    const pDisabled = computed(() => {
      return hasParent.value ? parent.disabled : props.disabled;
    });
    const checked = computed(() => !!props.modelValue);
    const color = computed(() => {
      return !pDisabled.value ? !pValue.value ? "nut-checkbox__icon--unchecked" : "nut-checkbox__icon" : "nut-checkbox__icon--disable";
    });
    const emitChange = (value, label) => {
      emit("update:modelValue", value);
      emit("change", value, label);
    };
    const renderIcon = () => {
      const { iconName, iconSize, iconActiveName } = props;
      return h(_sfc_main$1o, {
        name: !pValue.value ? iconName : iconActiveName,
        size: iconSize,
        class: color.value
      });
    };
    const renderLabel = () => {
      var _a;
      return h("view", {
        class: `${componentName$r}__label ${pDisabled.value ? `${componentName$r}__label--disabled` : ""}`
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
    const handleClick = (e) => {
      var _a;
      if (pDisabled.value)
        return;
      emitChange(!checked.value, (_a = slots.default) == null ? void 0 : _a.call(slots)[0].children);
      if (hasParent.value) {
        let value = parent.value.value;
        let { label } = props;
        const index = value.indexOf(label);
        if (index > -1) {
          value.splice(index, 1);
        } else {
          value.push(label);
        }
        parent.updateValue(value);
      }
    };
    onMounted(() => {
      hasParent.value && parent["relation"](getCurrentInstance());
    });
    return () => {
      return h("view", {
        class: `${componentName$r} ${props.textPosition === "left" ? `${componentName$r}--reverse` : ""}`,
        onClick: handleClick
      }, [renderIcon(), renderLabel()]);
    };
  }
});
const { create: create$z, componentName: componentName$q } = createComponent("checkboxgroup");
const _sfc_main$z = create$z({
  props: {
    modelValue: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["change", "update:modelValue"],
  setup(props, { slots, emit }) {
    const state = reactive({
      children: []
    });
    const relation = (child) => {
      if (child.proxy) {
        state.children.push(child.proxy);
      }
    };
    const updateValue = (value) => {
      emit("update:modelValue", value);
      emit("change", value);
    };
    const toggleAll = (checked) => {
      let values = [];
      if (!!checked) {
        state.children.forEach((item) => {
          values.push(item == null ? void 0 : item.label);
        });
      }
      emit("update:modelValue", values);
    };
    provide("parent", {
      value: computed(() => props.modelValue),
      disabled: props.disabled,
      updateValue,
      relation
    });
    watch(() => props.modelValue, (value) => {
      emit("change", value);
    });
    useExpose$1({ toggleAll });
    return () => {
      var _a;
      return h("view", {
        class: `${componentName$q}`
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const commonProps = {
  listData: {
    type: Array,
    default: () => {
      return [];
    }
  },
  readonly: {
    type: Boolean,
    default: false
  },
  defaultIndex: {
    type: [Number, String],
    default: 0
  },
  itemHeight: {
    type: [Number, String],
    default: 35
  }
};
const { create: create$y } = createComponent("picker-column");
const _sfc_main$y = create$y({
  props: __spreadValues({
    dataType: String,
    itemShow: {
      type: Boolean,
      default: false
    }
  }, commonProps),
  emits: ["click", "change"],
  setup(props, { emit }) {
    const wrapper = ref();
    const state = reactive({
      touchParams: {
        startY: 0,
        endY: 0,
        startTime: 0,
        endTime: 0,
        lastY: 0
      },
      currIndex: 1,
      transformY: 0,
      scrollDistance: 0,
      lineSpacing: 36,
      rotation: 20,
      timer: null
    });
    const roller = ref(null);
    const list = ref(null);
    const listItem = ref(null);
    const touchDeg = ref(0);
    const touchTime = ref(0);
    const touchTranslateY = ref(0);
    const touchListStyle = computed(() => {
      return {
        transition: `transform ${touchTime.value}ms cubic-bezier(0.19, 1, 0.22, 1)`,
        transform: `translate3d(0, ${state.scrollDistance}px, 0)`
      };
    });
    const touchRollerStyle = computed(() => {
      return {
        transition: `transform ${touchTime.value}ms cubic-bezier(0.19, 1, 0.22, 1)`,
        transform: `rotate3d(1, 0, 0, ${touchDeg.value})`
      };
    });
    const onTouchStart = (event) => {
      event.preventDefault();
      let changedTouches = event.changedTouches[0];
      state.touchParams.startY = changedTouches.pageY;
      state.touchParams.startTime = event.timeStamp || Date.now();
      state.transformY = state.scrollDistance;
    };
    const onTouchMove = (event) => {
      event.preventDefault();
      let changedTouches = event.changedTouches[0];
      state.touchParams.lastY = changedTouches.pageY;
      state.touchParams.lastTime = event.timeStamp || Date.now();
      let move = state.touchParams.lastY - state.touchParams.startY;
      setMove(move);
    };
    const onTouchEnd = (event) => {
      event.preventDefault();
      let changedTouches = event.changedTouches[0];
      state.touchParams.lastY = changedTouches.pageY;
      state.touchParams.lastTime = event.timestamp || Date.now();
      let move = state.touchParams.lastY - state.touchParams.startY;
      let moveTime = state.touchParams.lastTime - state.touchParams.startTime;
      if (moveTime <= 300) {
        move = move * 2;
        moveTime = moveTime + 1e3;
        setMove(move, "end", moveTime);
      } else {
        setMove(move, "end");
      }
    };
    const setRollerStyle = (index) => {
      return `transform: rotate3d(1, 0, 0, ${-state.rotation * index}deg) translate3d(0px, 0px, 104px)`;
    };
    const isHidden = (index) => {
      if (index >= state.currIndex + 8 || index <= state.currIndex - 8) {
        return true;
      } else {
        return false;
      }
    };
    const setTransform = (translateY = 0, type, time = 1e3, deg) => {
      if (type === "end") {
        touchTime.value = time;
      } else {
        touchTime.value = 0;
      }
      touchDeg.value = deg;
      touchTranslateY.value = translateY;
      state.scrollDistance = translateY;
    };
    const setMove = (move, type, time) => {
      let updateMove = move + state.transformY;
      if (type === "end") {
        if (updateMove > 0) {
          updateMove = 0;
        }
        if (updateMove < -(props.listData.values.length - 1) * state.lineSpacing) {
          updateMove = -(props.listData.values.length - 1) * state.lineSpacing;
        }
        let endMove = Math.round(updateMove / state.lineSpacing) * state.lineSpacing;
        let deg = `${(Math.abs(Math.round(endMove / state.lineSpacing)) + 1) * state.rotation}deg`;
        setTransform(endMove, type, time, deg);
        let t = time ? time / 2 : 0;
        state.timer = setTimeout(() => {
          setChooseValue();
        }, t);
        state.currIndex = Math.abs(Math.round(endMove / state.lineSpacing)) + 1;
      } else {
        let deg = "0deg";
        if (updateMove < 0) {
          deg = `${(Math.abs(updateMove / state.lineSpacing) + 1) * state.rotation}deg`;
        } else {
          deg = `${(-updateMove / state.lineSpacing + 1) * state.rotation}deg`;
        }
        setTransform(updateMove, null, void 0, deg);
        state.currIndex = Math.abs(Math.round(updateMove / state.lineSpacing)) + 1;
      }
    };
    const setChooseValue = () => {
      emit("change", state.currIndex - 1);
    };
    const modifyStatus = (type) => {
      let index = props.defaultIndex;
      state.currIndex = index === -1 ? 1 : index + 1;
      let move = index === -1 ? 0 : index * state.lineSpacing;
      type && setChooseValue();
      setMove(-move);
    };
    watch(() => props.listData, (val) => {
      state.transformY = 0;
      modifyStatus(false);
    }, {
      deep: true
    });
    watch(() => props.defaultIndex, (val) => {
      state.transformY = 0;
      modifyStatus(false);
    });
    onMounted(() => {
      modifyStatus(true);
    });
    return __spreadProps(__spreadValues(__spreadValues({}, toRefs(state)), toRefs(props)), {
      wrapper,
      setRollerStyle,
      isHidden,
      roller,
      list,
      listItem,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      touchRollerStyle,
      touchListStyle
    });
  }
});
const _hoisted_1$s = { class: "nut-picker-content" };
const _hoisted_2$n = {
  key: 0,
  class: "nut-picker-placeholder"
};
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: "nut-picker__list",
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
  }, [
    createElementVNode("view", {
      class: "nut-picker-roller",
      ref: "roller",
      style: normalizeStyle(_ctx.touchRollerStyle)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listData.values, (item, index) => {
        return openBlock(), createElementBlock("view", {
          class: normalizeClass(["nut-picker-roller-item", { "nut-picker-roller-item-hidden": _ctx.isHidden(index + 1) }]),
          style: normalizeStyle(_ctx.setRollerStyle(index + 1)),
          key: item.label ? item.label : index
        }, toDisplayString(_ctx.dataType === "cascade" ? item.text : item), 7);
      }), 128))
    ], 4),
    createElementVNode("view", _hoisted_1$s, [
      createElementVNode("view", {
        class: "nut-picker-list-panel",
        ref: "list",
        style: normalizeStyle(_ctx.touchListStyle)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.listData.values, (item, index) => {
          return openBlock(), createElementBlock("view", {
            class: "nut-picker-item nut-picker-item-ref",
            key: item.label ? item.label : index
          }, toDisplayString(_ctx.dataType === "cascade" ? item.text : item), 1);
        }), 128)),
        _ctx.listData && _ctx.listData.length === 1 ? (openBlock(), createElementBlock("view", _hoisted_2$n)) : createCommentVNode("", true)
      ], 4)
    ])
  ], 32);
}
var column = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$w]]);
const { create: create$x, componentName: componentName$p } = createComponent("picker");
const _sfc_main$x = create$x({
  components: {
    [column.name]: column,
    [Popup.name]: Popup
  },
  props: __spreadValues(__spreadProps(__spreadValues({}, popupProps), {
    title: {
      type: String,
      default: ""
    },
    cancelText: {
      type: String,
      default: "\u53D6\u6D88"
    },
    okText: {
      type: String,
      default: "\u786E\u5B9A"
    }
  }), commonProps),
  emits: ["close", "change", "confirm", "update:visible"],
  setup(props, { emit }) {
    const childrenKey = "children";
    const valuesKey = "values";
    const state = reactive({
      show: false,
      formattedColumns: props.listData,
      defaultIndex: props.defaultIndex
    });
    let _defaultIndex = props.defaultIndex;
    let defaultIndexList = [];
    const classes = computed(() => {
      const prefixCls = componentName$p;
      return {
        [prefixCls]: true
      };
    });
    const dataType = computed(() => {
      const firstColumn = state.formattedColumns[0];
      if (typeof firstColumn === "object") {
        if (firstColumn[childrenKey]) {
          return "cascade";
        } else if (firstColumn == null ? void 0 : firstColumn[valuesKey]) {
          addDefaultIndexList(props.listData);
          return "multipleColumns";
        }
      }
      return "text";
    });
    const columnList = computed(() => {
      if (dataType.value === "text") {
        return [{ values: state.formattedColumns, defaultIndex: state.defaultIndex }];
      } else if (dataType.value === "multipleColumns") {
        return state.formattedColumns;
      } else if (dataType.value === "cascade") {
        return formatCascade(state.formattedColumns, state.defaultIndex);
      }
      return state.formattedColumns;
    });
    const addDefaultIndexList = (listData) => {
      defaultIndexList = [];
      listData.forEach((res) => {
        defaultIndexList.push(res.defaultIndex || 0);
      });
    };
    const formatCascade = (listData, defaultIndex) => {
      const formatted = [];
      let children = listData;
      children.defaultIndex = defaultIndex;
      while (children) {
        formatted.push({
          values: children,
          defaultIndex: children.defaultIndex || 0
        });
        children = children == null ? void 0 : children[children.defaultIndex || 0].children;
      }
      addDefaultIndexList(formatted);
      return formatted;
    };
    const getCascadeData = (listData, defaultIndex) => {
      var _a;
      let arr = listData;
      arr.defaultIndex = defaultIndex;
      const dataList = [];
      while (arr) {
        const item = arr[(_a = arr.defaultIndex) != null ? _a : 0];
        dataList.push(item.text);
        arr = item.children;
      }
      return dataList;
    };
    const close = () => {
      emit("close");
      emit("update:visible", false);
    };
    const changeHandler = (columnIndex, dataIndex) => {
      if (dataType.value === "cascade") {
        let cursor = state.formattedColumns;
        if (columnIndex === 0) {
          state.defaultIndex = dataIndex;
        }
        let i = 0;
        while (cursor) {
          if (i === columnIndex) {
            cursor.defaultIndex = dataIndex;
          } else if (i > columnIndex) {
            cursor.defaultIndex = 0;
          }
          cursor = cursor[cursor.defaultIndex || 0].children;
          i++;
        }
      } else if (dataType.value === "text") {
        _defaultIndex = dataIndex;
      } else if (dataType.value === "multipleColumns") {
        defaultIndexList[columnIndex] = dataIndex;
        const val = defaultIndexList.map((res, i) => toRaw(state.formattedColumns)[i].values[res]);
        emit("change", val, columnIndex, dataIndex);
      }
    };
    const confirm = () => {
      if (dataType.value === "text") {
        state.defaultIndex = _defaultIndex;
        emit("confirm", state.formattedColumns[_defaultIndex]);
      } else if (dataType.value === "multipleColumns") {
        for (let i = 0; i < defaultIndexList.length; i++) {
          state.formattedColumns[i].defaultIndex = defaultIndexList[i];
        }
        const checkedArr = toRaw(state.formattedColumns).map((res) => res.values && res.values[res.defaultIndex]);
        emit("confirm", checkedArr);
      } else if (dataType.value === "cascade") {
        emit("confirm", getCascadeData(toRaw(state.formattedColumns), state.defaultIndex));
      }
      emit("update:visible", false);
    };
    watch(() => props.visible, (val) => {
      state.show = val;
    });
    watch(() => props.listData, (val) => {
      state.formattedColumns = val;
    });
    return __spreadProps(__spreadValues({
      classes
    }, toRefs(state)), {
      column,
      dataType,
      columnList,
      close,
      changeHandler,
      confirm
    });
  }
});
const _hoisted_1$r = { class: "nut-picker__bar" };
const _hoisted_2$m = { class: "nut-picker__column" };
const _hoisted_3$j = /* @__PURE__ */ createElementVNode("view", { class: "nut-picker__hairline" }, null, -1);
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_picker_column = resolveComponent("nut-picker-column");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createVNode(_component_nut_popup, {
      position: "bottom",
      visible: _ctx.show,
      "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.show = $event),
      teleport: _ctx.teleport,
      "lock-scroll": _ctx.lockScroll,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      onClose: _ctx.close,
      round: true
    }, {
      default: withCtx(() => [
        createElementVNode("view", _hoisted_1$r, [
          createElementVNode("view", {
            class: "nut-picker__left nut-picker__button",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.close && _ctx.close(...args))
          }, toDisplayString(_ctx.cancelText), 1),
          createElementVNode("view", null, toDisplayString(_ctx.title), 1),
          createElementVNode("view", {
            class: "nut-picker__button",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.confirm())
          }, toDisplayString(_ctx.okText), 1)
        ]),
        createElementVNode("view", _hoisted_2$m, [
          _hoisted_3$j,
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnList, (item, columnIndex) => {
            return openBlock(), createElementBlock("view", {
              class: "nut-picker__columnitem",
              key: columnIndex
            }, [
              createVNode(_component_nut_picker_column, {
                itemShow: _ctx.show,
                "list-data": item,
                readonly: _ctx.readonly,
                "default-index": item.defaultIndex,
                "visible-item-count": _ctx.visibleItemCount,
                "data-type": _ctx.dataType,
                onChange: (dataIndex) => {
                  _ctx.changeHandler(columnIndex, dataIndex);
                }
              }, null, 8, ["itemShow", "list-data", "readonly", "default-index", "visible-item-count", "data-type", "onChange"])
            ]);
          }), 128))
        ])
      ]),
      _: 1
    }, 8, ["visible", "teleport", "lock-scroll", "close-on-click-overlay", "onClose"])
  ], 2);
}
var Picker = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$v]]);
const { componentName: componentName$o, create: create$w } = createComponent("datepicker");
const currentYear = new Date().getFullYear();
function isDate(val) {
  return Object.prototype.toString.call(val) === "[object Date]" && !isNaN(val.getTime());
}
const zhCNType = {
  day: "\u65E5",
  year: "\u5E74",
  month: "\u6708",
  hour: "\u65F6",
  minute: "\u5206",
  seconds: "\u79D2"
};
const _sfc_main$w = create$w({
  components: {
    [Picker.name]: Picker
  },
  props: {
    modelValue: null,
    visible: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "date"
    },
    isShowChinese: {
      type: Boolean,
      default: true
    },
    minuteStep: {
      type: Number,
      default: 1
    },
    minDate: {
      type: Date,
      default: () => new Date(currentYear - 10, 0, 1),
      validator: isDate
    },
    maxDate: {
      type: Date,
      default: () => new Date(currentYear + 10, 11, 31),
      validator: isDate
    }
  },
  emits: ["click", "update:visible", "confirm"],
  setup(props, { emit }) {
    const state = reactive({
      show: false,
      currentDate: new Date(),
      title: props.title
    });
    const formatValue = (value) => {
      if (!isDate(value)) {
        value = props.minDate;
      }
      let timestmp = Math.max(value.getTime(), props.minDate.getTime());
      timestmp = Math.min(timestmp, props.maxDate.getTime());
      return new Date(timestmp);
    };
    function getMonthEndDay(year, month) {
      return 32 - new Date(year, month - 1, 32).getDate();
    }
    const getBoundary = (type, value) => {
      const boundary = props[`${type}Date`];
      const year = boundary.getFullYear();
      let month = 1;
      let date = 1;
      let hour = 0;
      let minute = 0;
      if (type === "max") {
        month = 12;
        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);
        hour = 23;
        minute = 59;
      }
      const seconds = minute;
      if (value.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (value.getMonth() + 1 === month) {
          date = boundary.getDate();
          if (value.getDate() === date) {
            hour = boundary.getHours();
            if (value.getHours() === hour) {
              minute = boundary.getMinutes();
            }
          }
        }
      }
      return {
        [`${type}Year`]: year,
        [`${type}Month`]: month,
        [`${type}Date`]: date,
        [`${type}Hour`]: hour,
        [`${type}Minute`]: minute,
        [`${type}Seconds`]: seconds
      };
    };
    const ranges = computed(() => {
      const { maxYear, maxDate, maxMonth, maxHour, maxMinute, maxSeconds } = getBoundary("max", state.currentDate);
      const { minYear, minDate, minMonth, minHour, minMinute, minSeconds } = getBoundary("min", state.currentDate);
      let result = [
        {
          type: "year",
          range: [minYear, maxYear]
        },
        {
          type: "month",
          range: [minMonth, maxMonth]
        },
        {
          type: "day",
          range: [minDate, maxDate]
        },
        {
          type: "hour",
          range: [minHour, maxHour]
        },
        {
          type: "minute",
          range: [minMinute, maxMinute]
        },
        {
          type: "seconds",
          range: [minSeconds, maxSeconds]
        }
      ];
      switch (props.type) {
        case "date":
          result = result.slice(0, 3);
          break;
        case "datetime":
          result = result.slice(0, 5);
          break;
        case "time":
          result = result.slice(3, 6);
          break;
        case "month-day":
          result = result.slice(1, 3);
          break;
        case "datehour":
          result = result.slice(0, 4);
          break;
      }
      return result;
    });
    const changeHandler = (val) => {
      if (["date", "datetime"].includes(props.type)) {
        let formatDate = [];
        if (props.isShowChinese) {
          formatDate = val.map((res) => {
            return Number(res.slice(0, res.length - 1));
          });
        } else {
          formatDate = val;
        }
        if (props.type === "date") {
          state.currentDate = formatValue(new Date(formatDate[0], formatDate[1] - 1, Math.min(formatDate[2], getMonthEndDay(formatDate[0], formatDate[1]))));
        } else if (props.type === "datetime") {
          state.currentDate = formatValue(new Date(formatDate[0], formatDate[1] - 1, Math.min(formatDate[2], getMonthEndDay(formatDate[0], formatDate[1])), formatDate[3], formatDate[4]));
        }
      }
    };
    const generateValue = (min, max, val, type) => {
      const arr = [];
      let index = 0;
      while (min <= max) {
        if (props.isShowChinese) {
          arr.push(min + zhCNType[type]);
        } else {
          arr.push(min);
        }
        if (type === "minute") {
          min += props.minuteStep;
        } else {
          min++;
        }
        if (min <= val) {
          index++;
        }
      }
      return { values: arr, defaultIndex: index };
    };
    const getDateIndex = (type) => {
      if (type === "year") {
        return state.currentDate.getFullYear();
      } else if (type === "month") {
        return state.currentDate.getMonth() + 1;
      } else if (type === "day") {
        return state.currentDate.getDate();
      } else if (type === "hour") {
        return state.currentDate.getHours();
      } else if (type === "minute") {
        return state.currentDate.getMinutes();
      } else if (type === "seconds") {
        return state.currentDate.getSeconds();
      }
      return 0;
    };
    const columns = computed(() => {
      console.log(ranges.value);
      const val = ranges.value.map((res) => {
        return generateValue(res.range[0], res.range[1], getDateIndex(res.type), res.type);
      });
      return val;
    });
    const closeHandler = () => {
      emit("update:visible", false);
    };
    const confirm = (val) => {
      emit("update:visible", false);
      emit("confirm", val);
    };
    onMounted(() => {
      state.currentDate = formatValue(props.modelValue);
    });
    watch(() => props.title, (val) => {
      state.title = val;
    });
    watch(() => props.visible, (val) => {
      state.show = val;
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      changeHandler,
      closeHandler,
      confirm,
      columns
    });
  }
});
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_picker = resolveComponent("nut-picker");
  return openBlock(), createBlock(_component_nut_picker, {
    visible: _ctx.show,
    onClose: _ctx.closeHandler,
    "list-data": _ctx.columns,
    onChange: _ctx.changeHandler,
    title: _ctx.title,
    onConfirm: _ctx.confirm
  }, null, 8, ["visible", "onClose", "list-data", "onChange", "title", "onConfirm"]);
}
var DatePicker = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$u]]);
const { componentName: componentName$n, create: create$v } = createComponent("inputnumber");
const _sfc_main$v = create$v({
  props: {
    modelValue: {
      type: [Number, String],
      default: 0
    },
    inputWidth: {
      type: [Number, String],
      default: ""
    },
    buttonSize: {
      type: [Number, String],
      default: ""
    },
    min: {
      type: [Number, String],
      default: 1
    },
    max: {
      type: [Number, String],
      default: 9999
    },
    step: {
      type: [Number, String],
      default: 1
    },
    decimalPlaces: {
      type: [Number, String],
      default: 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue", "change", "blur", "focus", "reduce", "add", "overlimit"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$n;
      return {
        [prefixCls]: true,
        [`${prefixCls}--disabled`]: props.disabled
      };
    });
    const fixedDecimalPlaces = (v) => {
      return Number(v).toFixed(Number(props.decimalPlaces));
    };
    const change = (event) => {
      const input = event.target;
      emit("update:modelValue", input.valueAsNumber, event);
    };
    const emitChange = (value, event) => {
      let output_value = fixedDecimalPlaces(value);
      emit("update:modelValue", output_value, event);
      emit("change", output_value, event);
    };
    const addAllow = (value = Number(props.modelValue)) => {
      return value < Number(props.max) && !props.disabled;
    };
    const reduceAllow = (value = Number(props.modelValue)) => {
      return value > Number(props.min) && !props.disabled;
    };
    const reduce = (event) => {
      emit("reduce", event);
      if (reduceAllow()) {
        let output_value = Number(props.modelValue) - Number(props.step);
        emitChange(output_value, event);
      } else {
        emit("overlimit", event, "reduce");
      }
    };
    const add = (event) => {
      emit("add", event);
      if (addAllow()) {
        let output_value = Number(props.modelValue) + Number(props.step);
        emitChange(output_value, event);
      } else {
        emit("overlimit", event, "add");
      }
    };
    const focus = (event) => {
      if (props.disabled)
        return;
      if (props.readonly)
        return;
      emit("focus", event);
    };
    const blur = (event) => {
      if (props.disabled)
        return;
      if (props.readonly)
        return;
      const input = event.target;
      let value = input.valueAsNumber;
      if (value < Number(props.min)) {
        value = Number(props.min);
      } else if (value > Number(props.max)) {
        value = Number(props.max);
      }
      emitChange(value, event);
      emit("blur", event);
    };
    return {
      classes,
      change,
      blur,
      focus,
      add,
      addAllow,
      reduce,
      reduceAllow,
      pxCheck
    };
  }
});
const _hoisted_1$q = ["min", "max", "disabled", "readonly", "value"];
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle({ height: _ctx.pxCheck(_ctx.buttonSize) })
  }, [
    createVNode(_component_nut_icon, {
      name: "minus",
      class: normalizeClass(["nut-inputnumber__icon", { "nut-inputnumber__icon--disabled": !_ctx.reduceAllow() }]),
      size: _ctx.buttonSize,
      onClick: _ctx.reduce
    }, null, 8, ["class", "size", "onClick"]),
    createElementVNode("input", {
      type: "number",
      min: _ctx.min,
      max: _ctx.max,
      style: normalizeStyle({ width: _ctx.pxCheck(_ctx.inputWidth) }),
      disabled: _ctx.disabled,
      readonly: _ctx.readonly,
      value: _ctx.modelValue,
      onInput: _cache[0] || (_cache[0] = (...args) => _ctx.change && _ctx.change(...args)),
      onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.blur && _ctx.blur(...args)),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.focus && _ctx.focus(...args))
    }, null, 44, _hoisted_1$q),
    createVNode(_component_nut_icon, {
      name: "plus",
      class: normalizeClass(["nut-inputnumber__icon", { "nut-inputnumber__icon--disabled": !_ctx.addAllow() }]),
      size: _ctx.buttonSize,
      onClick: _ctx.add
    }, null, 8, ["class", "size", "onClick"])
  ], 6);
}
var InputNumber = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$t]]);
function trimExtraChar(value, char, regExp) {
  const index = value.indexOf(char);
  if (index === -1) {
    return value;
  }
  if (char === "-" && index !== 0) {
    return value.slice(0, index);
  }
  return value.slice(0, index + 1) + value.slice(index).replace(regExp, "");
}
function formatNumber(value, allowDot = true, allowMinus = true) {
  if (allowDot) {
    value = trimExtraChar(value, ".", /\./g);
  } else {
    value = value.replace(/\./g, "");
  }
  if (allowMinus) {
    value = trimExtraChar(value, "-", /-/g);
  } else {
    value = value.replace(/-/, "");
  }
  const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
  return value.replace(regExp, "");
}
const { componentName: componentName$m, create: create$u } = createComponent("input");
const _sfc_main$u = create$u({
  props: {
    type: {
      type: String,
      default: "text"
    },
    modelValue: {
      type: [String, Number],
      default: ""
    },
    placeholder: {
      type: String,
      default: "\u8BF7\u8F93\u5165\u4FE1\u606F"
    },
    label: {
      type: String,
      default: ""
    },
    requireShow: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    textAlign: {
      type: String,
      default: "left"
    },
    maxLength: {
      type: [String, Number],
      default: ""
    },
    clearable: {
      type: Boolean,
      default: true
    },
    hasBorder: {
      type: Boolean,
      default: true
    }
  },
  emits: ["change", "update:modelValue", "blur", "focus", "clear"],
  setup(props, { emit }) {
    const active = ref(false);
    const classes = computed(() => {
      const prefixCls = componentName$m;
      return {
        [prefixCls]: true,
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-require`]: props.requireShow,
        [`${prefixCls}-border`]: props.hasBorder
      };
    });
    const styles = computed(() => {
      return {
        textAlign: props.textAlign
      };
    });
    const valueChange = (event) => {
      const input = event.target;
      let val = input.value;
      if (props.type === "digit") {
        val = formatNumber(val, true);
      }
      if (props.type === "number") {
        val = formatNumber(val, false);
      }
      if (props.maxLength && val.length > Number(props.maxLength)) {
        val = val.slice(0, Number(props.maxLength));
      }
      emit("update:modelValue", val, event);
      emit("change", val, event);
    };
    const valueFocus = (event) => {
      const input = event.target;
      let value = input.value;
      active.value = true;
      emit("focus", value, event);
    };
    const valueBlur = (event) => {
      setTimeout(() => {
        active.value = false;
      }, 200);
      const input = event.target;
      let value = input.value;
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.slice(0, Number(props.maxLength));
      }
      emit("blur", value, event);
    };
    const handleClear = (event) => {
      emit("update:modelValue", "", event);
      emit("change", "", event);
      emit("clear", "");
    };
    return {
      active,
      classes,
      styles,
      valueChange,
      valueFocus,
      valueBlur,
      handleClear
    };
  }
});
const _hoisted_1$p = {
  key: 0,
  class: "nut-input-label"
};
const _hoisted_2$l = { class: "label-string" };
const _hoisted_3$i = ["type", "maxlength", "placeholder", "disabled", "readonly", "value"];
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.label ? (openBlock(), createElementBlock("view", _hoisted_1$p, [
      createElementVNode("view", _hoisted_2$l, toDisplayString(_ctx.label), 1)
    ])) : createCommentVNode("", true),
    createElementVNode("input", {
      class: "input-text",
      style: normalizeStyle(_ctx.styles),
      type: _ctx.type,
      maxlength: _ctx.maxLength,
      placeholder: _ctx.placeholder,
      disabled: _ctx.disabled,
      readonly: _ctx.readonly,
      value: _ctx.modelValue,
      onInput: _cache[0] || (_cache[0] = (...args) => _ctx.valueChange && _ctx.valueChange(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.valueFocus && _ctx.valueFocus(...args)),
      onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.valueBlur && _ctx.valueBlur(...args))
    }, null, 44, _hoisted_3$i),
    _ctx.clearable && !_ctx.readonly ? withDirectives((openBlock(), createElementBlock("view", {
      key: 1,
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClear && _ctx.handleClear(...args)),
      class: "nut-textinput-clear"
    }, [
      createVNode(_component_nut_icon, {
        name: "close-little",
        size: "12px"
      })
    ], 512)), [
      [vShow, _ctx.active && _ctx.modelValue.length > 0]
    ]) : createCommentVNode("", true)
  ], 2);
}
var Input = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$s]]);
const { componentName: componentName$l, create: create$t } = createComponent("radio");
const _sfc_main$t = create$t({
  props: {
    disabled: {
      type: Boolean,
      default: false
    },
    shape: {
      type: String,
      default: "round"
    },
    label: {
      type: [String, Number],
      default: ""
    },
    iconName: {
      type: String,
      default: "check-normal"
    },
    iconActiveName: {
      type: String,
      default: "check-checked"
    },
    iconSize: {
      type: [String, Number],
      default: 18
    }
  },
  setup(props, { emit, slots }) {
    let parent = inject("parent");
    const isCurValue = computed(() => {
      return parent.label.value == props.label;
    });
    const color = computed(() => {
      return !props.disabled ? isCurValue.value ? "nut-radio__icon" : "nut-radio__icon--unchecked" : "nut-radio__icon--disable";
    });
    const position = computed(() => {
      return parent.position;
    });
    const renderIcon = () => {
      const { iconName, iconSize, iconActiveName } = props;
      return h(_sfc_main$1o, {
        name: isCurValue.value ? iconActiveName : iconName,
        size: iconSize,
        class: color.value
      });
    };
    const renderLabel = () => {
      var _a;
      return h("view", {
        class: `${componentName$l}__label ${props.disabled ? `${componentName$l}__label--disabled` : ""}`
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
    const renderButton = () => {
      var _a;
      return h("view", {
        class: `${componentName$l}__button ${isCurValue.value && `${componentName$l}__button--active`} ${props.disabled ? `${componentName$l}__button--disabled` : ""}`
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
    const handleClick = () => {
      if (isCurValue.value || props.disabled)
        return;
      parent.updateValue(props.label);
    };
    let reverseState = position.value === "left";
    return () => {
      return h("view", {
        class: `${componentName$l} ${componentName$l}--${props.shape} ${reverseState ? `${componentName$l}--reverse` : ""}`,
        onClick: handleClick
      }, [
        props.shape == "button" ? renderButton() : reverseState ? [renderLabel(), renderIcon()] : [renderIcon(), renderLabel()]
      ]);
    };
  }
});
const { componentName: componentName$k, create: create$s } = createComponent("radiogroup");
const _sfc_main$s = create$s({
  props: {
    modelValue: {
      type: [Number, String, Boolean],
      default: ""
    },
    direction: {
      type: String,
      default: "vertical"
    },
    textPosition: {
      type: String,
      default: "right"
    }
  },
  emits: ["change", "update:modelValue"],
  setup(props, { emit, slots }) {
    const updateValue = (value) => emit("update:modelValue", value);
    provide("parent", {
      label: readonly(computed(() => props.modelValue)),
      position: props.textPosition,
      updateValue
    });
    watch(() => props.modelValue, (value) => emit("change", value));
    return () => {
      var _a;
      return h("view", {
        class: `${componentName$k} ${componentName$k}--${props.direction}`
      }, (_a = slots.default) == null ? void 0 : _a.call(slots));
    };
  }
});
const { componentName: componentName$j, create: create$r } = createComponent("rate");
const _sfc_main$r = create$r({
  props: {
    count: {
      type: [String, Number],
      default: 5
    },
    modelValue: {
      type: [String, Number],
      default: 0
    },
    iconSize: {
      type: [String, Number],
      default: 18
    },
    activeColor: {
      type: String,
      default: ""
    },
    voidColor: {
      type: String,
      default: ""
    },
    uncheckedIcon: {
      type: String,
      default: "star-n"
    },
    checkedIcon: {
      type: String,
      default: "star-fill-n"
    },
    readonly: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    spacing: {
      type: [String, Number],
      default: 14
    },
    classPrefix: {
      type: String,
      default: "nut-icon"
    },
    fontClassName: {
      type: String,
      default: "nutui-iconfont"
    }
  },
  emits: ["update:modelValue", "change"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$j;
      return {
        [prefixCls]: true
      };
    });
    const onClick = (e, index) => {
      e.preventDefault();
      e.stopPropagation();
      if (props.disabled || props.readonly)
        return;
      let value = 0;
      if (index === 1 && props.modelValue === index)
        ;
      else {
        value = index;
        if (props.allowHalf) {
          if ((e == null ? void 0 : e.target).className.includes("__icon--half")) {
            value -= 0.5;
          }
        }
      }
      emit("update:modelValue", value);
      emit("change", value);
    };
    return {
      classes,
      onClick,
      pxCheck
    };
  }
});
const _hoisted_1$o = ["onClick"];
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.count, (n) => {
      return openBlock(), createElementBlock("view", {
        class: "nut-rate-item",
        key: n,
        onClick: ($event) => _ctx.onClick($event, n),
        style: normalizeStyle({ marginRight: _ctx.pxCheck(_ctx.spacing) })
      }, [
        createVNode(_component_nut_icon, {
          size: _ctx.iconSize,
          class: normalizeClass(["nut-rate-item__icon", { "nut-rate-item__icon--disabled": _ctx.disabled || n > _ctx.modelValue }]),
          "font-class-name": _ctx.fontClassName,
          "class-prefix": _ctx.classPrefix,
          color: n <= _ctx.modelValue ? _ctx.activeColor : _ctx.voidColor,
          name: n <= _ctx.modelValue ? _ctx.checkedIcon : _ctx.uncheckedIcon
        }, null, 8, ["size", "class", "font-class-name", "class-prefix", "color", "name"]),
        _ctx.allowHalf && _ctx.modelValue + 1 > n ? (openBlock(), createBlock(_component_nut_icon, {
          key: 0,
          class: "nut-rate-item__icon nut-rate-item__icon--half",
          "font-class-name": _ctx.fontClassName,
          "class-prefix": _ctx.classPrefix,
          color: n <= _ctx.modelValue + 1 ? _ctx.activeColor : _ctx.voidColor,
          size: _ctx.iconSize,
          name: _ctx.checkedIcon
        }, null, 8, ["font-class-name", "class-prefix", "color", "size", "name"])) : _ctx.allowHalf && _ctx.modelValue + 1 < n ? (openBlock(), createBlock(_component_nut_icon, {
          key: 1,
          class: "nut-rate-item__icon nut-rate-item__icon--disabled nut-rate-item__icon--half",
          "font-class-name": _ctx.fontClassName,
          "class-prefix": _ctx.classPrefix,
          color: _ctx.voidColor,
          size: _ctx.iconSize,
          name: _ctx.uncheckedIcon
        }, null, 8, ["font-class-name", "class-prefix", "color", "size", "name"])) : createCommentVNode("", true)
      ], 12, _hoisted_1$o);
    }), 128))
  ], 2);
}
var Rate = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r]]);
const { create: create$q } = createComponent("shortpassword");
const _sfc_main$q = create$q({
  props: {
    title: {
      type: String,
      default: "\u8BF7\u8F93\u5165\u5BC6\u7801"
    },
    desc: {
      type: String,
      default: "\u60A8\u4F7F\u7528\u4E86\u865A\u62DF\u8D44\u4EA7\uFF0C\u8BF7\u8FDB\u884C\u9A8C\u8BC1"
    },
    tips: {
      type: String,
      default: "\u5FD8\u8BB0\u5BC6\u7801"
    },
    visible: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: String,
      default: ""
    },
    errorMsg: {
      type: String,
      default: ""
    },
    noButton: {
      type: Boolean,
      default: true
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    length: {
      type: [String, Number],
      default: 6
    }
  },
  emits: ["update:modelValue", "update:visible", "complete", "change", "ok", "tips", "close", "cancel"],
  setup(props, { emit }) {
    const realInput = ref(props.modelValue);
    const realpwd = ref();
    const comLen = computed(() => range(Number(props.length)));
    const show = ref(props.visible);
    function sureClick() {
      emit("ok", realInput.value);
    }
    function focus() {
      realpwd.value.focus();
    }
    watch(() => props.visible, (value) => {
      show.value = value;
    });
    watch(() => props.modelValue, (value) => {
      realInput.value = value;
      console.log("watch", value);
    });
    function changeValue(e) {
      const input = e.target;
      let val = input.value;
      if (val.length > comLen.value) {
        val = val.slice(0, comLen.value);
        realInput.value = val;
      }
      if (String(realInput.value).length === comLen.value) {
        emit("complete", val);
      }
      emit("change", val);
      emit("update:modelValue", val);
    }
    function close() {
      emit("update:visible", false);
      emit("cancel");
    }
    function closeIcon() {
      emit("update:visible", false);
      emit("close");
    }
    function range(val) {
      return Math.min(Math.max(4, val), 6);
    }
    function onTips() {
      emit("tips");
    }
    function systemStyle() {
      let u = navigator.userAgent;
      let isAndroid = u.indexOf("Android") > -1 || u.indexOf("Linux") > -1;
      let isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
      if (isIOS) {
        return {
          paddingRight: "1200px"
        };
      }
      if (isAndroid) {
        return {
          opacity: 0,
          zindex: 10
        };
      }
    }
    return {
      comLen,
      sureClick,
      realInput,
      realpwd,
      focus,
      range,
      changeValue,
      close,
      onTips,
      show,
      systemStyle,
      closeIcon
    };
  }
});
const _hoisted_1$n = { class: "nut-shortpsd-title" };
const _hoisted_2$k = { class: "nut-shortpsd-subtitle" };
const _hoisted_3$h = { class: "nut-input-normalw" };
const _hoisted_4$e = /* @__PURE__ */ createElementVNode("div", { class: "nut-input-site" }, null, -1);
const _hoisted_5$9 = {
  key: 0,
  class: "nut-shortpsd-icon"
};
const _hoisted_6$7 = { class: "nut-shortpsd-message" };
const _hoisted_7$6 = { class: "nut-shortpsd-error" };
const _hoisted_8$6 = {
  key: 0,
  class: "nut-shortpsd-forget"
};
const _hoisted_9$4 = {
  key: 0,
  class: "nut-shortpsd-footer"
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createElementBlock("view", null, [
    createVNode(_component_nut_popup, {
      style: {
        padding: "32px 24px 28px 24px",
        borderRadius: "12px",
        textAlign: "center"
      },
      visible: _ctx.show,
      "onUpdate:visible": _cache[6] || (_cache[6] = ($event) => _ctx.show = $event),
      closeable: true,
      onClickCloseIcon: _ctx.closeIcon,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      onClickOverlay: _ctx.close
    }, {
      default: withCtx(() => [
        createElementVNode("view", _hoisted_1$n, toDisplayString(_ctx.title), 1),
        createElementVNode("view", _hoisted_2$k, toDisplayString(_ctx.desc), 1),
        createElementVNode("div", _hoisted_3$h, [
          withDirectives(createElementVNode("input", {
            ref: "realpwd",
            class: "nut-input-real",
            type: "number",
            maxlength: "6",
            style: normalizeStyle(_ctx.systemStyle()),
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.realInput = $event),
            onInput: _cache[1] || (_cache[1] = (...args) => _ctx.changeValue && _ctx.changeValue(...args))
          }, null, 36), [
            [vModelText, _ctx.realInput]
          ]),
          _hoisted_4$e,
          createElementVNode("view", {
            class: "nut-shortpsd-fake",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.focus && _ctx.focus(...args))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(new Array(_ctx.comLen), (sublen, index) => {
              return openBlock(), createElementBlock("view", {
                class: "nut-shortpsd-li",
                key: index
              }, [
                String(_ctx.realInput).length > index ? (openBlock(), createElementBlock("view", _hoisted_5$9)) : createCommentVNode("", true)
              ]);
            }), 128))
          ])
        ]),
        createElementVNode("view", _hoisted_6$7, [
          createElementVNode("view", _hoisted_7$6, toDisplayString(_ctx.errorMsg), 1),
          _ctx.tips ? (openBlock(), createElementBlock("view", _hoisted_8$6, [
            createVNode(_component_nut_icon, {
              class: "icon",
              size: "11px",
              name: "tips"
            }),
            createElementVNode("view", {
              onClick: _cache[3] || (_cache[3] = (...args) => _ctx.onTips && _ctx.onTips(...args))
            }, toDisplayString(_ctx.tips), 1)
          ])) : createCommentVNode("", true)
        ]),
        !_ctx.noButton ? (openBlock(), createElementBlock("view", _hoisted_9$4, [
          createElementVNode("view", {
            class: "nut-shortpsd-cancle",
            onClick: _cache[4] || (_cache[4] = (...args) => _ctx.close && _ctx.close(...args))
          }, "\u53D6\u6D88"),
          createElementVNode("view", {
            class: "nut-shortpsd-sure",
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.sureClick && _ctx.sureClick(...args))
          }, "\u786E\u8BA4")
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["visible", "onClickCloseIcon", "close-on-click-overlay", "onClickOverlay"])
  ]);
}
var ShortPassword = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
const { componentName: componentName$i, create: create$p } = createComponent("textarea");
const _sfc_main$p = create$p({
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    textAlign: {
      type: String,
      default: "left"
    },
    limitShow: {
      type: Boolean,
      default: false
    },
    maxLength: {
      type: [String, Number],
      default: ""
    },
    rows: {
      type: [String, Number],
      default: ""
    },
    placeholder: {
      type: String,
      default: "\u8BF7\u8F93\u5165\u5185\u5BB9"
    },
    readonly: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    autosize: {
      type: Boolean,
      default: false
    },
    autofocus: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:modelValue", "change", "blur", "focus"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$i;
      return {
        [prefixCls]: true,
        [`${prefixCls}--disabled`]: props.disabled
      };
    });
    const styles = computed(() => {
      return {
        textAlign: props.textAlign,
        resize: props.autosize ? "vertical" : "none"
      };
    });
    const emitChange = (value, event) => {
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.substring(0, Number(props.maxLength));
      }
      emit("update:modelValue", value, event);
      emit("change", value, event);
    };
    const change = (event) => {
      const input = event.target;
      emitChange(input.value, event);
    };
    const focus = (event) => {
      if (props.disabled)
        return;
      if (props.readonly)
        return;
      emit("focus", event);
    };
    const blur = (event) => {
      if (props.disabled)
        return;
      if (props.readonly)
        return;
      const input = event.target;
      let value = input.value;
      emitChange(value, event);
      emit("blur", { value, event });
    };
    return {
      classes,
      styles,
      change,
      focus,
      blur
    };
  }
});
const _hoisted_1$m = ["rows", "disabled", "readonly", "value", "maxlength", "placeholder", "autofocus"];
const _hoisted_2$j = {
  key: 0,
  class: "nut-textarea__limit"
};
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("textarea", {
      class: "nut-textarea__textarea",
      style: normalizeStyle(_ctx.styles),
      rows: _ctx.rows,
      disabled: _ctx.disabled,
      readonly: _ctx.readonly,
      value: _ctx.modelValue,
      onInput: _cache[0] || (_cache[0] = (...args) => _ctx.change && _ctx.change(...args)),
      onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.blur && _ctx.blur(...args)),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.focus && _ctx.focus(...args)),
      maxlength: _ctx.maxLength,
      placeholder: _ctx.placeholder,
      autofocus: _ctx.autofocus
    }, null, 44, _hoisted_1$m),
    _ctx.limitShow ? (openBlock(), createElementBlock("view", _hoisted_2$j, toDisplayString(_ctx.modelValue ? _ctx.modelValue.length : 0) + "/" + toDisplayString(_ctx.maxLength), 1)) : createCommentVNode("", true)
  ], 2);
}
var TextArea = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p]]);
class UploadOptions {
  constructor() {
    __publicField(this, "url", "");
    __publicField(this, "name", "file");
    __publicField(this, "formData");
    __publicField(this, "method", "post");
    __publicField(this, "xhrState", 200);
    __publicField(this, "timeout", 30 * 1e3);
    __publicField(this, "headers", {});
    __publicField(this, "withCredentials", false);
    __publicField(this, "onStart");
    __publicField(this, "taroFilePath");
    __publicField(this, "onProgress");
    __publicField(this, "onSuccess");
    __publicField(this, "onFailure");
  }
}
class Uploader$1 {
  constructor(options) {
    __publicField(this, "options");
    this.options = options;
  }
  upload() {
    var _a;
    const options = this.options;
    const xhr = new XMLHttpRequest();
    xhr.timeout = options.timeout;
    if (xhr.upload) {
      xhr.upload.addEventListener("progress", (e) => {
        var _a2;
        (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, e, options);
      }, false);
      xhr.onreadystatechange = () => {
        var _a2, _b;
        if (xhr.readyState === 4) {
          if (xhr.status == options.xhrState) {
            (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, xhr.responseText, options);
          } else {
            (_b = options.onFailure) == null ? void 0 : _b.call(options, xhr.responseText, options);
          }
        }
      };
      xhr.withCredentials = options.withCredentials;
      xhr.open(options.method, options.url, true);
      for (const [key, value] of Object.entries(options.headers)) {
        xhr.setRequestHeader(key, value);
      }
      (_a = options.onStart) == null ? void 0 : _a.call(options, options);
      xhr.send(options.formData);
    } else {
      console.warn("\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 XMLHttpRequest");
    }
  }
  uploadTaro(uploadFile) {
    var _a;
    const options = this.options;
    const uploadTask = uploadFile({
      url: options.url,
      filePath: options.taroFilePath,
      header: __spreadValues({
        "Content-Type": "multipart/form-data"
      }, options.headers),
      formData: options.formData,
      name: options.name,
      success(response) {
        var _a2, _b;
        if (options.xhrState == response.statusCode) {
          (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, response, options);
        } else {
          (_b = options.onFailure) == null ? void 0 : _b.call(options, response, options);
        }
      },
      fail(e) {
        var _a2;
        (_a2 = options.onFailure) == null ? void 0 : _a2.call(options, e, options);
      }
    });
    (_a = options.onStart) == null ? void 0 : _a.call(options, options);
    uploadTask.progress((res) => {
      var _a2;
      (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, res, options);
    });
  }
}
const { componentName: componentName$h, create: create$o } = createComponent("uploader");
class FileItem {
  constructor() {
    __publicField(this, "status", "ready");
    __publicField(this, "message", "\u51C6\u5907\u5B8C\u6210");
    __publicField(this, "uid", new Date().getTime().toString());
    __publicField(this, "name");
    __publicField(this, "url");
    __publicField(this, "type");
    __publicField(this, "percentage", 0);
    __publicField(this, "formData", new FormData());
  }
}
const _sfc_main$o = create$o({
  props: {
    name: { type: String, default: "file" },
    url: { type: String, default: "" },
    timeout: { type: [Number, String], default: 1e3 * 30 },
    fileList: { type: Array, default: () => [] },
    isPreview: { type: Boolean, default: true },
    listType: { type: String, default: "picture" },
    isDeletable: { type: Boolean, default: true },
    method: { type: String, default: "post" },
    capture: { type: Boolean, default: false },
    maximize: { type: [Number, String], default: Number.MAX_VALUE },
    maximum: { type: [Number, String], default: 1 },
    clearInput: { type: Boolean, default: true },
    accept: { type: String, default: "*" },
    headers: { type: Object, default: {} },
    data: { type: Object, default: {} },
    uploadIcon: { type: String, default: "photograph" },
    uploadIconSize: { type: [String, Number], default: "" },
    xhrState: { type: [Number, String], default: 200 },
    withCredentials: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    autoUpload: { type: Boolean, default: true },
    beforeUpload: {
      type: Function,
      default: null
    },
    beforeDelete: {
      type: Function,
      default: (file, files) => {
        return true;
      }
    },
    onChange: { type: Function }
  },
  emits: [
    "start",
    "progress",
    "oversize",
    "success",
    "failure",
    "change",
    "delete",
    "update:fileList",
    "file-item-click"
  ],
  setup(props, { emit }) {
    const fileList = reactive(props.fileList);
    let uploadQueue = [];
    const classes = computed(() => {
      const prefixCls = componentName$h;
      return {
        [prefixCls]: true
      };
    });
    const clearInput = (el) => {
      el.value = "";
    };
    const fileItemClick = (fileItem) => {
      emit("file-item-click", { fileItem });
    };
    const executeUpload = (fileItem, index) => {
      const uploadOption = new UploadOptions();
      uploadOption.url = props.url;
      uploadOption.formData = fileItem.formData;
      uploadOption.timeout = props.timeout * 1;
      uploadOption.method = props.method;
      uploadOption.xhrState = props.xhrState;
      uploadOption.headers = props.headers;
      uploadOption.withCredentials = props.withCredentials;
      uploadOption.onStart = (option) => {
        fileItem.status = "ready";
        fileItem.message = "\u51C6\u5907\u4E0A\u4F20";
        clearUploadQueue(index);
        emit("start", option);
      };
      uploadOption.onProgress = (event, option) => {
        fileItem.status = "uploading";
        fileItem.message = "\u4E0A\u4F20\u4E2D";
        fileItem.percentage = (event.loaded / event.total * 100).toFixed(0);
        emit("progress", { event, option, percentage: fileItem.percentage });
      };
      uploadOption.onSuccess = (responseText, option) => {
        fileItem.status = "success";
        fileItem.message = "\u4E0A\u4F20\u6210\u529F";
        emit("success", {
          responseText,
          option,
          fileItem
        });
        emit("update:fileList", fileList);
      };
      uploadOption.onFailure = (responseText, option) => {
        fileItem.status = "error";
        fileItem.message = "\u4E0A\u4F20\u5931\u8D25";
        emit("failure", {
          responseText,
          option,
          fileItem
        });
      };
      let task = new Uploader$1(uploadOption);
      if (props.autoUpload) {
        task.upload();
      } else {
        uploadQueue.push(new Promise((resolve, reject) => {
          resolve(task);
        }));
      }
    };
    const clearUploadQueue = (index = -1) => {
      if (index > -1) {
        uploadQueue.splice(index, 1);
      } else {
        uploadQueue = [];
      }
    };
    const submit = () => {
      Promise.all(uploadQueue).then((res) => {
        res.forEach((i) => i.upload());
      });
    };
    const readFile = (files) => {
      files.forEach((file, index) => {
        const formData = new FormData();
        for (const [key, value] of Object.entries(props.data)) {
          formData.append(key, value);
        }
        formData.append(props.name, file);
        const fileItem = reactive(new FileItem());
        fileItem.name = file.name;
        fileItem.status = "ready";
        fileItem.type = file.type;
        fileItem.formData = formData;
        fileItem.message = "\u7B49\u5F85\u4E0A\u4F20";
        executeUpload(fileItem, index);
        if (props.isPreview && file.type.includes("image")) {
          const reader = new FileReader();
          reader.onload = (event) => {
            fileItem.url = event.target.result;
            fileList.push(fileItem);
          };
          reader.readAsDataURL(file);
        } else {
          fileList.push(fileItem);
        }
      });
    };
    const filterFiles = (files) => {
      const maximum = props.maximum * 1;
      const maximize = props.maximize * 1;
      const oversizes = new Array();
      files = files.filter((file) => {
        if (file.size > maximize) {
          oversizes.push(file);
          return false;
        } else {
          return true;
        }
      });
      if (oversizes.length) {
        emit("oversize", oversizes);
      }
      let currentFileLength = files.length + fileList.length;
      if (currentFileLength > maximum) {
        files.splice(files.length - (currentFileLength - maximum));
      }
      return files;
    };
    const onDelete = (file, index) => {
      clearUploadQueue(index);
      if (props.beforeDelete(file, fileList)) {
        fileList.splice(index, 1);
        emit("delete", {
          file,
          fileList,
          index
        });
      } else {
        console.log("\u7528\u6237\u963B\u6B62\u4E86\u5220\u9664\uFF01");
      }
    };
    const onChange = (event) => {
      if (props.disabled) {
        return;
      }
      const $el = event.target;
      let { files } = $el;
      if (props.beforeUpload) {
        props.beforeUpload(files).then((f) => {
          const _files = filterFiles(new Array().slice.call(f));
          readFile(_files);
        });
      } else {
        const _files = filterFiles(new Array().slice.call(files));
        readFile(_files);
      }
      emit("change", {
        fileList,
        event
      });
      if (props.clearInput) {
        clearInput($el);
      }
    };
    return {
      onChange,
      onDelete,
      fileList,
      classes,
      fileItemClick,
      clearUploadQueue,
      submit
    };
  }
});
const _hoisted_1$l = {
  key: 0,
  class: "nut-uploader__slot"
};
const _hoisted_2$i = ["accept", "multiple", "name", "disabled"];
const _hoisted_3$g = ["accept", "multiple", "name", "disabled"];
const _hoisted_4$d = {
  key: 0,
  class: "nut-uploader__preview-img"
};
const _hoisted_5$8 = {
  key: 0,
  class: "nut-uploader__preview__progress"
};
const _hoisted_6$6 = { class: "nut-uploader__preview__progress__msg" };
const _hoisted_7$5 = {
  key: 1,
  class: "nut-uploader__preview__progress"
};
const _hoisted_8$5 = { class: "nut-uploader__preview__progress__msg" };
const _hoisted_9$3 = ["onClick", "src"];
const _hoisted_10$2 = {
  key: 4,
  class: "nut-uploader__preview-img__file"
};
const _hoisted_11$2 = ["onClick"];
const _hoisted_12$2 = { class: "tips" };
const _hoisted_13$1 = {
  key: 1,
  class: "nut-uploader__preview-list"
};
const _hoisted_14$1 = ["onClick"];
const _hoisted_15$1 = ["accept", "multiple", "name", "disabled"];
const _hoisted_16$1 = ["accept", "multiple", "name", "disabled"];
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_progress = resolveComponent("nut-progress");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    _ctx.$slots.default ? (openBlock(), createElementBlock("view", _hoisted_1$l, [
      renderSlot(_ctx.$slots, "default"),
      _ctx.maximum - _ctx.fileList.length ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        _ctx.capture ? (openBlock(), createElementBlock("input", {
          key: 0,
          class: "nut-uploader__input",
          type: "file",
          capture: "camera",
          accept: _ctx.accept,
          multiple: _ctx.multiple,
          name: _ctx.name,
          disabled: _ctx.disabled,
          onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onChange && _ctx.onChange(...args))
        }, null, 40, _hoisted_2$i)) : (openBlock(), createElementBlock("input", {
          key: 1,
          class: "nut-uploader__input",
          type: "file",
          accept: _ctx.accept,
          multiple: _ctx.multiple,
          name: _ctx.name,
          disabled: _ctx.disabled,
          onChange: _cache[1] || (_cache[1] = (...args) => _ctx.onChange && _ctx.onChange(...args))
        }, null, 40, _hoisted_3$g))
      ], 64)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.fileList, (item, index) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(["nut-uploader__preview", [_ctx.listType]]),
        key: item.uid
      }, [
        _ctx.listType == "picture" && !_ctx.$slots.default ? (openBlock(), createElementBlock("view", _hoisted_4$d, [
          item.status == "ready" ? (openBlock(), createElementBlock("view", _hoisted_5$8, [
            createElementVNode("view", _hoisted_6$6, toDisplayString(item.message), 1)
          ])) : item.status != "success" ? (openBlock(), createElementBlock("view", _hoisted_7$5, [
            createVNode(_component_nut_icon, {
              color: "#fff",
              name: item.status == "error" ? "failure" : "loading"
            }, null, 8, ["name"]),
            createElementVNode("view", _hoisted_8$5, toDisplayString(item.message), 1)
          ])) : createCommentVNode("", true),
          _ctx.isDeletable ? (openBlock(), createBlock(_component_nut_icon, {
            key: 2,
            color: "rgba(0,0,0,0.6)",
            onClick: ($event) => _ctx.onDelete(item, index),
            class: "close",
            name: "failure"
          }, null, 8, ["onClick"])) : createCommentVNode("", true),
          item.type.includes("image") && item.url ? (openBlock(), createElementBlock("img", {
            key: 3,
            class: "nut-uploader__preview-img__c",
            onClick: ($event) => _ctx.fileItemClick(item),
            src: item.url
          }, null, 8, _hoisted_9$3)) : (openBlock(), createElementBlock("view", _hoisted_10$2, [
            createElementVNode("view", {
              onClick: ($event) => _ctx.fileItemClick(item),
              class: "nut-uploader__preview-img__file__name"
            }, [
              createVNode(_component_nut_icon, {
                color: "#808080",
                name: "link"
              }),
              createTextVNode("\xA0" + toDisplayString(item.name), 1)
            ], 8, _hoisted_11$2)
          ])),
          createElementVNode("view", _hoisted_12$2, toDisplayString(item.name), 1)
        ])) : _ctx.listType == "list" ? (openBlock(), createElementBlock("view", _hoisted_13$1, [
          createElementVNode("view", {
            onClick: ($event) => _ctx.fileItemClick(item),
            class: normalizeClass(["nut-uploader__preview-img__file__name", [item.status]])
          }, [
            createVNode(_component_nut_icon, { name: "link" }),
            createTextVNode("\xA0" + toDisplayString(item.name), 1)
          ], 10, _hoisted_14$1),
          createVNode(_component_nut_icon, {
            class: "nut-uploader__preview-img__file__del",
            onClick: ($event) => _ctx.onDelete(item, index),
            color: "#808080",
            name: "del"
          }, null, 8, ["onClick"]),
          item.status == "uploading" ? (openBlock(), createBlock(_component_nut_progress, {
            key: 0,
            size: "small",
            percentage: item.percentage,
            "stroke-color": "linear-gradient(270deg, rgba(18,126,255,1) 0%,rgba(32,147,255,1) 32.815625%,rgba(13,242,204,1) 100%)",
            "show-text": false
          }, null, 8, ["percentage"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2);
    }), 128)),
    _ctx.listType == "picture" && !_ctx.$slots.default && _ctx.maximum - _ctx.fileList.length ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass(["nut-uploader__upload", [_ctx.listType]])
    }, [
      createVNode(_component_nut_icon, {
        size: _ctx.uploadIconSize,
        color: "#808080",
        name: _ctx.uploadIcon
      }, null, 8, ["size", "name"]),
      _ctx.capture ? (openBlock(), createElementBlock("input", {
        key: 0,
        class: "nut-uploader__input",
        type: "file",
        capture: "camera",
        accept: _ctx.accept,
        multiple: _ctx.multiple,
        name: _ctx.name,
        disabled: _ctx.disabled,
        onChange: _cache[2] || (_cache[2] = (...args) => _ctx.onChange && _ctx.onChange(...args))
      }, null, 40, _hoisted_15$1)) : (openBlock(), createElementBlock("input", {
        key: 1,
        class: "nut-uploader__input",
        type: "file",
        accept: _ctx.accept,
        multiple: _ctx.multiple,
        name: _ctx.name,
        disabled: _ctx.disabled,
        onChange: _cache[3] || (_cache[3] = (...args) => _ctx.onChange && _ctx.onChange(...args))
      }, null, 40, _hoisted_16$1))
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var Uploader = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
function useExtend(apis) {
  const instance = getCurrentInstance();
  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
const { componentName: componentName$g, create: create$n } = createComponent("countup");
const _sfc_main$n = create$n({
  props: {
    initNum: {
      type: Number,
      default: 0
    },
    endNum: {
      type: Number,
      default: 0
    },
    speed: {
      type: Number,
      default: 1
    },
    toFixed: {
      type: Number,
      default: 0
    },
    during: {
      type: Number,
      default: 1e3
    },
    startFlag: {
      type: Boolean,
      default: true
    },
    numWidth: {
      type: Number,
      default: 20
    },
    numHeight: {
      type: Number,
      default: 20
    },
    scrolling: {
      type: Boolean,
      default: false
    },
    customBgImg: {
      type: String,
      default: ""
    },
    customSpacNum: {
      type: Number,
      default: 0
    },
    customChangeNum: {
      type: Number,
      default: 1
    },
    type: {
      type: String,
      default: ""
    },
    machineNum: {
      type: Number,
      default: 3
    },
    machinePrizeNum: {
      type: Number,
      default: 0
    },
    machinePrizeLevel: {
      type: Number,
      default: 0
    },
    machineTrunMore: {
      type: Number,
      default: 0
    }
  },
  components: {},
  emits: ["click", "scroll-end"],
  setup(props, { emit }) {
    const data = reactive({
      valFlag: false,
      current: 0,
      sortFlag: "add",
      initDigit1: 0,
      initDigit2: 0,
      to0_10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
      to10_0: [0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1],
      timer: null,
      totalCount: 0,
      pointNum: 0,
      numberVal: 0,
      num_total_len: 0,
      relNum: 0,
      customNumber: 1,
      prizeLevelTrun: 0,
      prizeY: [],
      prizeYPrev: [],
      finshMachine: 0,
      notPrize: [],
      typeMachine: ""
    });
    const { startFlag, scrolling, customBgImg, type } = reactive(props);
    watch(() => props.customChangeNum, (count2, prevCount) => {
      clearIntervalTime();
      countGo(0);
    });
    watch(() => props.machinePrizeLevel, (count2, prevCount) => {
      data.prizeLevelTrun = count2;
    });
    watch(() => props.initNum, (count2, prevCount) => {
      data.current = count2;
      data.valFlag = false;
      valChange();
    });
    watch(() => props.endNum, (count2, prevCount) => {
      data.current = props.initNum;
      data.valFlag = false;
      valChange();
    });
    const valChange = () => {
      if (data.valFlag) {
        return false;
      }
      if (startFlag) {
        if (scrolling || customBgImg) {
          if (type != "machine") {
            countGo();
          }
        } else {
          countChange();
          setTimeout(() => {
            data.valFlag = true;
          }, 300);
        }
      }
    };
    const clearIntervalTime = () => {
      clearInterval(Number(data.timer));
      data.timer = null;
    };
    const calculation = (num1, num2, type2) => {
      const num1Digits = (num1.toString().split(".")[1] || "").length;
      const num2Digits = (num2.toString().split(".")[1] || "").length;
      const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
      if (type2 == "-") {
        const n = Number((num1 * baseNum - num2 * baseNum).toFixed(0));
        return n / baseNum;
      } else {
        const m = Number((num1 * baseNum + num2 * baseNum).toFixed(0));
        return m / baseNum;
      }
    };
    const topNumber = (index) => {
      let { num_total_len, pointNum, initDigit1, initDigit2, sortFlag } = data;
      let idx1 = sortFlag == "add" || sortFlag == "equal" ? String(initDigit2)[index - (num_total_len - pointNum)] : 10 - Number(String(initDigit2)[index - (num_total_len - pointNum)]);
      let idx2 = sortFlag == "add" || sortFlag == "equal" ? String(initDigit1)[index] : 10 - Number(String(initDigit1)[index]);
      let num = index > num_total_len - pointNum - 1 ? -idx1 * 100 + "%" : index <= String(initDigit1).length - 1 ? -idx2 * 100 + "%" : 0;
      if (num == "-1000%") {
        num = 0;
      }
      return num;
    };
    const turnNumber = (index) => {
      let { num_total_len, pointNum, initDigit1, initDigit2, sortFlag } = data;
      let idx1 = String(initDigit2)[index - (num_total_len - pointNum)];
      let num = index > num_total_len - pointNum - 1 ? idx1 ? idx1 : 0 : index <= String(initDigit1).length - 1 ? String(initDigit1)[index] : 0;
      return num;
    };
    const countChange = () => {
      let { endNum, initNum, speed, toFixed } = props;
      let countTimer = setInterval(() => {
        if (initNum > endNum) {
          if (data.current <= endNum || data.current <= speed) {
            data.current = Number(endNum.toFixed(toFixed));
            clearInterval(countTimer);
            emit("scroll-end");
            data.valFlag = false;
          } else {
            data.current = Number((parseFloat(String(data.current)) - parseFloat(String(speed))).toFixed(toFixed));
          }
        } else {
          if (data.current >= endNum) {
            data.current = Number(endNum.toFixed(toFixed));
            clearInterval(countTimer);
            emit("scroll-end");
            data.valFlag = false;
          } else {
            data.current = Number((parseFloat(String(data.current)) + parseFloat(String(speed))).toFixed(toFixed));
          }
        }
      }, props.during);
    };
    const countGo = (flag) => {
      let { initNum, endNum, toFixed, customBgImg: customBgImg2 } = props;
      if (customBgImg2) {
        initNum = props.customChangeNum;
      }
      let startNumber1, startNumber2, endNumber1, endNumber2;
      if (initNum != 0) {
        if (toFixed != 0) {
          initNum = Number(initNum.toFixed(toFixed));
        }
        if (String(initNum).indexOf(".") > -1) {
          startNumber1 = String(initNum).split(".")[0].length;
          startNumber2 = String(initNum).split(".")[1].length;
        } else {
          startNumber1 = String(initNum).length;
          startNumber2 = 0;
        }
      } else {
        startNumber1 = 1;
        startNumber2 = 0;
      }
      if (endNum != 0) {
        if (toFixed != 0) {
          endNum = Number(endNum.toFixed(toFixed));
        }
        if (String(endNum).indexOf(".") > -1) {
          endNumber1 = String(endNum).split(".")[0].length;
          endNumber2 = String(endNum).split(".")[1].length;
        } else {
          endNumber1 = String(endNum).length;
          endNumber2 = 0;
        }
      } else {
        endNumber1 = 1;
        endNumber2 = 0;
      }
      let len1 = startNumber1 >= endNumber1 ? startNumber1 : endNumber1;
      let len2 = startNumber2 >= endNumber2 ? startNumber2 : endNumber2;
      data.num_total_len = len1 + len2;
      data.pointNum = len2;
      if (initNum > endNum) {
        data.sortFlag = "reduce";
        data.to0_10 = [0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        data.totalCount = calculation(initNum, endNum, "-");
        data.numberVal = Number(String(initNum));
      } else if (initNum < endNum) {
        data.sortFlag = "add";
        data.to0_10 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
        data.totalCount = calculation(endNum, initNum, "-");
        data.numberVal = Number(String(endNum));
      } else {
        data.sortFlag = "equal";
      }
      var unit = 1;
      for (let i = 0; i < data.pointNum; i++) {
        unit *= 10;
      }
      var rel_big = data.numberVal * unit;
      data.relNum = rel_big;
      if (toFixed != 0) {
        data.pointNum = String(data.numberVal).split(".")[1] ? String(data.numberVal).split(".")[1].length : 0;
        data.num_total_len = String(rel_big).length;
      }
      if (String(initNum).indexOf(".") > -1) {
        let n = String(initNum).split(".");
        data.initDigit1 = Number(n[0]);
        data.initDigit2 = Number(n[1]);
      } else {
        data.initDigit1 = initNum;
        data.initDigit2 = 0;
      }
      if (scrolling && !customBgImg2) {
        nextTick(() => {
          if (data.sortFlag == "equal") {
            return false;
          }
          let refsDom = document.getElementsByClassName("numberItem");
          let element = refsDom[data.num_total_len - 1];
          runTurn(element);
        });
      } else {
        if (flag !== 0) {
          imgNumberScroll();
        }
      }
    };
    const runTurn = (el) => {
      clearIntervalTime();
      var m = 1;
      if (data.pointNum != 0) {
        m = 1 / Math.pow(10, data.pointNum);
      }
      data.timer = setInterval(() => {
        runStep(el);
        data.totalCount = calculation(data.totalCount, m, "-");
        if (data.totalCount <= 0) {
          clearIntervalTime();
          emit("scroll-end");
          data.valFlag = false;
        }
      }, props.during);
    };
    const runStep = (el) => {
      let currentTurn = el.getAttribute("turn-number");
      let turningNum;
      if (data.sortFlag == "add") {
        turningNum = parseInt(String(currentTurn)) + 1;
      } else {
        turningNum = parseInt(String(currentTurn)) - 1 >= 0 ? parseInt(String(currentTurn)) - 1 : 9;
      }
      el.setAttribute("turn-number", String(turningNum));
      if (el.style.transition == "none 0s ease 0s" || turningNum == 1 || !el.style.transition) {
        el.style.transition = `all linear ${props.during}ms`;
      }
      if (turningNum == 10 || data.sortFlag == "reduce" && turningNum == 0) {
        var timeOut = null;
        el.style.top = `-${data.sortFlag == "add" ? turningNum * 100 : (10 - turningNum) * 100}%`;
        el.setAttribute("turn-number", "0");
        timeOut = setTimeout(() => {
          timeOut && clearTimeout(timeOut);
          el.style.transition = "none";
          el.style.top = "0";
          if (turningNum == 10) {
            if (el.previousSibling) {
              runStep(el.previousSibling);
            }
          }
        }, 0.975 * props.during);
      } else {
        el.style.top = `-${data.sortFlag == "add" ? turningNum * 100 : (10 - turningNum) * 100}%`;
      }
      if (el.style.top == "-100%" && data.sortFlag == "reduce") {
        runStep(el.previousSibling);
      }
    };
    const imgNumberScroll = () => {
      if (data.pointNum != 0) {
        Math.pow(10, data.pointNum);
      }
      nextTick(() => {
        let f = document.getElementsByClassName("run-number-img")[0];
        f.addEventListener("webkitTransitionEnd", () => {
          emit("scroll-end");
          data.valFlag = false;
        });
      });
    };
    const generateRandom = () => {
      data.notPrize = [];
      while (data.notPrize.length < 3) {
        var rand = Math.floor(Math.random() * props.machinePrizeNum + 1);
        if (data.notPrize.indexOf(rand) == -1) {
          data.notPrize.push(rand);
        }
      }
    };
    const machineLuck = () => {
      const machineTrunMoreNum = props.machineTrunMore < 0 ? 0 : props.machineTrunMore;
      let distance = props.numHeight * props.machinePrizeNum;
      if (data.prizeLevelTrun < 0) {
        generateRandom();
      }
      for (let i = 0; i < props.machineNum; i++) {
        setTimeout(() => {
          let turn = distance * (i + 1 + parseFloat(String(machineTrunMoreNum)));
          if (data.prizeYPrev.length != 0) {
            data.prizeY[i] = data.prizeYPrev[i];
          }
          let local = data.prizeYPrev[i] ? data.prizeYPrev[i] : 0;
          let newLocation = turn + local + (props.machinePrizeNum - data.prizeLevelTrun + 1) * props.numHeight + (distance - local);
          if (data.prizeLevelTrun < 0) {
            newLocation += props.numHeight * data.notPrize[i];
          }
          scrollTime(i, newLocation, local);
        }, 500 * i);
      }
    };
    useExtend({ machineLuck });
    const scrollTime = (index, total, num) => {
      let t = setInterval(() => {
        if (num <= total) {
          num += 10;
          data.prizeY[index] = parseFloat(String(num));
        } else {
          clearInterval(t);
          t = null;
          data.finshMachine += 1;
          data.prizeY[index] = total;
          if (data.finshMachine == props.machineNum) {
            let distance = props.numHeight * props.machinePrizeNum;
            data.prizeYPrev = [];
            let prevAry = JSON.parse(JSON.stringify(data.prizeY));
            prevAry.forEach((item) => {
              let n = item;
              while (n > distance) {
                n -= distance;
              }
              data.prizeYPrev.push(n);
            });
            setTimeout(() => {
              data.finshMachine = 0;
              if (data.prizeLevelTrun < 0) {
                emit("scroll-end", false);
                data.valFlag = false;
              } else {
                emit("scroll-end", true);
                data.valFlag = false;
              }
            }, 130);
          }
        }
      }, 30);
    };
    onMounted(() => {
      data.current = props.initNum;
      nextTick(() => {
        valChange();
      });
    });
    onUnmounted(() => {
      clearIntervalTime();
      data.timer = null;
    });
    return __spreadProps(__spreadValues(__spreadValues({}, toRefs(data)), toRefs(reactive(props))), {
      topNumber,
      turnNumber
    });
  }
});
const _hoisted_1$k = { class: "nut-countup" };
const _hoisted_2$h = ["turn-number"];
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$k, [
    _ctx.customBgImg != "" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.type == "machine" ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "run-number-machine-img",
        style: normalizeStyle({ height: _ctx.numHeight + "px" })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.machineNum, (val, index) => {
          return openBlock(), createElementBlock("view", {
            class: "run-number-machine-img-li",
            ref_for: true,
            ref: "run-number-machine-img-li",
            key: "mImg" + index,
            style: normalizeStyle({
              width: _ctx.numWidth + "px",
              height: _ctx.numHeight + "px",
              backgroundImage: "url(" + _ctx.customBgImg + ")",
              backgroundPositionY: _ctx.prizeY[index] + "px"
            })
          }, null, 4);
        }), 128))
      ], 4)) : (openBlock(), createElementBlock("view", {
        key: 1,
        class: "run-number-img",
        style: normalizeStyle({ height: _ctx.numHeight + "px" })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.num_total_len, (val, index) => {
          return openBlock(), createElementBlock("view", {
            class: "run-number-img-li",
            key: "cImg" + index,
            style: normalizeStyle({
              width: _ctx.numWidth + "px",
              height: _ctx.numHeight + "px",
              left: _ctx.numWidth * (index > _ctx.num_total_len - _ctx.pointNum - 1 ? index == _ctx.num_total_len - _ctx.pointNum ? index * 1.5 : index * 1.3 : index) + "px",
              backgroundImage: "url(" + _ctx.customBgImg + ")",
              backgroundPosition: "0 " + -(String(_ctx.relNum)[index] * _ctx.numHeight + _ctx.customSpacNum * String(_ctx.relNum)[index]) + "px",
              transition: "all linear " + _ctx.during / 10 + "ms"
            })
          }, null, 4);
        }), 128)),
        _ctx.pointNum > 0 ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "pointstyl",
          style: normalizeStyle({
            width: _ctx.numWidth / 2 + "px",
            bottom: 0,
            left: _ctx.numWidth * (_ctx.num_total_len - _ctx.pointNum) * 1.1 + "px",
            fontSize: "30px"
          })
        }, ".", 4)) : createCommentVNode("", true)
      ], 4))
    ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      _ctx.scrolling ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "run-number",
        style: normalizeStyle({
          width: _ctx.numWidth * _ctx.num_total_len + _ctx.numWidth / 3 + "px",
          height: _ctx.numHeight + "px",
          lineHeight: _ctx.numHeight + "px"
        })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.num_total_len, (val, index) => {
          return openBlock(), createElementBlock("view", {
            ref_for: true,
            ref: "numberItem",
            class: "numberItem",
            key: val,
            style: normalizeStyle({
              top: _ctx.topNumber(index),
              left: _ctx.numWidth * (index > _ctx.num_total_len - _ctx.pointNum - 1 ? index * 1.1 : index) + "px"
            }),
            "turn-number": _ctx.turnNumber(index)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.to0_10, (item, idx) => {
              return openBlock(), createElementBlock("view", {
                class: "itemSpan",
                key: "dote" + idx,
                style: normalizeStyle({
                  width: _ctx.numWidth + "px",
                  height: _ctx.numHeight + "px",
                  lineHeight: _ctx.numHeight + "px"
                })
              }, toDisplayString(item), 5);
            }), 128))
          ], 12, _hoisted_2$h);
        }), 128)),
        _ctx.pointNum > 0 ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "pointstyl",
          style: normalizeStyle({
            width: _ctx.numWidth / 3 + "px",
            height: _ctx.numHeight + "px",
            lineHeight: _ctx.numHeight + "px",
            top: 0,
            left: _ctx.numWidth * (_ctx.num_total_len - _ctx.pointNum) + "px"
          })
        }, ".", 4)) : createCommentVNode("", true)
      ], 4)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.current), 1)
      ], 64))
    ], 64))
  ]);
}
var CountUp = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n]]);
const { create: create$m } = createComponent("numberkeyboard");
const _sfc_main$m = create$m({
  props: {
    title: {
      type: String,
      default: ""
    },
    visible: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "default"
    },
    customKey: {
      type: Array,
      default: () => []
    },
    value: {
      type: String,
      default: ""
    },
    maxlength: {
      type: [Number, String],
      default: 6
    },
    randomKeys: {
      type: Boolean,
      default: false
    },
    overlay: {
      type: Boolean,
      default: true
    }
  },
  emits: ["input", "delete", "close", "update:value"],
  setup(props, { emit }) {
    console.log(props.overlay);
    const clickKeyIndex = ref(void 0);
    const show = ref(props.visible);
    const root = ref();
    function defaultKey() {
      return [
        ...getBasicKeys(),
        { id: "lock", type: "lock" },
        { id: 0, type: "number" },
        { id: "delete", type: "delete" }
      ];
    }
    function getBasicKeys() {
      const keys = [];
      for (let i = 1; i <= 9; i++) {
        keys.push({ id: i, type: "number" });
      }
      if (props.randomKeys) {
        return keys.sort(() => Math.random() > 0.5 ? 1 : -1);
      }
      return keys;
    }
    function genCustomKeys() {
      const keys = getBasicKeys();
      const { customKey } = props;
      let customKeys = Array.isArray(customKey) ? customKey : [customKey];
      if (customKeys.length > 2) {
        customKeys = [customKeys[0], customKeys[1]];
      }
      if (customKeys.length === 1) {
        if (props.title) {
          keys.push({ id: customKeys[0], type: "custom" }, { id: 0, type: "number" }, { id: "delete", type: "delete" });
        } else {
          keys.push({ id: 0, type: "number" }, { id: customKeys[0], type: "custom" });
        }
      } else if (customKeys.length === 2) {
        keys.push({ id: customKeys[0], type: "custom" }, { id: 0, type: "number" }, { id: customKeys[1], type: "custom" });
        if (props.title) {
          keys.push({ id: "delete", type: "delete" });
        }
      } else {
        keys.push({ id: 0, type: "number" });
      }
      return keys;
    }
    const keysList = computed(() => {
      if (props.type == "rightColumn" || props.title != "") {
        return genCustomKeys();
      }
      return defaultKey();
    });
    watch(() => props.visible, (value) => {
      show.value = value;
    });
    function onTouchstart(item, event) {
      event.stopPropagation();
      clickKeyIndex.value = item.id;
      if (item.type == "number" || item.type == "custom") {
        emit("input", item.id);
        if (props.value.length < props.maxlength) {
          emit("update:value", props.value + item.id);
        }
      }
      if (item.type == "lock") {
        closeBoard();
      }
      if (item.type == "delete") {
        emit("delete");
        emit("update:value", props.value.slice(0, props.value.length - 1));
      }
    }
    function onTouchMove(id, event) {
      event.stopPropagation();
    }
    function onTouchEnd() {
      clickKeyIndex.value = void 0;
    }
    function closeBoard() {
      emit("close");
    }
    onMounted(() => {
    });
    return {
      clickKeyIndex,
      defaultKey,
      closeBoard,
      onTouchEnd,
      onTouchMove,
      onTouchstart,
      keysList,
      genCustomKeys,
      getBasicKeys,
      root,
      show
    };
  }
});
const _hoisted_1$j = {
  class: "nut-numberkeyboard",
  ref: "root"
};
const _hoisted_2$g = {
  key: 0,
  class: "number-board-header"
};
const _hoisted_3$f = { class: "tit" };
const _hoisted_4$c = { class: "number-board-body" };
const _hoisted_5$7 = { class: "number-board" };
const _hoisted_6$5 = ["onTouchstart", "onTouchmove"];
const _hoisted_7$4 = {
  key: 1,
  src: "https://img11.360buyimg.com/imagetools/jfs/t1/146371/38/8485/738/5f606425Eca239740/14f4b4f5f20d8a68.png"
};
const _hoisted_8$4 = {
  key: 2,
  src: "https://img11.360buyimg.com/imagetools/jfs/t1/129395/8/12735/2030/5f61ac37E70cab338/fb477dc11f46056c.png"
};
const _hoisted_9$2 = {
  key: 0,
  class: "number-board-sidebar"
};
const _hoisted_10$1 = { class: "key-board-wrapper" };
const _hoisted_11$1 = /* @__PURE__ */ createElementVNode("img", { src: "https://img11.360buyimg.com/imagetools/jfs/t1/129395/8/12735/2030/5f61ac37E70cab338/fb477dc11f46056c.png" }, null, -1);
const _hoisted_12$1 = [
  _hoisted_11$1
];
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.show,
    "onUpdate:visible": _cache[6] || (_cache[6] = ($event) => _ctx.show = $event),
    position: "bottom",
    overlay: _ctx.overlay,
    onClickOverlay: _cache[7] || (_cache[7] = ($event) => _ctx.closeBoard()),
    "overlay-class": "nut-numberkeyboard-overlay"
  }, {
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$j, [
        _ctx.title ? (openBlock(), createElementBlock("div", _hoisted_2$g, [
          createElementVNode("h3", _hoisted_3$f, toDisplayString(_ctx.title), 1),
          createElementVNode("span", {
            class: "keyboard-close",
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.closeBoard())
          }, "\u5B8C\u6210")
        ])) : createCommentVNode("", true),
        createElementVNode("div", _hoisted_4$c, [
          createElementVNode("div", _hoisted_5$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.keysList, (item) => {
              return openBlock(), createElementBlock("div", {
                class: normalizeClass([
                  "key-board-wrapper",
                  {
                    "key-board-wrapper-large": item.id == 0 && _ctx.type == "rightColumn" && Array.isArray(_ctx.customKey) && _ctx.customKey.length == 1
                  }
                ]),
                key: "key" + item.id
              }, [
                createElementVNode("div", {
                  class: normalizeClass([
                    "key",
                    { active: item.id == _ctx.clickKeyIndex },
                    { lock: item.type == "lock" },
                    { delete: item.type == "delete" }
                  ]),
                  onTouchstart: (event) => _ctx.onTouchstart(item, event),
                  onTouchmove: (event) => _ctx.onTouchMove(item, event),
                  onTouchend: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
                }, [
                  item.type == "number" || item.type == "custom" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(item.id), 1)
                  ], 64)) : createCommentVNode("", true),
                  item.type == "lock" ? (openBlock(), createElementBlock("img", _hoisted_7$4)) : createCommentVNode("", true),
                  item.type == "delete" ? (openBlock(), createElementBlock("img", _hoisted_8$4)) : createCommentVNode("", true)
                ], 42, _hoisted_6$5)
              ], 2);
            }), 128))
          ]),
          _ctx.type == "rightColumn" ? (openBlock(), createElementBlock("div", _hoisted_9$2, [
            createElementVNode("div", _hoisted_10$1, [
              createElementVNode("div", {
                class: normalizeClass(["key", { active: _ctx.clickKeyIndex == "delete" }]),
                onTouchstart: _cache[2] || (_cache[2] = (event) => _ctx.onTouchstart({ id: "delete", type: "delete" }, event)),
                onTouchmove: _cache[3] || (_cache[3] = (event) => _ctx.onTouchMove({ id: "delete", type: "delete" }, event)),
                onTouchend: _cache[4] || (_cache[4] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
              }, _hoisted_12$1, 34)
            ]),
            _ctx.title == "" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "key-board-wrapper",
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.closeBoard())
            }, [
              createElementVNode("div", {
                class: normalizeClass(["key", "finish", { activeFinsh: _ctx.clickKeyIndex == "finish" }])
              }, " \u5B8C\u6210 ", 2)
            ])) : createCommentVNode("", true)
          ])) : createCommentVNode("", true)
        ])
      ], 512)
    ]),
    _: 1
  }, 8, ["visible", "overlay"]);
}
var NumberKeyboard = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
const { componentName: componentName$f, create: create$l } = createComponent("countdown");
const _sfc_main$l = create$l({
  props: {
    modelValue: {
      type: Object,
      default: () => {
        return {};
      }
    },
    paused: {
      default: false,
      type: Boolean
    },
    showDays: {
      default: false,
      type: Boolean
    },
    showPlainText: {
      default: false,
      type: Boolean
    },
    startTime: {
      type: [Number, String],
      validator(v) {
        const dateStr = new Date(v).toString().toLowerCase();
        return dateStr !== "invalid date";
      }
    },
    endTime: {
      type: [Number, String],
      validator(v) {
        const dateStr = new Date(v).toString().toLowerCase();
        return dateStr !== "invalid date";
      }
    }
  },
  components: {},
  emits: ["input", "on-end", "on-restart", "on-paused", "update:modelValue"],
  setup(props, { emit, slots }) {
    const state = reactive({
      restTime: 0,
      p: 0,
      _curr: 0,
      timer: null
    });
    const resttime = computed(() => {
      const rest = restTime(state.restTime);
      const { d, h: h2, m, s } = rest;
      if (!props.showDays && d > 0) {
        rest.h = fill2(Number(rest.h) + d * 24);
        rest.d = 0;
      }
      return rest;
    });
    const plainText = computed(() => {
      const { d, h: h2, m, s } = resttime.value;
      return `${d > 0 && props.showDays ? d + "\u5929" + h2 : h2}\u5C0F\u65F6${m}\u5206${s}\u79D2`;
    });
    watch(() => props.value, (value) => {
    });
    watch(() => state.restTime, (value) => {
      let tranTime = restTime(value);
      emit("update:modelValue", tranTime);
      emit("input", tranTime);
    });
    watch(() => props.paused, (v, ov) => {
      if (!ov) {
        state._curr = getTimeStamp();
        emit("on-paused", state.restTime);
      } else {
        state.p += getTimeStamp() - state._curr;
        emit("on-restart", state.restTime);
      }
    });
    watch(() => props.endTime, (value) => {
      initTimer();
    });
    watch(() => props.startTime, (value) => {
      initTimer();
    });
    const classes = computed(() => {
      const prefixCls = componentName$f;
      return {
        [prefixCls]: true
      };
    });
    const getTimeStamp = (timeStr) => {
      if (!timeStr)
        return Date.now();
      let t = timeStr;
      t = t > 0 ? +t : t.toString().replace(/\-/g, "/");
      return new Date(t).getTime();
    };
    const initTimer = () => {
      const delay = 1e3;
      const curr = Date.now();
      const start = getTimeStamp(props.startTime || curr);
      const end = getTimeStamp(props.endTime || curr);
      const diffTime = curr - start;
      state.restTime = end - (start + diffTime);
      state.timer = setInterval(() => {
        if (!props.paused) {
          let restTime2 = end - (Date.now() - state.p + diffTime);
          state.restTime = restTime2;
          if (restTime2 < 0) {
            state.restTime = 0;
            emit("on-end");
            clearInterval(state.timer);
          }
        }
      }, delay);
    };
    const fill2 = (v) => {
      v += "";
      while (v.length < 2) {
        v = "0" + v;
      }
      return v;
    };
    const restTime = (t) => {
      const ts = t;
      let rest = {
        d: "-",
        h: "--",
        m: "--",
        s: "--"
      };
      if (ts === 0) {
        rest = {
          d: "0",
          h: "00",
          m: "00",
          s: "00"
        };
      }
      if (ts) {
        const ds = 24 * 60 * 60 * 1e3;
        const hs = 60 * 60 * 1e3;
        const ms = 60 * 1e3;
        const d = ts >= ds ? parseInt(ts / ds) : 0;
        const h2 = ts - d * ds >= hs ? parseInt((ts - d * ds) / hs) : 0;
        const m = ts - d * ds - h2 * hs >= ms ? parseInt((ts - d * ds - h2 * hs) / ms) : 0;
        const s = Math.round((ts - d * ds - h2 * hs - m * ms) / 1e3);
        if (d >= 0)
          rest.d = d + "";
        if (h2 >= 0)
          rest.h = fill2(h2);
        if (m >= 0)
          rest.m = fill2(m);
        if (s >= 0)
          rest.s = fill2(s);
      }
      return rest;
    };
    initTimer();
    return __spreadProps(__spreadValues({}, toRefs(props)), {
      slots,
      classes,
      getTimeStamp,
      initTimer,
      resttime,
      plainText
    });
  }
});
const _hoisted_1$i = {
  key: 1,
  class: "nut-cd-block"
};
const _hoisted_2$f = { class: "nut-cd-block" };
const _hoisted_3$e = /* @__PURE__ */ createElementVNode("view", { class: "nut-cd-dot" }, "\u5929", -1);
const _hoisted_4$b = { class: "nut-cd-block" };
const _hoisted_5$6 = /* @__PURE__ */ createElementVNode("view", { class: "nut-cd-dot" }, ":", -1);
const _hoisted_6$4 = { class: "nut-cd-block" };
const _hoisted_7$3 = /* @__PURE__ */ createElementVNode("view", { class: "nut-cd-dot" }, ":", -1);
const _hoisted_8$3 = { class: "nut-cd-block" };
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : _ctx.showPlainText ? (openBlock(), createElementBlock("view", _hoisted_1$i, toDisplayString(_ctx.plainText), 1)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
      _ctx.resttime.d >= 0 && _ctx.showDays ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createElementVNode("view", _hoisted_2$f, toDisplayString(_ctx.resttime.d), 1),
        _hoisted_3$e
      ], 64)) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_4$b, toDisplayString(_ctx.resttime.h), 1),
      _hoisted_5$6,
      createElementVNode("view", _hoisted_6$4, toDisplayString(_ctx.resttime.m), 1),
      _hoisted_7$3,
      createElementVNode("view", _hoisted_8$3, toDisplayString(_ctx.resttime.s), 1)
    ], 64))
  ], 2);
}
var CountDown = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
const { create: create$k } = createComponent("badge");
const _sfc_main$k = create$k({
  props: {
    value: {
      type: [String, Number]
    },
    max: {
      type: Number,
      default: 1e4
    },
    dot: {
      type: Boolean,
      default: false
    },
    hidden: {
      type: Boolean,
      default: false
    },
    top: {
      type: String,
      default: "0"
    },
    right: {
      type: String,
      default: "0"
    },
    zIndex: {
      type: Number,
      default: 9
    },
    color: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const state = reactive({});
    const stl = computed(() => {
      return {
        top: `${props.top}px`,
        right: `${props.right}px`,
        zIndex: props.zIndex,
        background: props.color
      };
    });
    const content = computed(() => {
      if (props.dot)
        return;
      const value = props.value;
      const max = props.max;
      if (typeof value === "number" && typeof max === "number") {
        return max < value ? `${max}+` : value;
      }
      return value;
    });
    return {
      state,
      stl,
      content
    };
  }
});
const _hoisted_1$h = { class: "nut-badge" };
const _hoisted_2$e = { class: "slot-icons" };
const _hoisted_3$d = ["textContent"];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$h, [
    createElementVNode("view", _hoisted_2$e, [
      renderSlot(_ctx.$slots, "icons")
    ]),
    renderSlot(_ctx.$slots, "default"),
    withDirectives(createElementVNode("view", {
      textContent: toDisplayString(_ctx.content),
      class: normalizeClass(["nut-badge__content sup", { "is-dot": _ctx.dot }]),
      style: normalizeStyle(_ctx.stl)
    }, null, 14, _hoisted_3$d), [
      [vShow, !_ctx.hidden && (_ctx.content || _ctx.dot)]
    ])
  ]);
}
var Badge = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
const { componentName: componentName$e, create: create$j } = createComponent("tag");
const _sfc_main$j = create$j({
  props: {
    color: { type: String, default: "" },
    textColor: { type: String, default: "" },
    type: {
      type: String,
      default: "default"
    },
    plain: {
      type: Boolean,
      default: false
    },
    round: {
      type: Boolean,
      default: false
    },
    mark: {
      type: Boolean,
      default: false
    },
    closeable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["close"],
  setup(props, { emit }) {
    const { type, color, plain, round, mark, textColor } = toRefs(props);
    const classes = computed(() => {
      const prefixCls = componentName$e;
      return {
        [prefixCls]: true,
        [`${prefixCls}--${type.value}`]: type.value,
        [`${prefixCls}--plain`]: plain.value,
        [`${prefixCls}--round`]: round.value,
        [`${prefixCls}--mark`]: mark.value
      };
    });
    const getStyle = () => {
      if (color == null ? void 0 : color.value) {
        return {
          background: color.value,
          color: textColor.value
        };
      }
      if (plain.value) {
        return {
          color: "#FA2400",
          background: "#fff",
          border: "1px solid rgba(250,36,0,1)"
        };
      }
      return {
        color: "",
        background: ""
      };
    };
    const onClose = (event) => {
      event.stopPropagation();
      emit("close", event);
    };
    return {
      classes,
      getStyle,
      onClose
    };
  }
});
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.getStyle())
  }, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.closeable ? (openBlock(), createBlock(_component_nut_icon, {
      key: 0,
      class: "nut-tag--close",
      name: "close",
      size: "12",
      onClick: _ctx.onClose
    }, null, 8, ["onClick"])) : createCommentVNode("", true)
  ], 6);
}
var Tag = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
const { componentName: componentName$d, create: create$i } = createComponent("popover");
const _sfc_main$i = create$i({
  inheritAttrs: false,
  components: {
    [Popup.name]: Popup,
    [Button.name]: Button
  },
  props: __spreadProps(__spreadValues({}, popupProps), {
    list: {
      type: Array,
      default: []
    },
    theme: {
      type: String,
      default: "light"
    },
    location: {
      type: String,
      default: "bottom"
    }
  }),
  emits: ["update", "update:visible", "close", "choose", "openPopover"],
  setup(props, { emit }) {
    const reference = ref();
    const state = reactive({
      elWidth: 0,
      elHeight: 0
    });
    const showPopup = ref(props.visible);
    const { theme, location: location2 } = toRefs(props);
    const classes = computed(() => {
      const prefixCls = componentName$d;
      return {
        [prefixCls]: true,
        [`${prefixCls}--${theme.value}`]: theme.value
      };
    });
    const popoverContent = computed(() => {
      const prefixCls = "popoverContent";
      return {
        [prefixCls]: true,
        [`${prefixCls}--${location2.value}`]: location2.value
      };
    });
    const popoverArrow = computed(() => {
      const prefixCls = "popoverArrow";
      return {
        [prefixCls]: true,
        [`${prefixCls}--${location2.value}`]: location2.value
      };
    });
    function getReference() {
      state.elWidth = reference.value.offsetWidth;
      state.elHeight = reference.value.offsetHeight;
    }
    const getStyle = computed(() => {
      const style = {};
      if (location2.value == "top") {
        style.bottom = state.elHeight + 20 + "px";
        style.left = 0 + "px";
      } else if (location2.value == "right") {
        style.top = 0 + "px";
        style.right = -state.elWidth + "px";
      } else if (location2.value == "left") {
        style.top = 0 + "px";
        style.left = -state.elWidth + "px";
      } else {
        style.top = state.elHeight + 20 + "px";
        style.left = 0 + "px";
      }
      return style;
    });
    const getArrowStyle = computed(() => {
      const style = {};
      if (location2.value == "top") {
        style.bottom = -20 + "px";
        style.left = state.elWidth / 2 + "px";
      } else if (location2.value == "right") {
        style.top = 20 + "px";
        style.left = -20 + "px";
      } else if (location2.value == "left") {
        style.top = 20 + "px";
        style.right = -20 + "px";
      } else {
        style.left = state.elWidth / 2 + "px";
        style.top = -20 + "px";
      }
      return style;
    });
    onMounted(() => {
      getReference();
    });
    watch(() => props.visible, (value) => {
      showPopup.value = value;
    });
    const update = (val) => {
      emit("update", val);
      emit("update:visible", val);
    };
    const openPopover = () => {
      update(!props.visible);
      emit("open");
    };
    const closePopover = () => {
      emit("close");
      emit("update:visible", false);
    };
    const chooseItem = (item, index) => {
      emit("choose", item, index);
    };
    return {
      classes,
      showPopup,
      openPopover,
      popoverContent,
      popoverArrow,
      closePopover,
      chooseItem,
      getReference,
      reference,
      getStyle,
      getArrowStyle
    };
  }
});
const _hoisted_1$g = { ref: "reference" };
const _hoisted_2$d = ["onClick"];
const _hoisted_3$c = { class: "title-name" };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  return openBlock(), createElementBlock("view", {
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.openPopover && _ctx.openPopover(...args), ["stop"])),
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("div", _hoisted_1$g, [
      renderSlot(_ctx.$slots, "reference")
    ], 512),
    _ctx.showPopup ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createElementVNode("view", {
        class: "more-background",
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.closePopover && _ctx.closePopover(...args), ["stop"]))
      }),
      createElementVNode("view", {
        class: normalizeClass(_ctx.popoverContent),
        style: normalizeStyle(_ctx.getStyle)
      }, [
        createElementVNode("view", {
          class: normalizeClass(_ctx.popoverArrow),
          style: normalizeStyle(_ctx.getArrowStyle)
        }, null, 6),
        renderSlot(_ctx.$slots, "content"),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, index) => {
          return openBlock(), createElementBlock("view", {
            key: index,
            class: normalizeClass({ "title-item": true, disabled: item.disabled }),
            onClick: withModifiers(($event) => _ctx.chooseItem(item, index), ["stop"])
          }, [
            item.icon ? renderSlot(_ctx.$slots, "default", { key: 0 }, () => [
              createVNode(_component_nut_icon, {
                class: "item-img",
                name: item.icon
              }, null, 8, ["name"])
            ]) : createCommentVNode("", true),
            createElementVNode("view", _hoisted_3$c, toDisplayString(item.name), 1)
          ], 10, _hoisted_2$d);
        }), 128))
      ], 6)
    ], 64)) : createCommentVNode("", true)
  ], 2);
}
var Popover = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
const TypeOfFun = (value) => {
  if (value === null) {
    return "null";
  }
  const type = typeof value;
  if (type === "undefined" || type === "string") {
    return type;
  }
  const typeString = toString.call(value);
  switch (typeString) {
    case "[object Array]":
      return "array";
    case "[object Date]":
      return "date";
    case "[object Boolean]":
      return "boolean";
    case "[object Number]":
      return "number";
    case "[object Function]":
      return "function";
    case "[object RegExp]":
      return "regexp";
    case "[object Object]":
      if (value.nodeType !== void 0) {
        if (value.nodeType == 3) {
          return /\S/.test(value.nodeValue) ? "textnode" : "whitespace";
        } else {
          return "element";
        }
      } else {
        return "object";
      }
    default:
      return "unknow";
  }
};
const isFunction = (val) => typeof val === "function";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const component$2 = {
  props: {
    modelValue: {
      type: Object,
      default: {}
    }
  },
  components: {},
  emits: ["validate"],
  setup(props, { emit, slots }) {
    const formErrorTip = computed(() => reactive({}));
    provide("formErrorTip", formErrorTip);
    const clearErrorTips = (value = props.modelValue) => {
      Object.keys(formErrorTip.value).forEach((item) => {
        formErrorTip.value[item] = "";
      });
    };
    const reset = () => {
      clearErrorTips();
    };
    watch(() => props.modelValue, (value) => {
      clearErrorTips(value);
    }, { immediate: true });
    const findFormItem = (vnodes) => {
      let task = [];
      vnodes.forEach((vnode, index) => {
        var _a, _b, _c;
        let type = vnode.type;
        type = type.name || type;
        if (type == "nut-form-item") {
          task.push({
            prop: (_a = vnode.props) == null ? void 0 : _a["prop"],
            rules: ((_b = vnode.props) == null ? void 0 : _b["rules"]) || []
          });
        } else if (Array.isArray(vnode.children) && ((_c = vnode.children) == null ? void 0 : _c.length)) {
          task = task.concat(findFormItem(vnode.children));
        }
      });
      return task;
    };
    const tipMessage = (errorMsg2) => {
      if (errorMsg2.message) {
        emit("validate", errorMsg2);
      }
      formErrorTip.value[errorMsg2.prop] = errorMsg2.message;
    };
    const checkRule = (item) => {
      const { rules, prop } = item;
      const _Promise = (errorMsg2) => {
        return new Promise((resolve, reject) => {
          tipMessage(errorMsg2);
          resolve(errorMsg2);
        });
      };
      const getPropByPath = (obj, keyPath) => {
        return keyPath.split(".").reduce((prev, curr) => prev[curr], obj);
      };
      if (!prop) {
        console.warn("[NutUI] <FormItem> \u4F7F\u7528 rules \u6821\u9A8C\u89C4\u5219\u65F6 , \u5FC5\u987B\u8BBE\u7F6E prop \u53C2\u6570");
      }
      let value = getPropByPath(props.modelValue, prop || "");
      tipMessage({ prop, message: "" });
      while (rules.length) {
        const { required, validator, regex, message } = rules.shift();
        const errorMsg2 = { prop, message };
        if (required) {
          if (!value) {
            return _Promise(errorMsg2);
          }
        }
        if (regex && !regex.test(String(value))) {
          return _Promise(errorMsg2);
        }
        if (validator) {
          const result = validator(value);
          if (isPromise(result)) {
            return new Promise((r, j) => {
              result.then((res) => {
                if (!res) {
                  tipMessage(errorMsg2);
                  r(errorMsg2);
                } else {
                  r(true);
                }
              });
            });
          } else {
            if (!result) {
              return _Promise(errorMsg2);
            }
          }
        }
      }
      return Promise.resolve(true);
    };
    const validate = (customProp = "") => {
      return new Promise((resolve, reject) => {
        let task = findFormItem(slots.default());
        let errors = task.map((item) => {
          if (customProp) {
            if (customProp == item.prop) {
              return checkRule(item);
            } else {
              return Promise.resolve(true);
            }
          } else {
            return checkRule(item);
          }
        });
        Promise.all(errors).then((errorRes) => {
          errorRes = errorRes.filter((item) => item != true);
          const res = { valid: true, errors: [] };
          if (errorRes.length) {
            res.valid = false;
            res.errors = errorRes;
          }
          resolve(res);
        });
      });
    };
    const onSubmit = () => {
      validate();
      return false;
    };
    return { validate, reset, onSubmit, formErrorTip };
  }
};
const { create: create$h } = createComponent("form");
const _sfc_main$h = create$h(component$2);
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_cell_group = resolveComponent("nut-cell-group");
  return openBlock(), createElementBlock("form", {
    class: "nut-form",
    onSubmit: _cache[0] || (_cache[0] = (...args) => _ctx.onSubmit && _ctx.onSubmit(...args))
  }, [
    createVNode(_component_nut_cell_group, null, {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "default")
      ]),
      _: 3
    })
  ], 32);
}
var Form = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
const { componentName: componentName$c, create: create$g } = createComponent("form-item");
const _sfc_main$g = create$g({
  inheritAttrs: false,
  props: {
    prop: {
      type: String,
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    rules: {
      type: Array,
      default: () => {
        return [];
      }
    },
    required: {
      type: Boolean,
      default: false
    },
    showErrorMessage: {
      type: Boolean,
      default: true
    },
    showErrorLine: {
      type: Boolean,
      default: true
    },
    labelWidth: {
      type: [String, Number],
      default: ""
    },
    labelAlign: {
      type: String,
      default: "left"
    },
    errorMessageAlign: {
      type: String,
      default: "left"
    },
    bodyAlign: {
      type: String,
      default: "left"
    }
  },
  components: {},
  emits: [""],
  setup(props, { emit }) {
    const parent = inject("formErrorTip");
    const labelStyle = computed(() => {
      return {
        width: pxCheck(props.labelWidth),
        textAlign: props.labelAlign
      };
    });
    const bodyStyle = computed(() => {
      return {
        textAlign: props.bodyAlign
      };
    });
    const errorMessageStyle = computed(() => {
      return {
        textAlign: props.errorMessageAlign
      };
    });
    return { parent, labelStyle, bodyStyle, errorMessageStyle };
  }
});
const _hoisted_1$f = { class: "nut-cell__value nut-form-item__body" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_cell = resolveComponent("nut-cell");
  return openBlock(), createBlock(_component_nut_cell, {
    class: normalizeClass(["nut-form-item", { error: _ctx.parent[_ctx.prop], line: _ctx.showErrorLine }])
  }, {
    default: withCtx(() => [
      _ctx.label ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: normalizeClass(["nut-cell__title nut-form-item__label", { required: _ctx.required }]),
        style: normalizeStyle(_ctx.labelStyle)
      }, toDisplayString(_ctx.label), 7)) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_1$f, [
        createElementVNode("view", {
          class: "nut-form-item__body__slots",
          style: normalizeStyle(_ctx.bodyStyle)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 4),
        _ctx.parent[_ctx.prop] && _ctx.showErrorMessage ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "nut-form-item__body__tips",
          style: normalizeStyle(_ctx.errorMessageStyle)
        }, toDisplayString(_ctx.parent[_ctx.prop]), 5)) : createCommentVNode("", true)
      ])
    ]),
    _: 3
  }, 8, ["class"]);
}
var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
const component$1 = {
  props: {
    width: {
      type: String,
      default: "100px"
    },
    height: {
      type: String,
      default: "100px"
    },
    animated: {
      type: Boolean,
      default: false
    },
    avatar: {
      type: Boolean,
      default: false
    },
    avatarShape: {
      type: String,
      default: "round"
    },
    avatarSize: {
      type: String,
      default: "50px"
    },
    loading: {
      type: Boolean,
      default: true
    },
    round: {
      type: Boolean,
      default: false
    },
    row: {
      type: String,
      default: "1"
    },
    title: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const { avatarShape, round, avatarSize } = toRefs(props);
    const avatarClass = computed(() => {
      const prefixCls = "avatarClass";
      return {
        [prefixCls]: true,
        [`${prefixCls}--${avatarShape.value}`]: avatarShape.value
      };
    });
    const blockClass = computed(() => {
      const prefixCls = "blockClass";
      return {
        [prefixCls]: true,
        [`${prefixCls}--round`]: round.value
      };
    });
    const getStyle = () => {
      if (avatarSize == null ? void 0 : avatarSize.value) {
        return {
          width: avatarSize.value,
          height: avatarSize.value
        };
      }
      return {
        width: "50px",
        height: "50px"
      };
    };
    onMounted(() => {
      console.log("row", props.row);
    });
    return {
      avatarShape,
      avatarClass,
      blockClass,
      getStyle
    };
  }
};
const { create: create$f } = createComponent("skeleton");
const _sfc_main$f = create$f(component$1);
const _hoisted_1$e = { key: 0 };
const _hoisted_2$c = {
  key: 1,
  class: "skeleton"
};
const _hoisted_3$b = /* @__PURE__ */ createElementVNode("view", { class: "skeleton-animation" }, null, -1);
const _hoisted_4$a = { class: "content" };
const _hoisted_5$5 = { class: "content-line" };
const _hoisted_6$3 = {
  key: 0,
  class: "title"
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_avatar = resolveComponent("nut-avatar");
  return !_ctx.loading ? (openBlock(), createElementBlock("view", _hoisted_1$e, [
    renderSlot(_ctx.$slots, "default")
  ])) : (openBlock(), createElementBlock("view", _hoisted_2$c, [
    _hoisted_3$b,
    createElementVNode("view", _hoisted_4$a, [
      _ctx.avatar ? (openBlock(), createBlock(_component_nut_avatar, {
        key: 0,
        class: normalizeClass(_ctx.avatarClass),
        shape: _ctx.avatarShape,
        style: normalizeStyle(_ctx.getStyle()),
        "bg-color": "rgb(239, 239, 239)"
      }, null, 8, ["class", "shape", "style"])) : createCommentVNode("", true),
      Number(_ctx.row) == 1 ? (openBlock(), createElementBlock("view", {
        key: 1,
        class: normalizeClass(_ctx.blockClass),
        style: normalizeStyle({ width: _ctx.width, height: _ctx.height })
      }, null, 6)) : createCommentVNode("", true),
      createElementVNode("view", _hoisted_5$5, [
        _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_6$3)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(Number(_ctx.row), (item, index) => {
          return openBlock(), createElementBlock("view", {
            key: index,
            class: normalizeClass(_ctx.blockClass),
            style: normalizeStyle({ width: _ctx.width, height: _ctx.height })
          }, null, 6);
        }), 128))
      ])
    ])
  ]));
}
var Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
const formatTree = (tree, parent, config) => tree.map((node) => {
  const { value: valueKey = "value", text: textKey = "text", children: childrenKey = "children" } = config;
  const _a = node, { [valueKey]: value, [textKey]: text, [childrenKey]: children } = _a, others = __objRest(_a, [__restKey(valueKey), __restKey(textKey), __restKey(childrenKey)]);
  const newNode = __spreadProps(__spreadValues({
    loading: false
  }, others), {
    level: parent ? (parent && parent.level || 0) + 1 : 0,
    value,
    text,
    children,
    _parent: parent
  });
  if (newNode.children && newNode.children.length) {
    newNode.children = formatTree(newNode.children, newNode, config);
  }
  return newNode;
});
const eachTree = (tree, cb) => {
  let i = 0;
  let node;
  while (node = tree[i++]) {
    if (cb(node) === true) {
      break;
    }
    if (node.children && node.children.length) {
      eachTree(node.children, cb);
    }
  }
};
const defaultConvertConfig = {
  topId: null,
  idKey: "id",
  pidKey: "pid",
  sortKey: ""
};
const convertListToOptions = (list, options) => {
  const mergedOptions = __spreadValues(__spreadValues({}, defaultConvertConfig), options || {});
  const { topId, idKey, pidKey, sortKey } = mergedOptions;
  let result = [];
  let map = {};
  list.forEach((node) => {
    node = __spreadValues({}, node);
    const { [idKey]: id, [pidKey]: pid } = node;
    const children = map[pid] = map[pid] || [];
    if (!result.length && pid === topId) {
      result = children;
    }
    children.push(node);
    node.children = map[id] || (map[id] = []);
  });
  if (sortKey) {
    Object.keys(map).forEach((i) => {
      if (map[i].length > 1) {
        map[i].sort((a, b) => a[sortKey] - b[sortKey]);
      }
    });
  }
  map = null;
  return result;
};
class Tree {
  constructor(nodes, config) {
    __publicField(this, "nodes");
    __publicField(this, "config");
    this.config = __spreadValues({
      value: "value",
      text: "text",
      children: "children"
    }, config || {});
    this.nodes = formatTree(nodes, null, this.config);
  }
  updateChildren(nodes, parent) {
    if (!parent) {
      this.nodes = formatTree(nodes, null, this.config);
    } else {
      parent.children = formatTree(nodes, parent, this.config);
    }
  }
  getNodeByValue(value) {
    let foundNode;
    eachTree(this.nodes, (node) => {
      if (node.value === value) {
        foundNode = node;
        return true;
      }
    });
    return foundNode;
  }
  getPathNodesByNode(node) {
    const nodes = [];
    while (node) {
      nodes.unshift(node);
      node = node._parent;
    }
    return nodes;
  }
  getPathNodesByValue(value) {
    if (Array.isArray(value) && !value.length) {
      return [];
    }
    const tail = Array.isArray(value) ? value[value.length - 1] : value;
    const node = this.getNodeByValue(tail);
    if (!node) {
      return [];
    }
    return this.getPathNodesByNode(node);
  }
  isLeaf(node, lazy) {
    const { leaf, children } = node;
    const hasChildren = Array.isArray(children) && Boolean(children.length);
    return leaf || !hasChildren && !lazy;
  }
  hasChildren(node, lazy) {
    const isLeaf = this.isLeaf(node, lazy);
    if (isLeaf) {
      return false;
    }
    const { children } = node;
    return Array.isArray(children) && Boolean(children.length);
  }
}
const { create: create$e } = createComponent("cascader-item");
const _sfc_main$e = create$e({
  props: {
    visible: Boolean,
    modelValue: Array,
    options: {
      type: Array,
      default: () => []
    },
    lazy: Boolean,
    lazyLoad: Function,
    valueKey: {
      type: String,
      default: "value"
    },
    textKey: {
      type: String,
      default: "text"
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    convertConfig: Object
  },
  components: {},
  emits: ["update:modelValue", "change", "pathChange"],
  setup(props, { emit }) {
    const configs = computed(() => ({
      lazy: props.lazy,
      lazyLoad: props.lazyLoad,
      valueKey: props.valueKey,
      textKey: props.textKey,
      childrenKey: props.childrenKey,
      convertConfig: props.convertConfig
    }));
    const tabsCursor = ref(0);
    const initLoading = ref(false);
    const innerValue = ref(props.modelValue);
    const tree = ref(new Tree([], {}));
    const panes = ref([]);
    const isLazy = computed(() => configs.value.lazy && Boolean(configs.value.lazyLoad));
    const lazyLoadMap = new Map();
    let currentProcessNode;
    const init = async () => {
      lazyLoadMap.clear();
      panes.value = [];
      tabsCursor.value = 0;
      initLoading.value = false;
      currentProcessNode = null;
      let { options } = props;
      if (configs.value.convertConfig) {
        options = convertListToOptions(options, configs.value.convertConfig);
      }
      tree.value = new Tree(options, {
        value: configs.value.valueKey,
        text: configs.value.textKey,
        children: configs.value.childrenKey
      });
      if (isLazy.value && !tree.value.nodes.length) {
        await invokeLazyLoad({
          root: true,
          loading: true,
          text: "",
          value: ""
        });
      }
      panes.value = [{ nodes: tree.value.nodes, selectedNode: null }];
      syncValue();
    };
    const syncValue = async () => {
      const currentValue = innerValue.value;
      if (currentValue === void 0 || !tree.value.nodes.length) {
        return;
      }
      if (currentValue.length === 0) {
        tabsCursor.value = 0;
        panes.value = [{ nodes: tree.value.nodes, selectedNode: null }];
        return;
      }
      let needToSync = currentValue;
      if (isLazy.value && Array.isArray(currentValue) && currentValue.length) {
        needToSync = [];
        let parent = tree.value.nodes.find((node) => node.value === currentValue[0]);
        if (parent) {
          needToSync = [parent.value];
          initLoading.value = true;
          const last = await currentValue.slice(1).reduce(async (p, value) => {
            var _a;
            const parent2 = await p;
            await invokeLazyLoad(parent2);
            const node = (_a = parent2 == null ? void 0 : parent2.children) == null ? void 0 : _a.find((item) => item.value === value);
            if (node) {
              needToSync.push(value);
            }
            return Promise.resolve(node);
          }, Promise.resolve(parent));
          await invokeLazyLoad(last);
          initLoading.value = false;
        }
      }
      if (needToSync.length && currentValue === props.modelValue) {
        const pathNodes = tree.value.getPathNodesByValue(needToSync);
        pathNodes.map((node, index) => {
          tabsCursor.value = index;
          methods.handleNode(node, true);
        });
      }
    };
    const invokeLazyLoad = async (node) => {
      if (!node) {
        return;
      }
      if (!configs.value.lazyLoad) {
        node.leaf = true;
        return;
      }
      if (tree.value.isLeaf(node, isLazy.value) || tree.value.hasChildren(node, isLazy.value)) {
        return;
      }
      node.loading = true;
      const parent = node.root ? null : node;
      let lazyLoadPromise = lazyLoadMap.get(node);
      if (!lazyLoadPromise) {
        lazyLoadPromise = new Promise((resolve) => {
          var _a, _b;
          (_b = (_a = configs.value).lazyLoad) == null ? void 0 : _b.call(_a, node, resolve);
        });
        lazyLoadMap.set(node, lazyLoadPromise);
      }
      const nodes = await lazyLoadPromise;
      if (Array.isArray(nodes) && nodes.length > 0) {
        tree.value.updateChildren(nodes, parent);
      } else {
        node.leaf = true;
      }
      node.loading = false;
      lazyLoadMap.delete(node);
    };
    const emitChange = (pathNodes) => {
      const emitValue = pathNodes.map((node) => node.value);
      innerValue.value = emitValue;
      emit("change", emitValue, pathNodes);
      emit("update:modelValue", emitValue, pathNodes);
    };
    const methods = {
      async handleNode(node, silent) {
        const { disabled, loading } = node;
        if (!silent && disabled || !panes.value[tabsCursor.value]) {
          return;
        }
        if (tree.value.isLeaf(node, isLazy.value)) {
          node.leaf = true;
          panes.value[tabsCursor.value].selectedNode = node;
          panes.value = panes.value.slice(0, node.level + 1);
          if (!silent) {
            const pathNodes = panes.value.map((pane) => pane.selectedNode);
            emitChange(pathNodes);
            emit("pathChange", pathNodes);
          }
          return;
        }
        if (tree.value.hasChildren(node, isLazy.value)) {
          const level = node.level + 1;
          panes.value[tabsCursor.value].selectedNode = node;
          panes.value = panes.value.slice(0, level);
          panes.value.push({
            nodes: node.children || [],
            selectedNode: null
          });
          tabsCursor.value = level;
          if (!silent) {
            const pathNodes = panes.value.map((pane) => pane.selectedNode);
            emit("pathChange", pathNodes);
          }
          return;
        }
        currentProcessNode = node;
        if (loading) {
          return;
        }
        await invokeLazyLoad(node);
        if (currentProcessNode === node) {
          panes.value[tabsCursor.value].selectedNode = node;
          methods.handleNode(node, silent);
        }
      },
      handleTabClick(tab) {
        currentProcessNode = null;
        tabsCursor.value = tab.paneKey;
      },
      formatTabTitle(pane) {
        return pane.selectedNode ? pane.selectedNode.text : "\u8BF7\u9009\u62E9";
      },
      isSelected(pane, node) {
        return pane.selectedNode && pane.selectedNode.value === node.value;
      }
    };
    watch([configs, () => props.options], () => {
      init();
    }, {
      deep: true,
      immediate: true
    });
    watch(() => props.modelValue, (value) => {
      if (value !== innerValue.value) {
        innerValue.value = value;
        syncValue();
      }
    });
    watch(() => props.visible, (val) => {
      if (val && Array.isArray(innerValue.value) && innerValue.value.length > 0) {
        syncValue();
      }
    });
    return __spreadValues({ panes, initLoading, tabsCursor }, methods);
  }
});
const _hoisted_1$d = {
  role: "menu",
  class: "nut-cascader-pane"
};
const _hoisted_2$b = ["aria-checked", "aria-disabled", "onClick"];
const _hoisted_3$a = { class: "nut-cascader-item__title" };
const _hoisted_4$9 = /* @__PURE__ */ createElementVNode("view", { class: "nut-cascader-pane" }, null, -1);
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_tabpane = resolveComponent("nut-tabpane");
  const _component_nut_tabs = resolveComponent("nut-tabs");
  return openBlock(), createBlock(_component_nut_tabs, {
    class: "nut-cascader",
    modelValue: _ctx.tabsCursor,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tabsCursor = $event),
    onClick: _ctx.handleTabClick,
    "title-scroll": ""
  }, {
    default: withCtx(() => [
      !_ctx.initLoading && _ctx.panes.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.panes, (pane, index) => {
        return openBlock(), createBlock(_component_nut_tabpane, {
          title: _ctx.formatTabTitle(pane),
          key: index
        }, {
          default: withCtx(() => [
            createElementVNode("view", _hoisted_1$d, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(pane.nodes, (node) => {
                return openBlock(), createElementBlock("view", {
                  key: node.value,
                  class: normalizeClass(["nut-cascader-item", { active: _ctx.isSelected(pane, node), disabled: node.disabled }]),
                  "aria-checked": _ctx.isSelected(pane, node),
                  "aria-disabled": node.disabled || void 0,
                  role: "menuitemradio",
                  onClick: ($event) => _ctx.handleNode(node, false)
                }, [
                  createElementVNode("view", _hoisted_3$a, toDisplayString(node.text), 1),
                  node.loading ? (openBlock(), createBlock(_component_nut_icon, {
                    key: 0,
                    class: "nut-cascader-item__icon-loading",
                    name: "loading"
                  })) : (openBlock(), createBlock(_component_nut_icon, {
                    key: 1,
                    class: "nut-cascader-item__icon-check",
                    name: "checklist"
                  }))
                ], 10, _hoisted_2$b);
              }), 128))
            ])
          ]),
          _: 2
        }, 1032, ["title"]);
      }), 128)) : (openBlock(), createBlock(_component_nut_tabpane, {
        key: 1,
        title: "Loading..."
      }, {
        default: withCtx(() => [
          _hoisted_4$9
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["modelValue", "onClick"]);
}
var CascaderItem = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
const { create: create$d } = createComponent("cascader");
const _sfc_main$d = create$d({
  components: {
    [CascaderItem.name]: CascaderItem
  },
  props: {
    modelValue: Array,
    visible: Boolean,
    title: String,
    options: {
      type: Array,
      default: () => []
    },
    lazy: Boolean,
    lazyLoad: Function,
    valueKey: {
      type: String,
      default: "value"
    },
    textKey: {
      type: String,
      default: "text"
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    convertConfig: Object
  },
  emits: ["update:modelValue", "change", "pathChange", "update:visible"],
  setup(props, { emit }) {
    const innerValue = ref(props.modelValue);
    const innerVisible = computed({
      get() {
        return props.visible;
      },
      set(value) {
        emit("update:visible", value);
      }
    });
    const onChange = (value, pathNodes) => {
      innerValue.value = value;
      innerVisible.value = false;
      emit("change", value, pathNodes);
      emit("update:modelValue", value);
    };
    const onPathChange = (pathNodes) => {
      emit("pathChange", pathNodes);
    };
    watch(() => props.modelValue, (value) => {
      if (value !== innerValue.value) {
        innerValue.value = value;
      }
    });
    return {
      onChange,
      onPathChange,
      innerValue,
      innerVisible
    };
  }
});
const _hoisted_1$c = {
  key: 0,
  class: "nut-cascader__bar"
};
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_cascader_item = resolveComponent("nut-cascader-item");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.innerVisible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.innerVisible = $event),
    position: "bottom",
    "pop-class": "nut-cascader__popup",
    round: "",
    closeable: true,
    "destroy-on-close": false
  }, {
    default: withCtx(() => [
      _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_1$c, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
      createVNode(_component_nut_cascader_item, {
        onChange: _ctx.onChange,
        onPathChange: _ctx.onPathChange,
        modelValue: _ctx.innerValue,
        options: _ctx.options,
        lazy: _ctx.lazy,
        "lazy-load": _ctx.lazyLoad,
        "value-key": _ctx.valueKey,
        "text-key": _ctx.textKey,
        "children-key": _ctx.childrenKey,
        "convert-config": _ctx.convertConfig,
        visible: _ctx.innerVisible
      }, null, 8, ["onChange", "onPathChange", "modelValue", "options", "lazy", "lazy-load", "value-key", "text-key", "children-key", "convert-config", "visible"])
    ]),
    _: 1
  }, 8, ["visible"]);
}
var Cascader = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
const { componentName: componentName$b, create: create$c } = createComponent("address");
const _sfc_main$c = create$c({
  inheritAttrs: false,
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "custom"
    },
    customAddressTitle: {
      type: String,
      default: "\u8BF7\u9009\u62E9\u6240\u5728\u5730\u533A"
    },
    province: {
      type: Array,
      default: () => []
    },
    city: {
      type: Array,
      default: () => []
    },
    country: {
      type: Array,
      default: () => []
    },
    town: {
      type: Array,
      default: () => []
    },
    isShowCustomAddress: {
      type: Boolean,
      default: true
    },
    existAddress: {
      type: Array,
      default: () => []
    },
    existAddressTitle: {
      type: String,
      default: "\u914D\u9001\u81F3"
    },
    customAndExistTitle: {
      type: String,
      default: "\u9009\u62E9\u5176\u4ED6\u5730\u5740"
    },
    defaultIcon: {
      type: String,
      default: "location2"
    },
    selectedIcon: {
      type: String,
      default: "Check"
    },
    closeBtnIcon: {
      type: String,
      default: "circle-close"
    },
    backBtnIcon: {
      type: String,
      default: "left"
    },
    height: {
      type: [String, Number],
      default: "200px"
    }
  },
  emits: ["update:visible", "type", "change", "selected", "close", "close-mask", "switch-module"],
  setup(props, { emit }) {
    const regionLine = ref(null);
    const tabRegion = ref(null);
    const showPopup = ref(props.visible);
    const privateType = ref(props.type);
    const tabIndex = ref(0);
    const tabName = ref(["province", "city", "country", "town"]);
    const isCustom2 = computed(() => props.type === "custom2");
    const transformData = (data) => {
      if (!Array.isArray(data))
        throw new TypeError("params muse be array.");
      if (!data.length)
        return [];
      data.forEach((item) => {
        if (!item.title) {
          console.error("[NutUI] <Address> \u8BF7\u68C0\u67E5\u6570\u7EC4\u9009\u9879\u7684 title \u503C\u662F\u5426\u6709\u8BBE\u7F6E ,title \u4E3A\u5FC5\u586B\u9879 .");
          return;
        }
      });
      const newData = [];
      data = data.sort((a, b) => {
        return a.title.localeCompare(b.title);
      });
      data.forEach((item) => {
        const index = newData.findIndex((value) => value.title === item.title);
        if (index <= -1) {
          newData.push({
            title: item.title,
            list: [].concat(item)
          });
        } else {
          newData[index] = {
            title: item.title,
            list: newData[index].list.concat(item)
          };
        }
      });
      return newData;
    };
    const regionList = reactive({
      province: isCustom2.value ? transformData(props.province) : props.province,
      city: isCustom2.value ? transformData(props.city) : props.city,
      country: isCustom2.value ? transformData(props.country) : props.country,
      town: isCustom2.value ? transformData(props.town) : props.town
    });
    const selectedRegion = reactive({
      province: {},
      city: {},
      country: {},
      town: {}
    });
    let selectedExistAddress = reactive({});
    const closeWay = ref("self");
    const lineDistance = ref(20);
    const getTabName = (item, index) => {
      if (item.name)
        return item.name;
      if (tabIndex.value < index) {
        return item.name;
      } else {
        return "\u8BF7\u9009\u62E9";
      }
    };
    const handClose = (type = "self") => {
      if (!props.closeBtnIcon)
        return;
      closeWay.value = type == "cross" ? "cross" : "self";
      showPopup.value = false;
    };
    const clickOverlay = () => {
      closeWay.value = "mask";
    };
    const lineAnimation = () => {
      console.log("\u6ED1\u52A8\u7EA2\u7EBF");
      nextTick(() => {
        const name = tabRegion.value && tabRegion.value.getElementsByClassName("active")[0];
        if (name) {
          const distance = name.offsetLeft;
          lineDistance.value = distance ? distance : 20;
        }
      });
    };
    const nextAreaList = (item) => {
      const calBack = {
        next: "",
        value: "",
        custom: tabName.value[tabIndex.value]
      };
      selectedRegion[tabName.value[tabIndex.value]] = item;
      for (let i = tabIndex.value; i < tabIndex.value - 1; i++) {
        selectedRegion[tabName.value[i + 1]] = {};
      }
      if (tabIndex.value < 3) {
        tabIndex.value = tabIndex.value + 1;
        lineAnimation();
        calBack.next = tabName.value[tabIndex.value];
        calBack.value = item;
        emit("change", calBack);
      } else {
        handClose();
      }
    };
    const changeRegionTab = (item, key, index) => {
      if (getTabName(item, index)) {
        tabIndex.value = index;
        lineAnimation();
      }
    };
    const selectedExist = (item) => {
      const copyExistAdd = props.existAddress;
      let prevExistAdd = {};
      copyExistAdd.forEach((list, index) => {
        if (list && list.selectedAddress) {
          prevExistAdd = list;
        }
        list.selectedAddress = false;
      });
      item.selectedAddress = true;
      selectedExistAddress = item;
      emit("selected", prevExistAdd, item, copyExistAdd);
      handClose();
    };
    const initAddress = () => {
      for (let i = 0; i < tabName.value.length; i++) {
        selectedRegion[tabName.value[i]] = {};
      }
      tabIndex.value = 0;
      lineAnimation();
    };
    const close = () => {
      const resCopy = Object.assign({
        addressIdStr: "",
        addressStr: ""
      }, selectedRegion);
      const res = {
        data: {},
        type: privateType.value
      };
      if (privateType.value == "custom" || privateType.value == "custom2") {
        const { province, city, country, town } = resCopy;
        resCopy.addressIdStr = [
          province.id || 0,
          city.id || 0,
          country.id || 0,
          town.id || 0
        ].join("_");
        resCopy.addressStr = [
          province.name,
          city.name,
          country.name,
          town.name
        ].join("");
        res.data = resCopy;
      } else {
        res.data = selectedExistAddress;
      }
      initAddress();
      if (closeWay.value == "self") {
        emit("close", res);
      } else {
        emit("close-mask", { closeWay });
      }
      emit("update:visible", false);
    };
    const switchModule = () => {
      if (privateType.value == "exist") {
        privateType.value = "custom";
      } else {
        privateType.value = "exist";
      }
      initAddress();
      emit("switch-module", { type: privateType.value });
    };
    const handleElevatorItem = (key, item) => {
      nextAreaList(item);
    };
    watch(() => props.visible, (value) => {
      showPopup.value = value;
    });
    watch(() => showPopup.value, (value) => {
      if (value == false) {
        close();
      }
    });
    watch(() => props.province, (value) => {
      regionList.province = isCustom2.value ? transformData(value) : value;
    });
    watch(() => props.city, (value) => {
      regionList.city = isCustom2.value ? transformData(value) : value;
    });
    watch(() => props.country, (value) => {
      regionList.country = isCustom2.value ? transformData(value) : value;
    });
    watch(() => props.town, (value) => {
      regionList.town = isCustom2.value ? transformData(value) : value;
    });
    watch(() => props.existAddress, (value) => {
      value.forEach((item, index) => {
        if (item.selectedAddress) {
          selectedExistAddress = item;
        }
      });
    });
    return __spreadValues({
      showPopup,
      privateType,
      tabIndex,
      tabName,
      regionList,
      selectedRegion,
      selectedExistAddress,
      switchModule,
      closeWay,
      close,
      getTabName,
      nextAreaList,
      regionLine,
      tabRegion,
      lineDistance,
      changeRegionTab,
      selectedExist,
      clickOverlay,
      handClose,
      handleElevatorItem
    }, toRefs(props));
  }
});
const _hoisted_1$b = { class: "nut-address" };
const _hoisted_2$a = { class: "nut-address__header" };
const _hoisted_3$9 = { class: "nut-address__header__title" };
const _hoisted_4$8 = {
  key: 0,
  class: "custom-address"
};
const _hoisted_5$4 = {
  class: "region-tab",
  ref: "tabRegion"
};
const _hoisted_6$2 = ["onClick"];
const _hoisted_7$2 = { class: "region-con" };
const _hoisted_8$2 = { class: "region-group" };
const _hoisted_9$1 = ["onClick"];
const _hoisted_10 = {
  key: 1,
  class: "custom-address"
};
const _hoisted_11 = {
  class: "region-tab",
  ref: "tabRegion"
};
const _hoisted_12 = ["onClick"];
const _hoisted_13 = { class: "elevator-group" };
const _hoisted_14 = {
  key: 2,
  class: "exist-address"
};
const _hoisted_15 = { class: "exist-address-group" };
const _hoisted_16 = { class: "exist-ul" };
const _hoisted_17 = ["onClick"];
const _hoisted_18 = { class: "exist-item-info" };
const _hoisted_19 = {
  key: 0,
  class: "exist-item-info-top"
};
const _hoisted_20 = { class: "exist-item-info-name" };
const _hoisted_21 = { class: "exist-item-info-phone" };
const _hoisted_22 = { class: "exist-item-info-bottom" };
const _hoisted_23 = { class: "btn" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_nut_elevator = resolveComponent("nut-elevator");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    position: "bottom",
    onClose: _ctx.close,
    onClickOverlay: _ctx.clickOverlay,
    onOpen: _cache[3] || (_cache[3] = ($event) => _ctx.closeWay = "self"),
    visible: _ctx.showPopup,
    "onUpdate:visible": _cache[4] || (_cache[4] = ($event) => _ctx.showPopup = $event)
  }, {
    default: withCtx(() => [
      createElementVNode("view", _hoisted_1$b, [
        createElementVNode("view", _hoisted_2$a, [
          createElementVNode("view", {
            class: "arrow-back",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.switchModule && _ctx.switchModule(...args))
          }, [
            withDirectives(createVNode(_component_nut_icon, {
              name: _ctx.backBtnIcon,
              color: "#cccccc"
            }, null, 8, ["name"]), [
              [vShow, _ctx.privateType == "custom" && _ctx.backBtnIcon]
            ])
          ]),
          createElementVNode("view", _hoisted_3$9, toDisplayString(_ctx.privateType == "custom" ? _ctx.customAddressTitle : _ctx.existAddressTitle), 1),
          createElementVNode("view", {
            class: "arrow-close",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handClose("cross"))
          }, [
            _ctx.closeBtnIcon ? (openBlock(), createBlock(_component_nut_icon, {
              key: 0,
              name: _ctx.closeBtnIcon,
              color: "#cccccc",
              size: "18px"
            }, null, 8, ["name"])) : createCommentVNode("", true)
          ])
        ]),
        _ctx.privateType == "custom" ? (openBlock(), createElementBlock("view", _hoisted_4$8, [
          createElementVNode("view", _hoisted_5$4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selectedRegion, (item, key, index) => {
              return openBlock(), createElementBlock("view", {
                class: normalizeClass(["tab-item", [index == _ctx.tabIndex ? "active" : ""]]),
                key: index,
                onClick: ($event) => _ctx.changeRegionTab(item, key, index)
              }, [
                createElementVNode("view", null, toDisplayString(_ctx.getTabName(item, index)), 1)
              ], 10, _hoisted_6$2);
            }), 128)),
            createElementVNode("view", {
              class: "region-tab-line",
              ref: "regionLine",
              style: normalizeStyle({ left: _ctx.lineDistance + "px" })
            }, null, 4)
          ], 512),
          createElementVNode("view", _hoisted_7$2, [
            createElementVNode("ul", _hoisted_8$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.regionList[_ctx.tabName[_ctx.tabIndex]], (item, index) => {
                return openBlock(), createElementBlock("li", {
                  key: index,
                  class: normalizeClass(["region-item", [_ctx.selectedRegion[_ctx.tabName[_ctx.tabIndex]].id == item.id ? "active" : ""]]),
                  onClick: ($event) => _ctx.nextAreaList(item)
                }, [
                  _ctx.selectedRegion[_ctx.tabName[_ctx.tabIndex]].id == item.id ? (openBlock(), createBlock(_component_nut_icon, {
                    key: 0,
                    class: "region-item-icon",
                    type: "self",
                    name: _ctx.selectedIcon,
                    size: "13px"
                  }, null, 8, ["name"])) : createCommentVNode("", true),
                  createTextVNode(toDisplayString(item.name), 1)
                ], 10, _hoisted_9$1);
              }), 128))
            ])
          ])
        ])) : _ctx.privateType == "custom2" ? (openBlock(), createElementBlock("view", _hoisted_10, [
          createElementVNode("view", _hoisted_11, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selectedRegion, (item, key, index) => {
              return openBlock(), createElementBlock("view", {
                class: normalizeClass(["tab-item", [index == _ctx.tabIndex ? "active" : ""]]),
                key: index,
                onClick: ($event) => _ctx.changeRegionTab(item, key, index)
              }, [
                createElementVNode("view", null, toDisplayString(_ctx.getTabName(item, index)), 1)
              ], 10, _hoisted_12);
            }), 128)),
            createElementVNode("view", {
              class: "region-tab-line",
              ref: "regionLine",
              style: normalizeStyle({ left: _ctx.lineDistance + "px" })
            }, null, 4)
          ], 512),
          createElementVNode("view", _hoisted_13, [
            createVNode(_component_nut_elevator, {
              height: _ctx.height,
              "index-list": _ctx.regionList[_ctx.tabName[_ctx.tabIndex]],
              onClickItem: _ctx.handleElevatorItem
            }, null, 8, ["height", "index-list", "onClickItem"])
          ])
        ])) : _ctx.privateType == "exist" ? (openBlock(), createElementBlock("view", _hoisted_14, [
          createElementVNode("div", _hoisted_15, [
            createElementVNode("ul", _hoisted_16, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.existAddress, (item, index) => {
                return openBlock(), createElementBlock("li", {
                  class: normalizeClass(["exist-item", [item.selectedAddress ? "active" : ""]]),
                  key: index,
                  onClick: ($event) => _ctx.selectedExist(item)
                }, [
                  createVNode(_component_nut_icon, {
                    class: "exist-item-icon",
                    type: "self",
                    name: item.selectedAddress ? _ctx.selectedIcon : _ctx.defaultIcon,
                    size: "13px"
                  }, null, 8, ["name"]),
                  createElementVNode("div", _hoisted_18, [
                    item.name && item.phone ? (openBlock(), createElementBlock("div", _hoisted_19, [
                      createElementVNode("div", _hoisted_20, toDisplayString(item.name), 1),
                      createElementVNode("div", _hoisted_21, toDisplayString(item.phone), 1)
                    ])) : createCommentVNode("", true),
                    createElementVNode("div", _hoisted_22, [
                      createElementVNode("view", null, toDisplayString(item.provinceName + item.cityName + item.countyName + item.townName + item.addressDetail), 1)
                    ])
                  ])
                ], 10, _hoisted_17);
              }), 128))
            ])
          ]),
          _ctx.isShowCustomAddress ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "choose-other",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.switchModule && _ctx.switchModule(...args))
          }, [
            createElementVNode("div", _hoisted_23, toDisplayString(_ctx.customAndExistTitle), 1)
          ])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])
    ]),
    _: 1
  }, 8, ["onClose", "onClickOverlay", "visible"]);
}
var Address = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
const { componentName: componentName$a, create: create$b } = createComponent("barrage");
const _sfc_main$b = create$b({
  props: {
    danmu: {
      type: Array,
      default: () => []
    },
    frequency: {
      type: Number,
      default: 500
    },
    speeds: {
      type: Number,
      default: 2e3
    },
    rows: {
      type: Number,
      default: 3
    },
    top: {
      type: Number,
      default: 10
    },
    loop: {
      type: Boolean,
      default: true
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const classes = computed(() => {
      const prefixCls = componentName$a;
      return {
        [prefixCls]: true
      };
    });
    let dmBody = ref(document.createElement("div"));
    let dmContainer = ref(document.createElement("div"));
    let timer = 0;
    const danmuList = ref(props.danmu);
    const rows = ref(props.rows);
    const top = ref(props.top);
    const index = ref(0);
    const speeds = props.speeds;
    const danmuCWidth = ref(0);
    onMounted(() => {
      danmuCWidth.value = dmBody.value.offsetWidth;
      run();
    });
    onUnmounted(() => {
      clearInterval(timer);
      timer = 0;
    });
    onDeactivated(() => {
      clearInterval(timer);
      timer = 0;
    });
    watch(() => props.danmu, (newValue, oldVlaue) => {
      danmuList.value = [...newValue];
    });
    const add = (word) => {
      const _index = index.value % danmuList.value.length;
      danmuList.value.splice(_index, 0, word);
    };
    const run = () => {
      clearInterval(timer);
      timer = 0;
      timer = setInterval(() => {
        play();
        run();
      }, props.frequency);
    };
    const play = () => {
      const _index = props.loop ? index.value % danmuList.value.length : index.value;
      let el = document.createElement(`view`);
      el.innerHTML = danmuList.value[_index];
      el.classList.add("dmitem");
      dmContainer.value.appendChild(el);
      nextTick(() => {
        const width = el.offsetWidth;
        const height = el.offsetHeight;
        el.classList.add("move");
        el.style.animationDuration = `${speeds}ms`;
        el.style.top = _index % rows.value * (height + top.value) + 20 + "px";
        el.style.width = width + 20 + "px";
        el.style.setProperty("--move-distance", `-${danmuCWidth.value}px`);
        el.dataset.index = `${_index}`;
        el.addEventListener("animationend", () => {
          dmContainer.value.removeChild(el);
        });
        index.value++;
      });
    };
    return { classes, danmuList, dmBody, dmContainer, add };
  }
});
const _hoisted_1$a = {
  ref: "dmContainer",
  class: "dmContainer"
};
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    ref: "dmBody",
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", _hoisted_1$a, null, 512)
  ], 2);
}
var Barrage = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
const { componentName: componentName$9, create: create$a } = createComponent("signature");
const _sfc_main$a = create$a({
  props: {
    customClass: {
      type: String,
      default: ""
    },
    lineWidth: {
      type: Number,
      default: 2
    },
    strokeStyle: {
      type: String,
      default: "#000"
    },
    type: {
      type: String,
      default: "png"
    },
    unSupportTpl: {
      type: String,
      default: "\u5BF9\u4E0D\u8D77\uFF0C\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301Canvas\uFF0C\u65E0\u6CD5\u4F7F\u7528\u672C\u63A7\u4EF6\uFF01"
    }
  },
  components: {},
  emits: ["confirm", "clear"],
  setup(props, { emit }) {
    const canvas = ref(null);
    const wrap = ref(null);
    const classes = computed(() => {
      const prefixCls = componentName$9;
      return {
        [prefixCls]: true,
        [`${props.customClass}`]: props.customClass
      };
    });
    const state = reactive({
      canvasHeight: 0,
      canvasWidth: 0,
      ctx: null,
      isSupportTouch: "ontouchstart" in window,
      events: "ontouchstart" in window ? ["touchstart", "touchmove", "touchend", "touchleave"] : ["mousedown", "mousemove", "mouseup", "mouseleave"]
    });
    const isCanvasSupported = () => {
      let elem = document.createElement("canvas");
      return !!(elem.getContext && elem.getContext("2d"));
    };
    const addEvent = () => {
      canvas.value.addEventListener(state.events[0], startEventHandler, false);
    };
    const startEventHandler = (event) => {
      event.preventDefault();
      state.ctx.beginPath();
      state.ctx.lineWidth = props.lineWidth;
      state.ctx.strokeStyle = props.strokeStyle;
      canvas.value.addEventListener(state.events[1], moveEventHandler, false);
      canvas.value.addEventListener(state.events[2], endEventHandler, false);
      canvas.value.addEventListener(state.events[3], leaveEventHandler, false);
    };
    const moveEventHandler = (event) => {
      event.preventDefault();
      let evt = state.isSupportTouch ? event.touches[0] : event;
      let coverPos = canvas.value.getBoundingClientRect();
      let mouseX = evt.clientX - coverPos.left;
      let mouseY = evt.clientY - coverPos.top;
      state.ctx.lineTo(mouseX, mouseY);
      state.ctx.stroke();
    };
    const endEventHandler = (event) => {
      event.preventDefault();
      canvas.value.removeEventListener(state.events[1], moveEventHandler, false);
      canvas.value.removeEventListener(state.events[2], endEventHandler, false);
    };
    const leaveEventHandler = (event) => {
      event.preventDefault();
      canvas.value.removeEventListener(state.events[1], moveEventHandler, false);
      canvas.value.removeEventListener(state.events[2], endEventHandler, false);
    };
    const clear = () => {
      canvas.value.addEventListener(state.events[2], endEventHandler, false);
      state.ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
      state.ctx.closePath();
      emit("clear");
    };
    const confirm = () => {
      onSave(canvas.value);
    };
    const onSave = (canvas2) => {
      let dataurl;
      switch (props.type) {
        case "png":
          dataurl = canvas2.toDataURL("image/png");
          break;
        case "jpg":
          dataurl = canvas2.toDataURL("image/jpeg", 0.8);
          break;
      }
      clear();
      emit("confirm", canvas2, dataurl);
    };
    onMounted(() => {
      if (isCanvasSupported()) {
        state.ctx = canvas.value.getContext("2d");
        state.canvasWidth = wrap.value.offsetWidth;
        state.canvasHeight = wrap.value.offsetHeight;
        addEvent();
      }
    });
    return { canvas, wrap, isCanvasSupported, confirm, clear, classes };
  }
});
const _hoisted_1$9 = {
  class: "nut-signature-inner",
  ref: "wrap"
};
const _hoisted_2$9 = ["height", "width"];
const _hoisted_3$8 = {
  key: 1,
  class: "nut-signature-unsopport"
};
const _hoisted_4$7 = /* @__PURE__ */ createTextVNode("\u91CD\u7B7E");
const _hoisted_5$3 = /* @__PURE__ */ createTextVNode("\u786E\u8BA4");
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("div", _hoisted_1$9, [
      _ctx.isCanvasSupported ? (openBlock(), createElementBlock("canvas", {
        key: 0,
        ref: "canvas",
        height: _ctx.canvasHeight,
        width: _ctx.canvasWidth
      }, null, 8, _hoisted_2$9)) : (openBlock(), createElementBlock("p", _hoisted_3$8, toDisplayString(_ctx.unSupportTpl), 1))
    ], 512),
    createVNode(_component_nut_button, {
      class: "nut-signature-btn",
      type: "default",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.clear())
    }, {
      default: withCtx(() => [
        _hoisted_4$7
      ]),
      _: 1
    }),
    createVNode(_component_nut_button, {
      class: "nut-signature-btn",
      type: "primary",
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.confirm())
    }, {
      default: withCtx(() => [
        _hoisted_5$3
      ]),
      _: 1
    })
  ], 2);
}
var Signature = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
const { componentName: componentName$8, create: create$9 } = createComponent("timeselect");
const _sfc_main$9 = create$9({
  props: {
    visible: {
      type: Boolean,
      defalut: false
    },
    height: {
      type: [String],
      default: "20%"
    },
    title: {
      type: String,
      default: "\u53D6\u4EF6\u65F6\u95F4"
    },
    currentKey: {
      type: [Number, String],
      default: 0
    },
    currentTime: {
      type: Array,
      default: () => {
        return [];
      }
    }
  },
  emits: ["update:visible", "select"],
  setup: (props, context) => {
    const classes = computed(() => {
      const prefixCls = componentName$8;
      return {
        [prefixCls]: true
      };
    });
    const popStyle = computed(() => {
      return {
        width: "100%",
        height: props.height
      };
    });
    const currentKey = computed(() => props.currentKey);
    const currentTime = computed(() => props.currentTime);
    const close = () => {
      context.emit("update:visible", false);
      context.emit("select", currentTime.value);
    };
    provide("currentKey", currentKey);
    provide("currentTime", currentTime);
    return {
      classes,
      popStyle,
      close
    };
  }
});
const _hoisted_1$8 = { class: "nut-timeselect__title" };
const _hoisted_2$8 = { class: "nut-timeselect__title__fixed" };
const _hoisted_3$7 = { class: "nut-timeselect__content" };
const _hoisted_4$6 = { class: "nut-timeselect__content__pannel" };
const _hoisted_5$2 = { class: "nut-timeselect__content__detail" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    position: "bottom",
    closeable: "",
    round: "",
    visible: _ctx.visible,
    style: normalizeStyle(_ctx.popStyle),
    onClickOverlay: _ctx.close,
    onClickCloseIcon: _ctx.close
  }, {
    default: withCtx(() => [
      createElementVNode("view", {
        class: normalizeClass(_ctx.classes)
      }, [
        createElementVNode("view", _hoisted_1$8, [
          createElementVNode("view", _hoisted_2$8, toDisplayString(_ctx.title), 1)
        ]),
        createElementVNode("view", _hoisted_3$7, [
          createElementVNode("view", _hoisted_4$6, [
            renderSlot(_ctx.$slots, "pannel")
          ]),
          createElementVNode("view", _hoisted_5$2, [
            renderSlot(_ctx.$slots, "detail")
          ])
        ])
      ], 2)
    ]),
    _: 3
  }, 8, ["visible", "style", "onClickOverlay", "onClickCloseIcon"]);
}
var TimeSelect = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
const { componentName: componentName$7, create: create$8 } = createComponent("timepannel");
const _sfc_main$8 = create$8({
  name: "timepannel",
  props: {
    name: {
      type: String,
      default: ""
    },
    pannelKey: {
      type: [Number, String],
      default: 0
    }
  },
  emits: ["change"],
  setup: (props, context) => {
    const currentKey = inject("currentKey");
    const state = reactive({
      currentKey
    });
    const classes = computed(() => {
      const prefixCls = componentName$7;
      return {
        [prefixCls]: true,
        "nut-timepannel--curr": state.currentKey == props.pannelKey
      };
    });
    const handlePannel = (pannelKey) => {
      context.emit("change", pannelKey);
    };
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      classes,
      handlePannel
    });
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handlePannel(_ctx.pannelKey))
  }, toDisplayString(_ctx.name), 3);
}
var TimePannel = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
const { componentName: componentName$6, create: create$7 } = createComponent("timedetail");
const _sfc_main$7 = create$7({
  name: "timedetail",
  props: {
    times: {
      type: Array,
      default: () => {
        return [];
      }
    },
    detailKey: {
      type: [Number, String],
      default: 0
    }
  },
  emits: ["select"],
  setup: (props, context) => {
    const currentKey = inject("currentKey");
    const currentTime = inject("currentTime");
    const state = reactive({
      currentKey,
      currentTime
    });
    const classes = computed(() => {
      const prefixCls = componentName$6;
      return {
        [prefixCls]: true
      };
    });
    const getClass = (item) => {
      let find = state.currentTime.find((item2) => item2.key == state.currentKey);
      if (find) {
        return {
          "nut-timedetail__detail__list__item": true,
          "nut-timedetail__detail__list__item--curr": find.list.filter((value) => value === item).length > 0
        };
      }
    };
    const renderData = computed(() => {
      return props.times.find((time) => time.key == state.currentKey)["list"];
    });
    const handleTime = (time) => {
      context.emit("select", time);
    };
    return __spreadProps(__spreadValues({
      classes
    }, toRefs(state)), {
      getClass,
      renderData,
      handleTime
    });
  }
});
const _hoisted_1$7 = { class: "nut-timedetail__detail nut-timedetail__detail--moring" };
const _hoisted_2$7 = { class: "nut-timedetail__detail__list" };
const _hoisted_3$6 = ["onClick"];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", _hoisted_1$7, [
      createElementVNode("view", _hoisted_2$7, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderData, (item) => {
          return openBlock(), createElementBlock("view", {
            class: normalizeClass(_ctx.getClass(item)),
            key: item,
            onClick: ($event) => _ctx.handleTime(item)
          }, toDisplayString(item), 11, _hoisted_3$6);
        }), 128))
      ])
    ])
  ], 2);
}
var TimeDetail = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const { componentName: componentName$5, create: create$6 } = createComponent("sku-header");
const _sfc_main$6 = create$6({
  props: {
    goods: {
      type: Object,
      default: {}
    }
  },
  emits: [],
  setup(props, { emit, slots }) {
    const getSlots = (name) => slots[name];
    return {
      getSlots
    };
  }
});
const _hoisted_1$6 = { class: "nut-sku-header" };
const _hoisted_2$6 = ["src"];
const _hoisted_3$5 = { class: "nut-sku-header-right" };
const _hoisted_4$5 = {
  key: 3,
  class: "nut-sku-header-right-extra"
};
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_price = resolveComponent("nut-price");
  return openBlock(), createElementBlock("view", _hoisted_1$6, [
    createElementVNode("img", {
      src: _ctx.goods.imagePath
    }, null, 8, _hoisted_2$6),
    createElementVNode("view", _hoisted_3$5, [
      _ctx.getSlots("sku-header-price") ? renderSlot(_ctx.$slots, "sku-header-price", { key: 0 }) : (openBlock(), createBlock(_component_nut_price, {
        key: 1,
        price: _ctx.goods.price,
        needSymbol: true,
        thousands: false
      }, null, 8, ["price"])),
      _ctx.getSlots("sku-header-extra") ? renderSlot(_ctx.$slots, "sku-header-extra", { key: 2 }) : createCommentVNode("", true),
      _ctx.goods.skuId && !_ctx.getSlots("sku-header-extra") ? (openBlock(), createElementBlock("view", _hoisted_4$5, "\u5546\u54C1\u7F16\u53F7\uFF1A" + toDisplayString(_ctx.goods.skuId), 1)) : createCommentVNode("", true)
    ])
  ]);
}
var SkuHeader = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const { componentName: componentName$4, create: create$5 } = createComponent("sku-select");
const _sfc_main$5 = create$5({
  props: {
    sku: {
      type: Array,
      default: () => []
    }
  },
  emits: ["selectSku"],
  setup(props, { emit }) {
    const skuInfo = ref([]);
    watch(() => props.sku, (value) => {
      skuInfo.value = [].slice.call(value);
    }, { deep: true });
    onMounted(() => {
      if (props.sku.length > 0) {
        skuInfo.value = [].slice.call(props.sku);
      }
    });
    const changeSaleChild = (attrItem, index, parentItem, parentIndex) => {
      if (attrItem.checkFlag || attrItem.disable) {
        return;
      }
      emit("selectSku", {
        sku: attrItem,
        skuIndex: index,
        parentSku: parentItem,
        parentIndex
      });
    };
    return {
      skuInfo,
      changeSaleChild
    };
  }
});
const _hoisted_1$5 = { class: "nut-sku-select" };
const _hoisted_2$5 = { class: "nut-sku-select-item-title" };
const _hoisted_3$4 = { class: "nut-sku-select-item-skus" };
const _hoisted_4$4 = ["onClick"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$5, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.skuInfo, (item, index) => {
      return openBlock(), createElementBlock("view", {
        class: "nut-sku-select-item",
        key: item.id
      }, [
        createElementVNode("view", _hoisted_2$5, toDisplayString(item.name), 1),
        createElementVNode("view", _hoisted_3$4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(item.list, (itemAttr, itemAttrIndex) => {
            return openBlock(), createElementBlock("view", {
              class: normalizeClass(["nut-sku-select-item-skus-sku", [{ active: !itemAttr.disable && itemAttr.active }, { disable: itemAttr.disable }]]),
              onClick: ($event) => _ctx.changeSaleChild(itemAttr, itemAttrIndex, item, index),
              key: itemAttr.name
            }, toDisplayString(itemAttr.name), 11, _hoisted_4$4);
          }), 128))
        ])
      ]);
    }), 128))
  ]);
}
var SkuSelect = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const { componentName: componentName$3, create: create$4 } = createComponent("sku-stepper");
const _sfc_main$4 = create$4({
  props: {
    stepperMax: {
      type: [Number, String],
      default: 99999
    },
    stepperMin: {
      type: [Number, String],
      default: 1
    },
    stepperExtraText: {
      type: [Function, Boolean],
      default: false
    },
    stepperTitle: {
      type: String,
      default: "\u8D2D\u4E70\u6570\u91CF"
    }
  },
  emits: ["click", "changeSku", "changeStepper", "clickBtnOptions", "overLimit", "reduce", "add"],
  setup(props, { emit }) {
    const goodsCount = ref(props.stepperMin);
    onMounted(() => {
      goodsCount.value = props.stepperMin;
    });
    const getExtraText = () => {
      const { stepperExtraText } = props;
      if (stepperExtraText && TypeOfFun(stepperExtraText) == "function") {
        return stepperExtraText();
      } else {
        return "";
      }
    };
    const add = (value) => {
      emit("add", value);
    };
    const reduce = (value) => {
      emit("reduce", value);
    };
    const overlimit = (e, action) => {
      emit("overLimit", {
        action,
        value: parseInt(goodsCount.value + "")
      });
    };
    const changeStepper = (value) => {
      goodsCount.value = value;
      emit("changeStepper", value);
    };
    return {
      goodsCount,
      add,
      reduce,
      overlimit,
      getExtraText,
      changeStepper
    };
  }
});
const _hoisted_1$4 = { class: "nut-sku-stepper" };
const _hoisted_2$4 = { class: "nut-sku-stepper-title" };
const _hoisted_3$3 = ["innerHTML"];
const _hoisted_4$3 = { class: "nut-sku-stepper-count" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_inputnumber = resolveComponent("nut-inputnumber");
  return openBlock(), createElementBlock("view", _hoisted_1$4, [
    createElementVNode("view", _hoisted_2$4, toDisplayString(_ctx.stepperTitle), 1),
    createElementVNode("view", {
      class: "nut-sku-stepper-limit",
      innerHTML: _ctx.getExtraText()
    }, null, 8, _hoisted_3$3),
    createElementVNode("view", _hoisted_4$3, [
      createVNode(_component_nut_inputnumber, {
        modelValue: _ctx.goodsCount,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.goodsCount = $event),
        min: _ctx.stepperMin,
        max: _ctx.stepperMax,
        onAdd: _ctx.add,
        onReduce: _ctx.reduce,
        onOverlimit: _ctx.overlimit,
        onChange: _ctx.changeStepper
      }, null, 8, ["modelValue", "min", "max", "onAdd", "onReduce", "onOverlimit", "onChange"])
    ])
  ]);
}
var SkuStepper = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
const { componentName: componentName$2, create: create$3 } = createComponent("sku-operate");
const _sfc_main$3 = create$3({
  props: {
    btnOptions: {
      type: Array,
      default: () => ["confirm"]
    },
    btnExtraText: {
      type: String,
      default: ""
    },
    buyText: {
      type: String,
      default: "\u7ACB\u5373\u8D2D\u4E70"
    },
    addCartText: {
      type: String,
      default: "\u52A0\u5165\u8D2D\u7269\u8F66"
    },
    confirmText: {
      type: String,
      default: "\u786E\u5B9A"
    }
  },
  emits: ["click", "changeSku", "changeBuyCount", "clickBtnOperate"],
  setup(props, { emit, slots }) {
    const getBtnDesc = (type) => {
      let mapD = {
        confirm: props.confirmText,
        cart: props.addCartText,
        buy: props.buyText
      };
      return mapD[type];
    };
    onMounted(() => {
      console.log(slots);
    });
    const getSlots = (name) => slots[name];
    const clickBtnOperate = (btn) => {
      emit("clickBtnOperate", btn);
    };
    return {
      getBtnDesc,
      clickBtnOperate,
      getSlots
    };
  }
});
const _hoisted_1$3 = {
  key: 0,
  class: "nut-sku-operate"
};
const _hoisted_2$3 = ["innerHTML"];
const _hoisted_3$2 = {
  key: 1,
  class: "nut-sku-operate-btn"
};
const _hoisted_4$2 = ["onClick"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.btnOptions.length > 0 ? (openBlock(), createElementBlock("view", _hoisted_1$3, [
    _ctx.btnExtraText ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: "nut-sku-operate-desc",
      innerHTML: _ctx.btnExtraText
    }, null, 8, _hoisted_2$3)) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "operate-btn"),
    !_ctx.getSlots("operate-btn") ? (openBlock(), createElementBlock("view", _hoisted_3$2, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.btnOptions, (btn, i) => {
        return openBlock(), createElementBlock("view", {
          class: normalizeClass([`nut-sku-operate-btn-${btn}`, "nut-sku-operate-btn-item"]),
          key: i,
          onClick: ($event) => _ctx.clickBtnOperate(btn)
        }, toDisplayString(_ctx.getBtnDesc(btn)), 11, _hoisted_4$2);
      }), 128))
    ])) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
var SkuOperate = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const { componentName: componentName$1, create: create$2 } = createComponent("sku");
const _sfc_main$2 = create$2({
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    sku: {
      type: Array,
      default: []
    },
    goods: {
      type: Object,
      default: {}
    },
    stepperMax: {
      type: [Number, String],
      default: 99999
    },
    stepperMin: {
      type: [Number, String],
      default: 1
    },
    btnOptions: {
      type: Array,
      default: () => ["confirm"]
    },
    stepperTitle: {
      type: String,
      default: "\u8D2D\u4E70\u6570\u91CF"
    },
    stepperExtraText: {
      type: [Function, Boolean],
      default: false
    },
    btnExtraText: {
      type: String,
      default: ""
    },
    buyText: {
      type: String,
      default: "\u7ACB\u5373\u8D2D\u4E70"
    },
    addCartText: {
      type: String,
      default: "\u52A0\u5165\u8D2D\u7269\u8F66"
    },
    confirmText: {
      type: String,
      default: "\u786E\u5B9A"
    }
  },
  emits: [
    "update:visible",
    "selectSku",
    "changeStepper",
    "clickBtnOperate",
    "clickCloseIcon",
    "clickOverlay",
    "close",
    "reduce",
    "add",
    "overLimit",
    "clickOverlay"
  ],
  components: {
    SkuHeader,
    SkuSelect,
    SkuStepper,
    SkuOperate
  },
  setup(props, { emit, slots }) {
    const showPopup = ref(props.visible);
    const goodsCount = ref(props.stepperMin);
    watch(() => props.visible, (value) => {
      showPopup.value = value;
    });
    watch(() => showPopup.value, (value) => {
      if (value == false) {
        close();
      }
    });
    onMounted(() => {
    });
    const getSlots = (name) => slots[name];
    const selectSku = (skus) => {
      emit("selectSku", skus);
    };
    const changeStepper = (value) => {
      goodsCount.value = value;
      emit("changeStepper", value);
    };
    const add = (value) => {
      emit("add", value);
    };
    const reduce = (value) => {
      emit("reduce", value);
    };
    const stepperOverLimit = (count2) => {
      emit("overLimit", count2);
    };
    const clickBtnOperate = (btn) => {
      emit("clickBtnOperate", {
        type: btn,
        value: goodsCount.value
      });
    };
    const closePopup = (type) => {
      if (type == "icon") {
        emit("click-close-icon");
      }
      if (type == "overlay") {
        emit("click-overlay");
      }
      if (type == "close") {
        emit("close");
      }
      showPopup.value = false;
    };
    const close = () => {
      emit("update:visible", false);
    };
    return {
      showPopup,
      closePopup,
      selectSku,
      changeStepper,
      stepperOverLimit,
      clickBtnOperate,
      add,
      reduce,
      getSlots
    };
  }
});
const _hoisted_1$2 = { class: "nut-sku" };
const _hoisted_2$2 = { class: "nut-sku-content" };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_sku_header = resolveComponent("sku-header");
  const _component_SkuSelect = resolveComponent("SkuSelect");
  const _component_sku_stepper = resolveComponent("sku-stepper");
  const _component_sku_operate = resolveComponent("sku-operate");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    position: "bottom",
    closeable: "",
    round: "",
    visible: _ctx.showPopup,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.showPopup = $event),
    onClickCloseIcon: _cache[1] || (_cache[1] = ($event) => _ctx.closePopup("icon")),
    onClickOverlay: _cache[2] || (_cache[2] = ($event) => _ctx.closePopup("overlay")),
    onClose: _cache[3] || (_cache[3] = ($event) => _ctx.closePopup("close")),
    style: { "height": "75%" }
  }, {
    default: withCtx(() => [
      createElementVNode("view", _hoisted_1$2, [
        renderSlot(_ctx.$slots, "sku-header"),
        !_ctx.getSlots("sku-header") ? (openBlock(), createBlock(_component_sku_header, {
          key: 0,
          goods: _ctx.goods
        }, createSlots({ _: 2 }, [
          _ctx.getSlots("sku-header-price") ? {
            name: "sku-header-price",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "sku-header-price")
            ])
          } : void 0,
          _ctx.getSlots("sku-header-extra") ? {
            name: "sku-header-extra",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "sku-header-extra")
            ])
          } : void 0
        ]), 1032, ["goods"])) : createCommentVNode("", true),
        createElementVNode("view", _hoisted_2$2, [
          renderSlot(_ctx.$slots, "sku-select-top"),
          renderSlot(_ctx.$slots, "sku-select"),
          !_ctx.getSlots("sku-select") ? (openBlock(), createBlock(_component_SkuSelect, {
            key: 0,
            sku: _ctx.sku,
            onSelectSku: _ctx.selectSku
          }, null, 8, ["sku", "onSelectSku"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "sku-stepper"),
          !_ctx.getSlots("sku-stepper") ? (openBlock(), createBlock(_component_sku_stepper, {
            key: 1,
            goods: _ctx.goods,
            stepperTitle: _ctx.stepperTitle,
            stepperMax: _ctx.stepperMax,
            stepperMin: _ctx.stepperMin,
            stepperExtraText: _ctx.stepperExtraText,
            onAdd: _ctx.add,
            onReduce: _ctx.reduce,
            onChangeStepper: _ctx.changeStepper,
            onOverLimit: _ctx.stepperOverLimit
          }, null, 8, ["goods", "stepperTitle", "stepperMax", "stepperMin", "stepperExtraText", "onAdd", "onReduce", "onChangeStepper", "onOverLimit"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "sku-stepper-bottom")
        ]),
        createVNode(_component_sku_operate, {
          btnOptions: _ctx.btnOptions,
          btnExtraText: _ctx.btnExtraText,
          buyText: _ctx.buyText,
          addCartText: _ctx.addCartText,
          confirmText: _ctx.confirmText,
          onClickBtnOperate: _ctx.clickBtnOperate
        }, createSlots({ _: 2 }, [
          _ctx.getSlots("sku-operate") ? {
            name: "operate-btn",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "sku-operate")
            ])
          } : void 0
        ]), 1032, ["btnOptions", "btnExtraText", "buyText", "addCartText", "confirmText", "onClickBtnOperate"])
      ])
    ]),
    _: 3
  }, 8, ["visible"]);
}
var Sku = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const { create: create$1 } = createComponent("card");
const _sfc_main$1 = create$1({
  props: {
    imgUrl: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    price: {
      type: String,
      default: ""
    },
    vipPrice: {
      type: String,
      default: ""
    },
    shopDesc: {
      type: String,
      default: ""
    },
    delivery: {
      type: String,
      default: ""
    },
    shopName: {
      type: String,
      default: ""
    }
  },
  setup(props, { emit, slots }) {
    console.log(slots["origin"]);
    const isHaveSlot = (slot) => {
      return slots[slot];
    };
    return {
      isHaveSlot
    };
  }
});
const _hoisted_1$1 = { class: "nut-card" };
const _hoisted_2$1 = { class: "nut-card__left" };
const _hoisted_3$1 = ["src"];
const _hoisted_4$1 = { class: "nut-card__right" };
const _hoisted_5$1 = { class: "nut-card__right__title" };
const _hoisted_6$1 = { class: "nut-card__right__price" };
const _hoisted_7$1 = { class: "nut-card__right__other" };
const _hoisted_8$1 = { class: "nut-card__right__shop" };
const _hoisted_9 = { class: "nut-card__right__shop__name" };
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_price = resolveComponent("nut-price");
  const _component_nut_tag = resolveComponent("nut-tag");
  return openBlock(), createElementBlock("div", _hoisted_1$1, [
    createElementVNode("div", _hoisted_2$1, [
      createElementVNode("img", {
        src: _ctx.imgUrl,
        alt: ""
      }, null, 8, _hoisted_3$1)
    ]),
    createElementVNode("div", _hoisted_4$1, [
      createElementVNode("div", _hoisted_5$1, toDisplayString(_ctx.title), 1),
      renderSlot(_ctx.$slots, "prolist"),
      createElementVNode("div", _hoisted_6$1, [
        createVNode(_component_nut_price, { price: _ctx.price }, null, 8, ["price"]),
        _ctx.isHaveSlot("origin") ? renderSlot(_ctx.$slots, "origin", { key: 0 }) : (openBlock(), createBlock(_component_nut_price, {
          key: 1,
          class: "nut-card__right__price__origin",
          price: _ctx.vipPrice
        }, null, 8, ["price"]))
      ]),
      createElementVNode("div", _hoisted_7$1, [
        _ctx.isHaveSlot("shop-tag") ? renderSlot(_ctx.$slots, "shop-tag", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createVNode(_component_nut_tag, { type: "danger" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.shopDesc), 1)
            ]),
            _: 1
          }),
          createVNode(_component_nut_tag, { plain: "" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.delivery), 1)
            ]),
            _: 1
          })
        ], 64))
      ]),
      createElementVNode("div", _hoisted_8$1, [
        createElementVNode("div", _hoisted_9, toDisplayString(_ctx.shopName), 1),
        renderSlot(_ctx.$slots, "footer")
      ])
    ])
  ]);
}
var Card = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
var RenderColumn = {
  setup(props) {
    return () => h(`view`, {}, props.slots());
  },
  props: {
    slots: Object
  }
};
const component = (componentName2) => {
  return {
    components: {
      RenderColumn
    },
    props: {
      bordered: {
        type: Boolean,
        default: true
      },
      columns: {
        type: Array,
        default: () => {
          return [];
        }
      },
      data: {
        type: Object,
        default: () => {
          return {};
        }
      },
      summary: {
        type: Function,
        default: null
      },
      striped: {
        type: Boolean,
        default: false
      }
    },
    emits: ["sorter"],
    setup(props, { emit, slots }) {
      const state = reactive({
        curData: props.data
      });
      const classes = computed(() => {
        const prefixCls = componentName2;
        return {
          [prefixCls]: true
        };
      });
      const cellClasses = (item) => {
        return {
          "nut-table__main__head__tr--border": props.bordered,
          [`nut-table__main__head__tr--align${item.align ? item.align : ""}`]: true
        };
      };
      const getColumnItem = (value) => {
        return props.columns.filter((item) => item.key === value)[0];
      };
      const handleSorterClick = (item) => {
        if (item.sorter) {
          emit("sorter", item);
          state.curData = typeof item.sorter === "function" ? state.curData.sort(item.sorter) : item.sorter === "default" ? state.curData.sort() : state.curData;
        }
      };
      const sortDataItem = () => {
        return props.columns.map((value) => {
          return value.key;
        });
      };
      watch(() => props.data, (val) => {
        state.curData = val.slice();
      });
      return __spreadProps(__spreadValues({}, toRefs(state)), {
        classes,
        cellClasses,
        getColumnItem,
        handleSorterClick,
        sortDataItem
      });
    }
  };
};
const { componentName, create } = createComponent("table");
const _sfc_main = create(component(componentName));
const _hoisted_1 = { class: "nut-table__main__head" };
const _hoisted_2 = { class: "nut-table__main__head__tr" };
const _hoisted_3 = ["onClick"];
const _hoisted_4 = { class: "nut-table__main__body" };
const _hoisted_5 = {
  key: 0,
  class: "nut-table__summary"
};
const _hoisted_6 = ["innerHTML"];
const _hoisted_7 = {
  key: 1,
  class: "nut-table__nodata"
};
const _hoisted_8 = {
  key: 0,
  class: "nut-table__nodata__text"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_icon = resolveComponent("nut-icon");
  const _component_RenderColumn = resolveComponent("RenderColumn");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createElementVNode("view", {
      class: normalizeClass(["nut-table__main", { "nut-table__main--striped": _ctx.striped }])
    }, [
      createElementVNode("view", _hoisted_1, [
        createElementVNode("view", _hoisted_2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (item) => {
            return openBlock(), createElementBlock("span", {
              class: normalizeClass(["nut-table__main__head__tr__th", _ctx.cellClasses(item)]),
              key: item.key,
              onClick: ($event) => _ctx.handleSorterClick(item)
            }, [
              createTextVNode(toDisplayString(item.title) + " ", 1),
              renderSlot(_ctx.$slots, "icon"),
              !_ctx.$slots.icon && item.sorter ? (openBlock(), createBlock(_component_nut_icon, {
                key: 0,
                name: "down-arrow",
                size: "12px"
              })) : createCommentVNode("", true)
            ], 10, _hoisted_3);
          }), 128))
        ])
      ]),
      createElementVNode("view", _hoisted_4, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.curData, (item) => {
          return openBlock(), createElementBlock("view", {
            class: "nut-table__main__body__tr",
            key: item
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.sortDataItem(), (value) => {
              return openBlock(), createElementBlock("span", {
                class: normalizeClass(["nut-table__main__body__tr__td", _ctx.cellClasses(_ctx.getColumnItem(value))]),
                key: value
              }, [
                createTextVNode(toDisplayString(typeof item[value] !== "function" ? item[value] : "") + " ", 1),
                typeof item[value] === "function" ? (openBlock(), createBlock(_component_RenderColumn, {
                  key: 0,
                  slots: item[value]
                }, null, 8, ["slots"])) : createCommentVNode("", true)
              ], 2);
            }), 128))
          ]);
        }), 128))
      ])
    ], 2),
    _ctx.summary ? (openBlock(), createElementBlock("view", _hoisted_5, [
      createElementVNode("span", {
        class: "nut-table__summary__text",
        innerHTML: _ctx.summary().value
      }, null, 8, _hoisted_6)
    ])) : createCommentVNode("", true),
    !_ctx.curData.length ? (openBlock(), createElementBlock("view", _hoisted_7, [
      createElementVNode("div", {
        class: normalizeClass(["nut-table__nodata", { "nut-table__nodata--border": _ctx.bordered }])
      }, [
        renderSlot(_ctx.$slots, "nodata"),
        !_ctx.$slots.nodata ? (openBlock(), createElementBlock("div", _hoisted_8, " \u6682\u65E0\u6570\u636E ")) : createCommentVNode("", true)
      ], 2)
    ])) : createCommentVNode("", true)
  ], 2);
}
var Table = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
function install(app) {
  const packages = [Avatar, Button, Cell, CellGroup, _sfc_main$1o, Price, OverLay, Divider, _sfc_main$1h, Col, Row, _ImagePreview, Swipe, ActionSheet, BackTop, Collapse, CollapseItem, Drag, _Dialog, InfiniteLoading, NotifyFunction, Range, Video, Popup, _sfc_main$$, Step, Swiper, SwiperItem, Switch, ToastFunction, Progress, CircleProgress, NoticeBar, SearchBar, Empty, Navbar, FixedNav, Menu, MenuItem, Tabbar, TabbarItem, Elevator, Pagination, Tabs, TabPane, Indicator, _sfc_main$H, GridItem, SideNavBar, SideNavBarItem, SubSideNavBar, Calendar, _sfc_main$A, _sfc_main$z, DatePicker, InputNumber, Input, _sfc_main$t, _sfc_main$s, Rate, Picker, ShortPassword, TextArea, Uploader, CountUp, NumberKeyboard, CountDown, Badge, Tag, Popover, Form, FormItem, Skeleton, Cascader, Address, Barrage, Signature, TimeSelect, TimePannel, TimeDetail, Sku, Card, Table];
  packages.forEach((item) => {
    if (item.install) {
      app.use(item);
    } else if (item.name) {
      app.component(item.name, item);
    }
  });
}
const version = "3.1.16";
var nutui_vue_build = { install, version };
export { ActionSheet, Address, Avatar, BackTop, Badge, Barrage, Button, Calendar, Card, Cascader, Cell, CellGroup, _sfc_main$A as Checkbox, _sfc_main$z as CheckboxGroup, CircleProgress, Col, Collapse, CollapseItem, CountDown, CountUp, DatePicker, _Dialog as Dialog, Divider, Drag, Elevator, Empty, FixedNav, Form, FormItem, _sfc_main$H as Grid, GridItem, _sfc_main$1o as Icon, _ImagePreview as ImagePreview, Indicator, InfiniteLoading, Input, InputNumber, _sfc_main$1h as Layout, Menu, MenuItem, Navbar, NoticeBar, NotifyFunction as Notify, NumberKeyboard, OverLay, Pagination, Picker, Popover, Popup, Price, Progress, _sfc_main$t as Radio, _sfc_main$s as RadioGroup, Range, Rate, Row, SearchBar, ShortPassword, SideNavBar, SideNavBarItem, Signature, Skeleton, Sku, Step, _sfc_main$$ as Steps, SubSideNavBar, Swipe, Swiper, SwiperItem, Switch, TabPane, Tabbar, TabbarItem, Table, Tabs, Tag, TextArea, TimeDetail, TimePannel, TimeSelect, ToastFunction as Toast, Uploader, Video, nutui_vue_build as default, install, version };
